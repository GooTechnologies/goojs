/* Goo Engine UNOFFICIAL
 * Copyright 2015 Goo Technologies AB
 */
!function(){"use strict";function a(a,c){function d(a){return this&&this.constructor===d?(this._keys=[],this._values=[],this.objectOnly=c,void(a&&b.call(this,a))):new d(a)}return c||q(a,"size",{get:m}),a.constructor=d,d.prototype=a,d}function b(a){this.add?a.forEach(this.add,this):a.forEach(function(a){this.set(a[0],a[1])},this)}function c(a){return this.has(a)&&(this._keys.splice(p,1),this._values.splice(p,1)),p>-1}function d(a){return this.has(a)?this._values[p]:void 0}function e(a,b){if(this.objectOnly&&b!==Object(b))throw new TypeError("Invalid value used as weak collection key");if(b!=b||0===b)for(p=a.length;p--&&!r(a[p],b););else p=a.indexOf(b);return p>-1}function f(a){return e.call(this,this._values,a)}function g(a){return e.call(this,this._keys,a)}function h(a,b){return this.has(a)?this._values[p]=b:this._values[this._keys.push(a)-1]=b,this}function i(a){return this.has(a)||this._values.push(a),this}function j(){this._values.length=0}function k(){return this._values.slice()}function l(){return this._keys.slice()}function m(){return this._values.length}function n(a,b){var c=this,d=c._values.slice();c._keys.slice().forEach(function(e,f){a.call(b,d[f],e,c)})}function o(a,b){var c=this;c._values.slice().forEach(function(d){a.call(b,d,d,c)})}Object.is||(Object.is=function(a,b){return 0===a&&0===b?1/a===1/b:a!==a?b!==b:a===b});var p,q=Object.defineProperty,r=Object.is;window.Set||(window.Map=a({"delete":c,has:g,get:d,set:h,keys:l,values:k,forEach:n,clear:j}),window.Set=a({has:f,add:i,"delete":c,clear:j,values:k,forEach:o}))}();
window.goo = {};
goo.Selection = (function () {
	'use strict';

	/**
	 * Generic selection class
	 */
	function Selection() {
		this.stack = [];

		//! AT: may rather use toArray
		if (arguments.length === 1) {
			var argument = arguments[0];
			if (argument instanceof Selection) {
				if (argument.top) {
					this.stack.push(argument.top);
				}
			} else if (Array.isArray(argument)) {
				this.stack.push(argument);
			} else {
				this.stack.push([argument]);
			}
		} else if (arguments.length > 1) {
			this.stack.push(Array.prototype.slice.call(arguments, 0));
		}

		if (this.stack.length > 0) {
			this.stack[0] = removeDuplicates(this.stack[0]);
		}

		this.top = this.stack.length === 0 ? null : this.stack[0];
	}

	/**
	 * Empty selection
	 * @type {Selection}
	 */
	Selection.EMPTY = new Selection();

	/**
	 * Returns true if the selection contains a specific element
	 * @param element
	 * @returns {boolean}
	 */
	Selection.prototype.contains = function (element) {
		if (this.top === null) { return false; }

		return this.top.indexOf(element) !== -1;
	};

	/**
	 * Returns the size of this selection
	 * @returns {number}
	 */
	Selection.prototype.size = function () {
		if (this.top === null) { return 0; }

		return this.top.length;
	};

	/**
	 * Applies a function on each element until `false` is returned
	 * @param {Function} fun The function to apply
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.each = function (fun) {
		//! AT: this check should be done automatically before each method
		if (this.top === null) { return this; }

		for (var i = 0; i < this.top.length; i++) {
			if (fun(this.top[i], i) === false) {
				break;
			}
		}

		return this;
	};

	/**
	 * Alias for `each`
	 * @type {Function}
	 */
	Selection.prototype.forEach = Selection.prototype.each;

	/**
	 * Applies a filter on the elements of this selection
	 * @param predicate The filter used for filtering
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.filter = function (predicate) {
		//! AT: this check should be done automatically before each method
		if (this.top === null) { return this; }

		var top = this.top.filter(predicate);
		this.stack.push(top);
		this.top = top;

		return this;
	};

	/**
	 * Applies a function on the elements of this selection producing a new collection
	 * @param fun The function to apply to each element
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.map = function (fun) {
		//! AT: this check should be done automatically before each method
		if (this.top === null) { return this; }

		var top = this.top.map(fun);
		this.stack.push(top);
		this.top = top;

		return this;
	};

	/**
	 * @private
	 * @param fun
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.flatMap = function (fun) {
		//! AT: this check should be done automatically before each method
		if (this.top === null) { return this; }

		var map = this.top.map(fun);
		var flatMap = map.reduce(function (prev, cur) { return prev.concat(cur); }, []);
		this.stack.push(flatMap);
		this.top = flatMap;

		return this;
	};

	/**
	 * Reduces the entire selection to a single element by applying a function on every element and an accumulated value
	 * @param fun The function used to reduce the selection
	 * @param initialValue The value used for the first call of `fun`
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.reduce = function (fun, initialValue) {
		//! AT: this check should be done automatically before each method
		if (this.top === null) { return this; }

		var top = [this.top.reduce(fun, initialValue)];
		this.stack.push(top);
		this.top = top;

		return this;
	};

	/**
	 * Adds elements to this selection. Any resulting duplicates are removed.
	 * @param {(Element | Array<Element> | Selection)} elements The element(s) to add
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.and = function () {
		if (this.top === null) { return this; }

		var elements = toArray.apply(null, arguments);

		var union = this.top.concat(elements);
		union = removeDuplicates(union);
		this.stack.push(union);
		this.top = union;

		return this;
	};

	/**
	 * Returns the common elements between this selection and the given parameter(s)
	 * @param {(Element | Array<Element> | Selection)} elements
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.intersects = function () {
		if (this.top === null) { return this; }

		var elements = toArray.apply(null, arguments);

		var intersection = [];

		//! AT: when searching for arbitrary objects in an array searching by pointer (reference) is the only way
		// hopefully, if longArray is represented as some tree/hash with fast .indexOf()
		// so that I can iterate over the shorter array and do query the long array
		// best case: short array has one element and if indexOf takes O(log(longArray.length)) (or even better) time
		// worst case scenario: both arrays are of the same length and this optimisation is useless - it takes
		// O(shortArray.length * log(longArray.length)) time
		var shortArray, longArray;
		if (elements.length > this.top.length) {
			shortArray = this.top;
			longArray = elements;
		} else {
			shortArray = elements;
			longArray = this.top;
		}

		for (var i = 0; i < shortArray.length; i++) {
			var element = shortArray[i];
			if (longArray.indexOf(element) !== -1) {
				intersection.push(element);
			}
		}

		this.stack.push(intersection);
		this.top = intersection;

		return this;
	};

	/**
	 * Removes elements from the current selection
	 * @param elements {(Element | Array<Element> | Selection)} Elements to remove from the selection
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.without = function () {
		if (this.top === null) { return this; }

		var elements = toArray.apply(null, arguments);

		var difference = [];

		for (var i = 0; i < this.top.length; i++) {
			var element = this.top[i];
			if (elements.indexOf(element) === -1) {
				difference.push(element);
			}
		}

		this.stack.push(difference);
		this.top = difference;

		return this;
	};

	/**
	 * Adds the previous selection to the current selection. Resulting duplicates are removed.
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.andSelf = function () {
		if (this.top === null) { return this; }

		if (this.stack.length <= 1) { return this; }

		var prev = this.stack[this.stack.length - 2];

		var union = prev.concat(this.top);
		union = removeDuplicates(union);
		this.stack.push(union);
		this.top = union;

		return this;
	};

	/**
	 * Discards the last operation done on the selection
	 * @returns {Selection} Returns self to allow chaining
	 */
	Selection.prototype.end = function () {
		if (this.top === null) { return this; }

		this.stack.pop();

		if (this.stack.length === 0) {
			this.top = null;
		} else {
			this.top = this.stack[this.stack.length - 1];
		}

		return this;
	};

	/**
	 * Returns the first object of the selection
	 * @returns {Element}
	 */
	//! AT: this may not be so crucial to have // might as well just use .get
	Selection.prototype.first = function () {
		return this.top === null ? null : this.top[0];
	};

	/**
	 * Clones the selection and its history
	 * @returns {Selection} Returns a copy of this selection object
	 */
	Selection.prototype.clone = function () {
		var clone = new Selection();

		//! AT: the array pointed by top is read only it can be shallow copied
		clone.top = this.top;

		// this array however is modified
		clone.stack = this.stack.concat([]);

		return clone;
	};

	/**
	 * Returns the element on the specified position or the whole selection as an array if position is not given
	 * @param {number} [index] Index of the desired element; can handle negative indices (Ex: -1 is the last element)
	 * @returns {Array}
	 */
	Selection.prototype.get = function (index) {
		if (typeof index !== 'number') {
			return this.top === null ? [] : this.top.concat([]);
		}
		if (index < 0) {
			return this.top === null ? undefined : this.top[this.top.length + index];
		} else {
			return this.top === null ? undefined : this.top[index];
		}
	};

	/**
	 * Returns the selection as an array
	 * @returns {Array}
	 */
	Selection.prototype.toArray = function () {
		return this.top === null ? [] : this.top.concat([]);
	};

	//! AT: slow //will be faster for EntitySelection
	function removeDuplicates(array) {
		var newArray = [];

		for (var i = 0; i < array.length; i++) {
			var element = array[i];
			// hopefully lastIndexOf is faster than O(n)
			if (array.lastIndexOf(element) === i) {
				newArray.push(element);
			}
		}

		return newArray;
	}

	/**
	 * Converts anything (nothing, a Selection, an array or more arguments) to an array
	 * @memberOf Selection#
	 * @private
	 * @returns {*}
	 */
	function toArray() {
		if (arguments.length === 1) {
			var argument = arguments[0];
			if (argument instanceof Selection) {
				if (argument.top) {
					return argument.top;
				} else {
					return [];
				}
			} else if (Array.isArray(argument)) {
				return argument;
			} else {
				return [argument];
			}
		} else if (arguments.length > 1) {
			return Array.prototype.slice.call(arguments, 0);
		} else {
			return [];
		}
	}

	return Selection;
})();
goo.EntitySelection = (function (
	Selection
) {
	'use strict';

	/**
	 * A specialised selection object for entities
	 * @extends Selection
	 */
	function EntitySelection() {
		Selection.apply(this, arguments);
	}

	EntitySelection.prototype = Object.create(Selection.prototype);
	EntitySelection.prototype.constructor = EntitySelection;

	/**
	 * Adds entities to this selection. Any resulting duplicates are removed.
	 * @param {(Entity | Array<Entity> | EntitySelection)} entities The entities to add
	 * @returns {EntitySelection} Returns self to allow chaining
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/EntitySelection/EntitySelection-setOps-example.html Working example
	 */
	EntitySelection.prototype.and = function () {
		if (this.top === null) { return this; }

		var union;

		var entities = toArray.apply(null, arguments);

		//! AT: this long/short separation only minimizes the number of ifs performed
		// while costing more memory (which is allocated on the stack anyways since the hashTable array never leaves this function
		// would love to see a benchmark though
		var shortArray, longArray;
		if (entities.length > this.top.length) {
			shortArray = this.top;
			longArray = entities;
		} else {
			shortArray = entities;
			longArray = this.top;
		}

		var hashTable = [];
		for (var i = 0; i < longArray.length; i++) {
			var id = longArray[i].id;
			hashTable[id] = true;
		}

		union = longArray.concat([]);

		for (var i = 0; i < shortArray.length; i++) {
			if (!hashTable[shortArray[i].id]) {
				union.push(shortArray[i]);
			}
		}

		this.stack.push(union);
		this.top = union;

		return this;
	};

	/**
	 * Returns the common entities between this selection and the given parameter(s)
	 * @param {(Entity | Array<Entity> | EntitySelection)} entities
	 * @returns {EntitySelection} Returns self to allow chaining
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/EntitySelection/EntitySelection-setOps-example.html Working example
	 */
	EntitySelection.prototype.intersects = function () {
		if (this.top === null) { return this; }

		var intersection;

		var entities = toArray.apply(null, arguments);

		//! AT: this long/short separation only minimizes the number of ifs performed
		// while costing more memory (which is allocated on the stack anyways since the hashTable array never leaves this function
		// would love to see a benchmark though
		var shortArray, longArray;
		if (entities.length > this.top.length) {
			shortArray = this.top;
			longArray = entities;
		} else {
			shortArray = entities;
			longArray = this.top;
		}

		var hashTable = [];
		for (var i = 0; i < longArray.length; i++) {
			var id = longArray[i].id;
			hashTable[id] = true;
		}

		intersection = [];
		for (var i = 0; i < shortArray.length; i++) {
			if (hashTable[shortArray[i].id]) {
				intersection.push(shortArray[i]);
			}
		}

		this.stack.push(intersection);
		this.top = intersection;

		return this;
	};

	/**
	 * Removes entities from the current selection
	 * @param {(Entity | Array<Entity> | EntitySelection)} entities Entities to remove from the selection
	 * @returns {EntitySelection} Returns self to allow chaining
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/EntitySelection/EntitySelection-setOps-example.html Working example
	 */
	EntitySelection.prototype.without = function () {
		if (this.top === null) { return this; }

		var difference;

		var entities = toArray.apply(null, arguments);

		var hashTable = [];
		for (var i = 0; i < entities.length; i++) {
			var id = entities[i].id;
			hashTable[id] = true;
		}

		difference = [];
		for (var i = 0; i < this.top.length; i++) {
			if (!hashTable[this.top[i].id]) {
				difference.push(this.top[i]);
			}
		}

		this.stack.push(difference);
		this.top = difference;

		return this;
	};

	/**
	 * Adds the previous selection to the current selection. Resulting duplicates are removed.
	 * @returns {EntitySelection} Returns self to allow chaining
	 */
	EntitySelection.prototype.andSelf = function () {
		if (this.top === null) { return this; }

		if (this.stack.length <= 1) { return this; }

		var prev = this.stack[this.stack.length - 2];

		return this.and.apply(this, prev);
	};

	//! AT: the transform component/system should install these
	/**
	 * Returns the parents of all entities in this selection
	 * @returns {EntitySelection} Returns self to allow chaining
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/EntitySelection/EntitySelection-parent-example.html Working example
	 */
	EntitySelection.prototype.parent = function () {
		if (this.top === null) { return this; }

		var hashTable = [];

		var parents = this.top.filter(function (entity) {
			if (!entity.transformComponent.parent) {
				return false;
			} else if (hashTable[entity.transformComponent.parent.entity.id]) {
				return false;
			} else {
				hashTable[entity.transformComponent.parent.entity.id] = true;
				return true;
			}
		}).map(function (entity) {
			return entity.transformComponent.parent.entity;
		});
		this.stack.push(parents);
		this.top = parents;

		return this;
	};

	/**
	 * Returns the children of all entities in this selection
	 * @returns {EntitySelection} Returns self to allow chaining
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/EntitySelection/EntitySelection-children-example.html Working example
	 */
	EntitySelection.prototype.children = function () {
		// could use flatMap
		if (this.top === null) { return this; }

		var children = this.top.map(function (entity) {
			return entity.transformComponent.children.map(function (childTransform) {
				return childTransform.entity;
			});
		});
		var flatChildren = children.reduce(function (prev, cur) { return prev.concat(cur); }, []);
		this.stack.push(flatChildren);
		this.top = flatChildren;

		return this;
	};

	/**
	 * Installs a method that acts upon entities on the prototype of EntitySelection
	 * @hidden
	 * @param method
	 * @param name
	 * @param dependentComponent
	 */
	EntitySelection.installMethod = function (method, name, dependentComponent) {
		EntitySelection.prototype[name] = function () {
			if (this.top === null) { return this; }

			for (var i = 0; i < this.top.length; i++) {
				var entity = this.top[i];

				if (entity.hasComponent(dependentComponent)) {
					method.apply(entity, arguments);
				}
			}

			return this;
		};
	};

	/**
	 * Converts anything (nothing, an EntitySelection, an array or more arguments) to an array
	 * @memberOf EntitySelection#
	 * @private
	 * @returns {*}
	 */
	function toArray() {
		if (arguments.length === 1) {
			var argument = arguments[0];
			if (argument instanceof EntitySelection) {
				if (argument.top) {
					return argument.top;
				} else {
					return [];
				}
			} else if (Array.isArray(argument)) {
				return argument;
			} else {
				return [argument];
			}
		} else if (arguments.length > 1) {
			return Array.prototype.slice.call(arguments, 0);
		} else {
			return [];
		}
	}

	return EntitySelection;
})(goo.Selection);
goo.Component = (function (EntitySelection) {
	'use strict';

	/**
	 * Base class/module for all components.
	 * See [this engine overview article]{@link http://www.gootechnologies.com/learn/tutorials/engine/engine-overview/} for more info.
	 */
	function Component() {
		/**
		 * If the component should be processed for containing entities.
		 * @type {boolean}
		 */
		this.enabled = true;

		this.installedAPI = new Set();

		this.forceDebug = false;
	}

	/**
	 * Injects public methods of this component into the host entity.
	 * @param entity
	 * @private
	 */
	Component.prototype.applyAPI = function (entity) {
		var api = this.api;
		if (!api) {
			return;
		}
		var keys = Object.keys(api);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			if (typeof entity[key] === 'undefined') {
				entity[key] = api[key];
				this.installedAPI.add(key);
			} else {
				console.warn('Could not install method ' + key + ' of ' + this.type + ' as it is already taken');
			}
		}
	};

	/**
	 * Removed any methods attached to the host entity that belong to this component's API.
	 * @param entity
	 * @private
	 */
	Component.prototype.removeAPI = function (entity) {
		this.installedAPI.forEach(function (key) {
			delete entity[key];
		});
	};

	Component.applyEntitySelectionAPI = function (entitySelectionAPI, componentType) {
		if (!entitySelectionAPI) { return; }

		var keys = Object.keys(entitySelectionAPI);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			if (typeof EntitySelection[key] === 'undefined') {
				EntitySelection.installMethod(entitySelectionAPI[key], key, componentType);
			} else {
				console.warn('Could not install method ' + key + ' on EntitySelection as it is already taken');
			}
		}
	};

	return Component;
})(goo.EntitySelection);
goo.StringUtils = (function () {
	'use strict';

	/**
	 * Provides string manipulation methods
	 */
	function StringUtils() {}

	StringUtils.endsWith = function (str, suffix) {
		return str.indexOf(suffix, str.length - suffix.length) !== -1;
	};

	StringUtils.startsWith = function (str, prefix) {
		return str.indexOf(prefix) === 0;
	};

	StringUtils.capitalize = function (str) {
		return str.charAt(0).toUpperCase() + str.substring(1);
	};

	StringUtils.uncapitalize = function (str) {
		return str.charAt(0).toLowerCase() + str.substring(1);
	};

	StringUtils.createUniqueId = function (type) {
		var date = Date.now();
		var uuid = 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
			// | 0 is a hack to floor a number, so this is a random number between 0 and 15
			var randomNumber = (date + Math.random() * 16) % 16 | 0;
			if (c === 'x') {
				return randomNumber.toString(16);
			} else {
				// Set bit 6 and 7 to 0 and 1
				return (randomNumber & 0x3 | 0x8).toString(16);
			}
		});
		if (type === undefined) {
			return uuid;
		}
		return uuid + '.' + type;
	};

	/**
	 * Returns the string from the beginning of the string until the specified stop string. The stop string
	 * is not included in the returned string.
	 *
	 * If the specified stop string is not found, the whole string is returned.
	 *
	 * @param {string} string
	 * @param {string} stopString
	 */
	StringUtils.getUntil = function (string, stopString) {
		var stopIndex = string.indexOf(stopString);
		if (stopIndex === -1) {
			return string;
		} else {
			return string.slice(0, stopIndex);
		}
	};

	/**
	 * Returns the string from the last occurence of the stop string until the end. The stop string is not included in the result.
	 * @param {string} string
	 * @param {string} stopString
	 * @returns {string}
	 */
	StringUtils.getAfterLast = function (string, stopString) {
		var stopIndex = string.lastIndexOf(stopString);
		if (stopIndex === -1) {
			return string;
		} else {
			return string.slice(stopIndex + stopString.length, string.length);
		}
	};

	/**
	 * Returns the string from the index of the start string until the end of the string. The start character is
	 * not included in the returned string.
	 *
	 * If the specified start string is not found in the string, an empty string is returned.
	 *
	 * @param {string} string
	 * @param {string} startString
	 */
	StringUtils.getFrom = function (string, startString) {
		var startIndex = string.indexOf(startString);
		if (startIndex === -1) {
			return '';
		} else {
			// Adding offset equal to the length of the start string,
			// to not include the start string in the returned string.
			return string.slice(startIndex + startString.length, string.length);
		}
	};

	StringUtils.getIndexedName = function (base, takenNames, separator) {
		if (!separator) {
			separator = '_';
		}

		var re = new RegExp(base + '(' + separator + '\\d+)?');
		var i;
		var index = 0;
		for (i in takenNames) {
			var name = takenNames[i];
			var m = re.exec(name);
			if (m) {
				if (m.length > 1 && m[1]) {
					var nidx = parseInt(m[1].substring(separator.length), 10);
					if (nidx >= index) {
						index = nidx + 1;
					}
				} else {
					index = 1;
				}
			}
		}

		return base + separator + index;
	};

	StringUtils.getUniqueName = function (desiredName, takenNames, separator) {
		if (takenNames.indexOf(desiredName) === -1) {
			return desiredName;
		}

		return StringUtils.getIndexedName(desiredName, takenNames, separator);
	};

	//! AT: toASCII, in JS everything is caps (JSON, innerHTML, etc)
	StringUtils.toAscii = function (input) {
		return input.replace(/([^\x00-\x7F])/g, 'x');
	};

	/*jshint bitwise: false */
	/**
	Js implementation of Java's hashcode (sort of). Somewhat useful for creating
	unique ideas that contain [A-Za-z0-9-_]
	*/
	StringUtils.hashCode = function (str) {
		var hash = 0;

		if (str.length === 0) {
			return hash;
		}

		for (var i = 0; i < str.length; i++) {
			var character = str.charCodeAt(i);
			hash = ((hash << 5) - hash) + character;
			hash = hash & hash; // Convert to 32bit integer
		}

		return btoa(hash).replace('/', '_').replace('+', '-');
	};

	// REVIEW: idCounter is only updated on declaration, same session will always have the same seed
	// used in generating ids
	var idCounter = Date.now();

	// returns an almost unique id
	StringUtils.getUniqueId = function () {
		idCounter++;
		var stringedArguments = Array.prototype.slice.call(arguments, 0).join('');
		return StringUtils.hashCode(idCounter + '' + stringedArguments);
	};

	/**
	 * Escapes all HTML entities from a given string.
	 * @param {string} text The string whose HTML entities are to be encoded.
	 * @returns {string} The specified string with all its HTML entities encoded.
	 */
	StringUtils.escapeHtmlEntities = function (text) {
		var div = document.createElement('div');
		div.appendChild(document.createTextNode(text));

		// Any edge cases that are not escaped by the browser.
		var edgeCases = { 34: 'quot' };

		return div.innerHTML.replace(/[\u00A0-\u2666\"\']/g, function (c) {
			var entityName = edgeCases[c.charCodeAt(0)];
			return '&' + (entityName || '#' + c.charCodeAt(0)) + ';';
		});
	};

	/**
	 * Parses an URL
	 * @param {string} url
	 * @example
	 *     var url = 'http://example.com:1234/images/goo.png?param=1#fragment';
	 *     var parts = Ajax.parseURL(url);
	 *     parts.scheme			// 'http'
	 *     parts.domain			// 'example.com'
	 *     parts.user_info		// undefined
	 *     parts.port			// '1234'
	 *     parts.path			// '/images/goo.png'
	 *     parts.query_data		// 'param=1'
	 *     parts.fragment		// 'fragment'
	 */

	//! AT: this does far too much and is used only to get the extension of whatever the uri is
	// write a faster one instead

	// let's save it ourselves if the browser doesn't automagically do it
	/**
	 * @private
	 */
	var splitRegExp = new RegExp(
		'^' +
		'(?:' +
		'([^:/?#.]+)' +                         // scheme - ignore special characters
		// used by other URL parts such as :,
		// ?, /, #, and .
		':)?' +
		'(?://' +
		'(?:([^/?#]*)@)?' +                     // userInfo
		'([\\w\\d\\-\\u0100-\\uffff.%]*)' +     // domain - restrict to letters,
		// digits, dashes, dots, percent
		// escapes, and unicode characters.
		'(?::([0-9]+))?' +                      // port
		')?' +
		'([^?#]+)?' +                           // path
		'(?:\\?([^#]*))?' +                     // query
		'(?:#(.*))?' +                          // fragment
		'$');

	StringUtils.parseURL = function (uri) {
		var split = uri.match(splitRegExp);
		return {
			'scheme': split[1],
			'user_info': split[2],
			'domain': split[3],
			'port': split[4],
			'path': split[5],
			'query_data': split[6],
			'fragment': split[7]
		};
	};

	return StringUtils;
})();
goo.Entity = (function (
	Component,
	StringUtils
) {
	'use strict';

	/**
	 * An Entity is a generic container of data.
	 * This data is wrapped in [Components]{@link Component}, which usually provide isolated features (transforms, geometries, materials, scripts and so on).
	 * By setting components to an entity, the entity will get the functionality provided by the components.
	 * For example, an entity with a {@link TransformComponent} and a {@link LightComponent} will be a light source in 3D space.
	 * Note that when attaching components to an entity, methods of the component will be injected into the entity, extending its interface.
	 * @param {World} world The {@link World} this entity will be part of after calling .addToWorld().
	 * @param {string} [name] Entity name.
	 * @param {number} [id] Entity id.
	 */
	function Entity(world, name, id) {
		this._world = world;
		this._components = [];
		this.id = id !== undefined ? id : StringUtils.createUniqueId('entity');
		this._index = Entity.entityCount;

		this._tags = new Set();
		this._attributes = new Map();

		/*Object.defineProperty(this, 'id', {
			value : Entity.entityCount++,
			writable : false
		});*/
		this.name = name !== undefined ? name : 'Entity_' + this._index;

		// (move to meshrenderercomponent)
		/** Set to true to skip all processing (rendering, script updating, et cetera) of the entity.
		 * @type {boolean}
		 * @default false
		 */
		this.skip = false;

		/** Holds the hidden status of the entity. The hidden status will not however propagate to components or child entities.
		 * @deprecated The usage of this flag changed. Please use entity.hide/show() instead to change the hidden status of the entity and entity.isHidden/isVisiblyHidden() to query the status
		 * @type {boolean}
		 * @default false
		 */
		this.hidden = false;
		//! AT: users are always confused about this - I'll have to hide it

		/**
		 * Has the same function as the `hidden` property, except it's now private.
		 * @type {boolean}
		 * @private
		 */
		this._hidden = false;

		/**
		 * True if the entity is within the frustum
		 * @type {boolean}
		 */
		this.isVisible = false;

		/** Mark entity as static.
		 * Non static entities become roots in the tree of combined ones so one can have statics under a moving node that combines but you can still move the parent node.
		 * @type {boolean}
		 * @default false
		 */
		this.static = false;

		Entity.entityCount++;
	}

	//! AT: not sure if 'add' is a better name - need to search for something short and compatible with the other 'set' methods
	/**
	 * Sets components on the entity or tries to create and set components out of the supplied parameters.
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/Entity/Entity-set-example.html Working example
	 * @example
	 * // Create three entities with different components, add them to world
	 * var sphereEntity = new Entity(world).set(sphere, material, [2, 0, 0]).addToWorld();
	 * var lightEntity = new Entity(world).set(light, [0, 1, 0]).addToWorld();
	 * var spinningEntity = new Entity(world).set(box, material, [-2, 0, 0], script).addToWorld();
	 *
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.set = function () {
		for (var i = 0; i < arguments.length; i++) {
			var argument = arguments[i];
			if (argument instanceof Component) {
				this.setComponent(argument);
			} else {
				// ask all components if they are compatible with the given data
				if (!this._world) { return this; }
				var components = this._world._components;
				for (var j = 0; j < components.length; j++) {
					var component = components[j];
					var applied = component.applyOnEntity(argument, this);
					if (applied) {
						break;
					}
				}
			}
		}

		// allow chaining
		return this;
	};

	/**
	 * Add the entity to the world, making it active and processed by systems and managers.
	 * @param {boolean} [recursive=true] Add children of the transform hierarchy recursively.
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.addToWorld = function (recursive) {
		this._world.addEntity(this, recursive);
		return this;
	};

	/**
	 * Remove entity from the world.
	 * @param {boolean} [recursive=true] Remove children of the transform hierarchy recursively.
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.removeFromWorld = function (recursive) {
		this._world.removeEntity(this, recursive);
		return this;
	};

	/**
	 * lower cases the first character of the type parameter.
	 * @param {string} type name.
	 * @returns {string} lower cased type name.
	 * @private
	 */
	function getTypeAttributeName(type) {
		return type.charAt(0).toLowerCase() + type.substr(1);
	}

	/**
	 * Set component of a certain type on entity. The operation has no effect if the entity already contains a component of the same type.
	 *
	 * @param {Component} component Component to set on the entity.
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.setComponent = function (component) {
		if (this.hasComponent(component.type)) {
			return this;
		} else {
			this._components.push(component);
		}
		this[getTypeAttributeName(component.type)] = component;

		// inform the component it's being attached to an entity
		if (component.attached) {
			component.attached(this);
		}

		component.applyAPI(this);

		if (this._world && this._world.entityManager.containsEntity(this)) {
			this._world.changedEntity(this, component, 'addedComponent');
		}

		return this;
	};

	/**
	 * Checks if a component of a specific type is present or not.
	 *
	 * @param {string} type Type of component to check for (eg. 'meshDataComponent').
	 * @returns {boolean}
	 */
	Entity.prototype.hasComponent = function (type) {
		var typeAttributeName = getTypeAttributeName(type);
		return !!this[typeAttributeName];
	};

	/**
	 * Retrieve a component of a specific type.
	 *
	 * @param {string} type Type of component to retrieve (eg. 'transformComponent').
	 * @returns {Component} Component with requested type or undefined if not present.
	 */
	Entity.prototype.getComponent = function (type) {
		var typeAttributeName = getTypeAttributeName(type);
		return this[typeAttributeName];
	};

	/**
	 * Remove a component of a specific type from entity.
	 *
	 * @param {string} type Type of component to remove (eg. 'meshDataComponent').
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.clearComponent = function (type) {
		var typeAttributeName = getTypeAttributeName(type);
		var component = this[typeAttributeName];

		if (!!component && this._components.indexOf(component) > -1) {
			// inform the component it's being detached from the entity
			if (component.detached) {
				component.detached(this);
			}

			// removing API
			component.removeAPI(this);

			// removing from dense array
			var index = this._components.indexOf(component);
			this._components.splice(index, 1);

			// removing from entity
			delete this[typeAttributeName];

			// notifying the world of the change
			if (this._world && this._world.entityManager.containsEntity(this)) {
				this._world.changedEntity(this, component, 'removedComponent');
			}
		}

		return this;
	};

	/**
	 * Adds a tag to the entity.
	 * @param {string} tag
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/Entity/Entity-tags-example.html Working example
	 * @example
	 * var banana = world.createEntity().setTag('fruit').setTag('green');
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.setTag = function (tag) {
		this._tags.add(tag);
		return this;
	};

	/**
	 * Checks whether an entity has a tag or not.
	 * @param {string} tag
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/Entity/Entity-tags-example.html Working example
	 * @example
	 * if (banana.hasTag('yellow')) {
	 *     console.log('The banana is yellow');
	 * }
	 * @returns {boolean}.
	 */
	Entity.prototype.hasTag = function (tag) {
		return this._tags.has(tag);
	};

	/**
	 * Clears a tag on an entity.
	 * @param {string} tag
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/Entity/Entity-tags-example.html Working example
	 * @example
	 * // Remove 'alive' tag if hit points drops to zero
	 * if (hero.getAttribute('hit-points') <= 0) {
	 *     hero.clearTag('alive');
	 * }
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.clearTag = function (tag) {
		this._tags.delete(tag);
		return this;
	};

	/**
	 * Sets an attribute and its value on the entity.
	 *
	 * @param {string} attribute
	 * @param value
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/Entity/Entity-attributes-example.html Working example
	 * @example
	 * // Create an entity with tags and attributes, and add it to world
	 * var hero = world.createEntity()
	 *                 .setTag('hero')
	 *                 .setAttribute('hit-points', 30)
	 *                 .setAttribute('attack-power', 3)
	 *                 .setTag('alive')
	 *                 .addToWorld();
	 *
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.setAttribute = function (attribute, value) {
		this._attributes.set(attribute, value);
		return this;
	};

	/**
	 * Checks whether an entity has an attribute or not.
	 * @param {string} attribute
	 * @returns {boolean}
	 */
	Entity.prototype.hasAttribute = function (attribute) {
		return this._attributes.has(attribute);
	};

	/**
	 * Gets the value of the specified attribute.
	 * @param {string} attribute
	 * @example
	 * // Check hit points on monster entity
	 * if (monster.getAttribute('hit-points') <= 0) {
	 *     console.log('The hero triumphs!');
	 * }
	 *
	 * @returns {*}
	 */
	Entity.prototype.getAttribute = function (attribute) {
		return this._attributes.get(attribute);
	};

	/**
	 * Clears an attribute of the entity.
	 * @param {string} attribute
	 * @returns {Entity} Returns self to allow chaining.
	 */
	Entity.prototype.clearAttribute = function (attribute) {
		this._attributes.delete(attribute);
		return this;
	};

	/**
	 * @returns {string} Name of entity.
	 */
	Entity.prototype.toString = function () {
		//! AT: should also return a list of its components or something more descriptive than just the name
		return this.name;
	};

	Entity.entityCount = 0;

	return Entity;
})(goo.Component,goo.StringUtils);
goo.Bus = (function () {
	'use strict';

	/**
	 * A generic message bus. Offers ways to receive and subscribe to messages on a hierarchy of channels.
	 */
	function Bus() {
		this.trie = { name: '', listeners: [], children: new Map() };
	}

	/**
	 * Sends messages to all listeners with provided callback function.
	 *
	 * @param {(string | Array<string>)} channels channel(s) addressed
	 * @param {Object} data
	 * @param {boolean} [storeEmit=false] Store the emit data for transmitting to future listeners
	 */
	Bus.prototype.emit = function (channels, data, storeEmit) {
		storeEmit = !!storeEmit;

		if (typeof channels === 'string') {
			this._emitToSingle(channels, data, storeEmit);
		} else {
			for (var i = 0; i < channels.length; i++) {
				this._emitToSingle(channels[i], data, storeEmit);
			}
		}

		return this;
	};

	/**
	 * Retrieves the last message sent on a channel. This will only work if message preservation is enabled when emitting.
	 * @param channelName
	 */
	Bus.prototype.getLastMessageOn = function (channelName) {
		var node = this._getNode(channelName);
		if (node) {
			return node.latestData;
		}
	};

	Bus.prototype._getNode = function (channelName, storeEmit) {
		var node = this.trie;
		var channelPath = channelName.split('.');

		for (var i = 0; i < channelPath.length; i++) {
			var channelSub = channelPath[i];

			if (node.children.has(channelSub)) {
				node = node.children.get(channelSub);
			} else {
				if (storeEmit) {
					var newNode = { listeners: [], children: new Map() };
					node.children.set(channelSub, newNode);
					node = newNode;
				} else {
					return;
				}
			}
		}

		return node;
	};

	function emitToListeners(node, data, channelName, bus) {
		for (var i = 0; i < node.listeners.length; i++) {
			var listener = node.listeners[i];
			if (listener) {
				listener(data, channelName, bus);
			} else {
				// some listeners may be set to null by the removeListener & co methods
				// the array is compacted here and not in the removeListener methods
				// because a listener itself can remove listeners
				node.listeners.splice(i, 1);
				i--;
			}
		}
	}

	function emitToAll(node, data, channelName, bus) {
		function traverse(node) {
			emitToListeners(node, data, channelName, bus);
			node.children.forEach(traverse);
		}

		traverse(node);
	}

	Bus.prototype._emitToSingle = function (channelName, data, storeEmit) {
		var node = this._getNode(channelName, storeEmit);
		if (node) {
			emitToAll(node, data, channelName, this);
			if (storeEmit) {
				node.latestData = data;
				node.latestChannel = channelName;
			}
		}
	};

	/**
	 * Register callback for a channel
	 * @param {string} channelName
	 * @param {Function} callback function (data)
	 * @param {boolean} [retrieveLatestEmit=false] Retrieve the last emit done before this listener was added (if emitted with storeEmit)
	 */
	Bus.prototype.addListener = function (channelName, callback, retrieveLatestEmit) {
		retrieveLatestEmit = !!retrieveLatestEmit;

		var node = this.trie;
		var channelPath = channelName.split('.');

		for (var i = 0; i < channelPath.length; i++) {
			var channelSub = channelPath[i];

			if (node.children.has(channelSub)) {
				node = node.children.get(channelSub);
			} else {
				var newNode = { listeners: [], children: new Map() };
				node.children.set(channelSub, newNode);
				node = newNode;
			}
		}

		if (node.listeners.indexOf(callback) === -1) {
			node.listeners.push(callback);
			if (retrieveLatestEmit && node.latestData) {
				callback(node.latestData, node.latestChannel, this);
			}
		}

		return this;
	};

	/**
	 * Sets element to null if it's present in the provided array
	 * @param {Array} array
	 * @param {*} element
	 */
	function nullifyElement(array, element) {
		var index = array.indexOf(element);
		if (index !== -1) {
			array[index] = null;
		}
	}

	/**
	 * Remove a listener from a channel but not from its children
	 * @param channelName
	 * @param callbackToRemove
	 */
	Bus.prototype.removeListener = function (channelName, callbackToRemove) {
		var node = this._getNode(channelName);
		if (node) { nullifyElement(node.listeners, callbackToRemove); }
		return this;
	};

	/**
	 * Removes all listeners on a specific channel
	 * @param channelName
	 */
	Bus.prototype.removeAllOnChannel = function (channelName) {
		var node = this._getNode(channelName);
		if (node) { node.listeners = []; }
		return this;
	};

	/**
	 * Removes a channel and its children
	 * @param channelName
	 */
	Bus.prototype.removeChannelAndChildren = function (channelName) {
		var channelParts = channelName.split('.');

		if (channelParts.length > 1) {
			var leafChannelName = channelParts.pop();
			var parentChannelName = channelParts.join('.');
			var parentNode = this._getNode(parentChannelName);

			parentNode.children.delete(leafChannelName);
		} else {
			this.trie.children.delete(channelName);
		}

		return this;
	};

	Bus.prototype._removeListener = function (node, callbackToRemove) {
		nullifyElement(node.listeners, callbackToRemove);

		node.children.forEach(function (child) {
			this._removeListener(child, callbackToRemove);
		}, this);
	};

	/**
	 * Removes a listener from all channels
	 * @param callbackToRemove
	 */
	Bus.prototype.removeListenerFromAllChannels = function (callbackToRemove) {
		this._removeListener(this.trie, callbackToRemove);
		return this;
	};

	Bus.prototype.clear = function () {
		this.trie = { name: '', listeners: [], children: new Map() };
	};

	return Bus;
})();
goo.ObjectUtils = (function () {
	'use strict';

	function ObjectUtils() {}

	/**
	 * Gets whether the specified array contains the specified value.
	 *
	 * @param {Array} array
	 *        The array which is to be checked.
	 * @param {*} value
	 *        The value which is to be found.
	 *
	 * @return {boolean}
	 *         True if the value exists in the array and false otherwise.
	 */
	ObjectUtils.contains = function (array, value) {
		return array.indexOf(value) !== -1;
	};

	/**
	 * Copies properties from an object onto another object if they're not already present
	 * @param {Object} destination Destination object to copy to
	 * @param {Object} source Source object to copy from
	 * @returns {Object} Returns the destination object
	 */
	ObjectUtils.defaults = function (destination, source) {
		var keys = Object.keys(source);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			if (typeof destination[key] === 'undefined' || destination[key] === null) {
				destination[key] = source[key];
			}
		}

		return destination;
	};

	/**
	 * Merges an options object and a defaults object into another object
	 * @param destination Object to attach properties to
	 * @param options A list of options; options must eb a subset of defaults
	 * @param defaults Defaults for options; if an option if not present this value is used instead
	 * @returns {Object} Returns the destination object
	 */
	ObjectUtils.copyOptions = function (destination, options, defaults) {
		var keys = Object.keys(defaults);

		if (options) {
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				var option = options[key];
				destination[key] = typeof option === 'undefined' || option === null ?
					defaults[key] :
					option;
			}
		} else {
			ObjectUtils.extend(destination, defaults);
		}

		return destination;
	};

	/**
	 * Copies properties from an object onto another object; overwrites existing properties
	 * @param {Object} destination Destination object to copy to
	 * @param {Object} source Source object to copy from
	 * @returns {Object} Returns the destination object
	 */
	ObjectUtils.extend = function (destination, source) {
		if (!source) { return; }

		var keys = Object.keys(source);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			destination[key] = source[key];
		}

		return destination;
	};

	// Create a (shallow-cloned) duplicate of an object.
	ObjectUtils.clone = function (obj) {
		if (!ObjectUtils.isObject(obj)) { return obj; }
		return Array.isArray(obj) ? obj.slice() : ObjectUtils.extend({}, obj);
	};

	// Save bytes in the minified (but not gzipped) version:
	var nativeForEach = Array.prototype.forEach;

	// The cornerstone, an `each` implementation, aka `forEach`.
	// Handles objects with the built-in `forEach`, arrays, and raw objects.
	// Delegates to **ECMAScript 5**'s native `forEach` if available.
	ObjectUtils.each = ObjectUtils.forEach = function (obj, iterator, context, sortProp) {
		if (typeof obj === 'undefined' || obj === null) { return; }
		if (nativeForEach && obj.forEach === nativeForEach) {
			obj.forEach(iterator, context);
		} else if (obj.length === +obj.length) {
			for (var i = 0, l = obj.length; i < l; i++) {
				iterator.call(context, obj[i], i, obj);
			}
		} else {
			var keys = Object.keys(obj);
			if (sortProp !== undefined) {
				keys.sort(function (a, b) {
					return obj[a][sortProp] - obj[b][sortProp];
				});
			}
			for (var i = 0, length = keys.length; i < length; i++) {
				iterator.call(context, obj[keys[i]], keys[i], obj);
			}
		}
	};

	/**
	 * Creates an array of values by running each element in collection through
	 * iteratee. The iteratee is bound to context and invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * @param {Array|Object|string} collection
	 * @param {Function} iteratee
	 * @param {*} context
	 * @param {string} sortProp
	 *
	 * @return {Array}
	 */
	ObjectUtils.map = function (collection, iteratee, context, sortProp) {
		var result = [];

		ObjectUtils.forEach(collection, function (value, key) {
			result.push(iteratee.call(context, value, key, collection));
		}, context, sortProp);

		return result;
	};

	/**
	 * Performs a deep clone. Can handle primitive types, arrays, generic
	 * objects, typed arrays and html nodes. Functions are shared. Does not
	 * handle circular references - also does not preserve original
	 * constructors/prototypes.
	 *
	 * @param {*} object Object to clone
	 * @returns {*}
	 */
	ObjectUtils.deepClone = function (object) {
		// handle primitive types, functions, null and undefined
		if (object === null || typeof object !== 'object') {
			return object;
		}

		// handle typed arrays
		if (Object.prototype.toString.call(object.buffer) === '[object ArrayBuffer]') {
			return new object.constructor(object);
		}

		// handle arrays (even sparse ones)
		if (object instanceof Array) {
			return object.map(ObjectUtils.deepClone);
		}

		// handle html nodes
		if (object.nodeType && typeof object.cloneNode === 'function') {
			return object.cloneNode(true);
		}

		// handle generic objects
		// prototypes and constructors will not match in the clone
		var copy = {};
		var keys = Object.keys(object);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			copy[key] = ObjectUtils.deepClone(object[key]);
		}
		return copy;
	};

	ObjectUtils.shallowSelectiveClone = function (source, keys) {
		var clone = {};

		keys.forEach(function (key) {
			clone[key] = source[key];
		});

		return clone;
	};

	// probably not the best way to copy maps and sets
	ObjectUtils.cloneMap = function (source) {
		var clone = new Map();
		source.forEach(function (value, key) {
			clone.set(key, value);
		});
		return clone;
	};

	ObjectUtils.cloneSet = function (source) {
		var clone = new Set();
		source.forEach(function (value) {
			clone.add(value);
		});
		return clone;
	};

	ObjectUtils.warnOnce = function (message, fun) {
		var warned = false;
		return function () {
			if (!warned) {
				console.warn(message);
				warned = true;
			}

			return fun.apply(this, arguments);
		};
	};

	/**
	 * Creates a function which returns the provided value.
	 *
	 * @param {*} value
	 *        Value which is to be returned by the created function.
	 *
	 * @return {Function}
	 */
	ObjectUtils.constant = function (value) {
		return function () { return value; };
	};

	/**
	 * Creates a function which returns the specified property of any object
	 * passed to it.
	 *
	 * @param {string} propName
	 *        Name of the property whose value is to be returned by the created
	 *        function
	 *
	 * @return {Function}
	 */
	ObjectUtils.property = function (propName) {
		return function (obj) { return obj[propName]; };
	};

	/**
	 * Gets whether the specified value is an object.
	 *
	 * @param {*} value
	 *        Value which is to be tested.
	 *
	 * @return {boolean}
	 *         True if the value is an object and false otherwise.
	 */
	ObjectUtils.isObject = function (value) {
		return value === Object(value);
	};

	/**
	 * Gets whether the specified value is a string.
	 *
	 * @param {*} value
	 *        Value which is to be tested.
	 *
	 * @return {boolean}
	 *         True if the value is a string and false otherwise.
	 */
	ObjectUtils.isString = function (value) {
		return typeof value === 'string';
	};

	/**
	 * Gets whether the specified value is an boolean value.
	 *
	 * @param {*} value
	 *        Value which is to be tested.
	 *
	 * @return {boolean}
	 *         True if the value is a boolean and false otherwise.
	 */
	ObjectUtils.isBoolean = function (value) {
		return value === true || value === false;
	};

	/**
	 * Gets whether the specified value is a number.
	 *
	 * @param {*} value
	 *        Value which is to be tested.
	 *
	 * @return {boolean}
	 *         True if the value is a number and false otherwise.
	 */
	ObjectUtils.isNumber = function (value) {
		return typeof value === 'number';
	};

	/**
	 * Gets whether the specified value is an integer number.
	 *
	 * @param {*} value
	 *        Value which is to be tested.
	 *
	 * @return {boolean}
	 *         True if the value is an integer number and false otherwise.
	 */
	ObjectUtils.isInteger = function (value) {
		return ObjectUtils.isNumber(value) && value % 1 === 0;
	};

	/**
	 * Gets the extension of the specified string. The extension is anything
	 * after the last '.'
	 *
	 * @param {*} value
	 *        Value whose extension is to be returned.
	 *
	 * @return {string}
	 */
	ObjectUtils.getExtension = function (value) {
		if (ObjectUtils.isString(value)) {
			var dotIndex = value.lastIndexOf('.');
			if (dotIndex >= -1) {
				return value.substr(dotIndex + 1).toLowerCase();
			}
		}

		return '';
	};

	return ObjectUtils;
})();
goo.ScriptUtils = (function (
	_
) {
	'use strict';

	function ScriptUtils() {}


	ScriptUtils.DEFAULTS_BY_TYPE = {
		'float': 0,
		'int': 0,
		'string': '',
		'vec2': [0, 0],
		'vec3': [0, 0, 0],
		'vec4': [0, 0, 0, 0],
		'boolean': false,
		'animation': null,
		'camera': null,
		'entity': null,
		'image': null,
		'sound': null,
		'texture': null
	};

	ScriptUtils.REF_TYPES = [
		'animation',
		'camera',
		'entity',
		'image',
		'sound',
		'texture'
	];

	ScriptUtils.isRefType = function (type) {
		return _.contains(ScriptUtils.REF_TYPES, type);
	};

	ScriptUtils.TYPE_VALIDATORS = (function () {
		var isVec = function (length) {
			return function (data) {
				return Array.isArray(data) && data.length === length;
			};
		};

		var isRef = function (type) {
			function isDirectRef(data) {
				return _.isString(data) && _.getExtension(data) === type;
			}

			// Checks for references passed like:
			// {
			//     entityRef: string
			//     enabled: boolean
			// }
			function isWrappedRef(data) {
				return data && isDirectRef(data[type + 'Ref']);
			}

			return function (data) {
				return isDirectRef(data) || isWrappedRef(data);
			};
		};

		return {
			'float': _.isNumber,
			'string': _.isString,
			'boolean': _.isBoolean,
			'int': _.isInteger,
			'vec2': isVec(2),
			'vec3': isVec(3),
			'vec4': isVec(4),
			'animation': isRef('animation'),
			'camera': isRef('camera'),
			'entity': isRef('entity'),
			'image': isRef('image'),
			'sound': isRef('sound'),
			'texture': isRef('texture')
		};
	})();

	/**
	 * Fill a passed parameters object with defaults from spec
	 * @hidden
	 * @param parameters {Object} The type of object passed as parameters to a script
	 * @param specs {Array<{key, name, default, description}>}
	 */
	ScriptUtils.fillDefaultValues = function (parameters, specs) {
		if (!(specs instanceof Array)) { return; }

		var keys = [];
		specs.forEach(function (spec) {
			if (!spec || typeof spec.key !== 'string') {
				return;
			}

			if (spec.default === null || spec.default === undefined) {
				spec.default = _.deepClone(ScriptUtils.DEFAULTS_BY_TYPE[spec.type]);
			}

			keys.push(spec.key);
			if (typeof parameters[spec.key] === 'undefined') {
				parameters[spec.key] = _.clone(spec.default);
			}
		});

		//! AT: when does this ever happen?
		for (var key in parameters) {
			if (keys.indexOf(key) === -1 && key !== 'enabled') {
				delete parameters[key];
			}
		}
	};

	/**
	 * Fills specs' names with their prettyprinted keys (x -> x, maxX -> Max X, myBluePanda -> My Blue Panda)
	 * @hidden
	 * @param specs {Array<{key, name, default, description}>}
	 */
	ScriptUtils.fillDefaultNames = function (specs) {
		if (!(specs instanceof Array)) { return; }

		function getNameFromKey(key) {
			if (typeof key !== 'string' || key.length === 0) { return ''; }
			var capitalisedKey = key[0].toUpperCase() + key.slice(1);
			return capitalisedKey.replace(/(.)([A-Z])/g, '$1 $2');
		}

		specs.forEach(function (spec) {
			if (!spec) { return; }
			if (typeof spec.name === 'undefined') {
				spec.name = getNameFromKey(spec.key);
			}
		});
	};

	// TODO Copied from FSMUtils. Should be put in another util
	// And keys should probably be defined ScriptUtil.keys.BackSpace = 'BackSpace';
	ScriptUtils.getKey = function (str) {
		if (ScriptUtils._keys[str]) {
			return ScriptUtils._keys[str];
		} else {
			return str.charCodeAt(0);
		}
	};

	ScriptUtils._keys = {
		'Backspace': 8,
		'Tab': 9,
		'Enter': 13,
		'Shift': 16,
		'Ctrl': 17,
		'Alt': 18,
		'Meta': 91,
		'Pause': 19,
		'Capslock': 20,
		'Esc': 27,
		'Space': 32,
		'Pageup': 33,
		'Pagedown': 34,
		'End': 35,
		'Home': 36,
		'Leftarrow': 37,
		'Uparrow': 38,
		'Rightarrow': 39,
		'Downarrow': 40,
		'Insert': 45,
		'Delete': 46,
		'0': 48,
		'1': 49,
		'2': 50,
		'3': 51,
		'4': 52,
		'5': 53,
		'6': 54,
		'7': 55,
		'8': 56,
		'9': 57,
		'a': 65,
		'b': 66,
		'c': 67,
		'd': 68,
		'e': 69,
		'f': 70,
		'g': 71,
		'h': 72,
		'i': 73,
		'j': 74,
		'k': 75,
		'l': 76,
		'm': 77,
		'n': 78,
		'o': 79,
		'p': 80,
		'q': 81,
		'r': 82,
		's': 83,
		't': 84,
		'u': 85,
		'v': 86,
		'w': 87,
		'x': 88,
		'y': 89,
		'z': 90,
		'A': 65,
		'B': 66,
		'C': 67,
		'D': 68,
		'E': 69,
		'F': 70,
		'G': 71,
		'H': 72,
		'I': 73,
		'J': 74,
		'K': 75,
		'L': 76,
		'M': 77,
		'N': 78,
		'O': 79,
		'P': 80,
		'Q': 81,
		'R': 82,
		'S': 83,
		'T': 84,
		'U': 85,
		'V': 86,
		'W': 87,
		'X': 88,
		'Y': 89,
		'Z': 90,
		'0numpad': 96,
		'1numpad': 97,
		'2numpad': 98,
		'3numpad': 99,
		'4numpad': 100,
		'5numpad': 101,
		'6numpad': 102,
		'7numpad': 103,
		'8numpad': 104,
		'9numpad': 105,
		'Multiply': 106,
		'Plus': 107,
		'Minus': 109,
		'Dot': 110,
		'Slash1': 111,
		'F1': 112,
		'F2': 113,
		'F3': 114,
		'F4': 115,
		'F5': 116,
		'F6': 117,
		'F7': 118,
		'F8': 119,
		'F9': 120,
		'F10': 121,
		'F11': 122,
		'F12': 123,
		'Equals': 187,
		'Comma': 188,
		'Slash': 191,
		'Backslash': 220
	};

	ScriptUtils._keyInverse = (function (assoc) {
		var inverseAssoc = {};

		var keys = Object.keys(assoc);
		for (var i = 0; i < keys.length; i++) {
			inverseAssoc[assoc[keys[i]]] = keys[i];
		}
		return inverseAssoc;
	}(ScriptUtils._keys));

	ScriptUtils.keyForCode = function (code) {
		return ScriptUtils._keyInverse[code];
	};

	return ScriptUtils;
})(goo.ObjectUtils);
goo.Scripts = (function (
	ScriptUtils,
	ObjectUtils
) {
	'use strict';

	// the collection of scripts
	var _scripts = {};

	// the static class which just holds the following methods
	var Scripts = {};

	Scripts.register = function (factoryFunction) {
		var key = factoryFunction.externals.key || factoryFunction.externals.name;
		if (_scripts[key]) {
			console.warn('Script already registered for key ' + key);
			return;
		}
		//! AT: this will modify the external object but that's ok
		ScriptUtils.fillDefaultNames(factoryFunction.externals.parameters);
		_scripts[key] = factoryFunction;
	};

	Scripts.addClass = ObjectUtils.warnOnce(
		'Scripts.addClass is deprecated; please consider using the global goo object instead',
		function (name, klass) {
			// deprecated as of v0.15.3 and scheduled for removal in version 0.17.0
		}
	);

	Scripts.getClasses = ObjectUtils.warnOnce(
		'Scripts.getClasses is deprecated; please consider using the global goo object instead',
		function () {
			return window.goo;
		}
	);

	Scripts.getScript = function (key) {
		return _scripts[key];
	};

	Scripts.create = function (key, options) {
		var factoryFunction;
		if (typeof key === 'string') {
			factoryFunction = _scripts[key];
			if (!factoryFunction) {
				throw new Error('Script "' + key + '" is not registered');
			}
		} else if (typeof key === 'function') {
			factoryFunction = key;
		}

		var script = factoryFunction();
		script.parameters = {};
		script.environment = null;
		script.externals = factoryFunction.externals;

		if (factoryFunction.externals) {
			ScriptUtils.fillDefaultNames(script.externals.parameters);
			ScriptUtils.fillDefaultValues(script.parameters, factoryFunction.externals.parameters);
		}

		if (options) {
			ObjectUtils.extend(script.parameters, options);
		}

		return script;
	};

	Scripts.allScripts = function () {
		// REVIEW: Why not return _scripts? Document this function.
		var scripts = {};
		var keys = Object.keys(_scripts);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			scripts[key] = _scripts[key];
		}
		return scripts;
	};

	return Scripts;
})(goo.ScriptUtils,goo.ObjectUtils);
goo.MathUtils = (function () {
	'use strict';

	/**
	 * A collection of useful math-related functions, constants and helpers.
	 * Only used to define the class. Should never be instantiated.
	 */
	function MathUtils() {}

	/** @type {number}
	 * @example
	 * // converts 75 degrees to radians
	 * var rot = 75 * MathUtils.DEG_TO_RAD;
	 */
	MathUtils.DEG_TO_RAD = Math.PI / 180.0;

	/** @type {number}
	 * @example
	 * // converts Math.PI to 180 degrees
	 * var rot = Math.PI  MathUtils.RAD_TO_DEG;
	 */
	MathUtils.RAD_TO_DEG = 180.0 / Math.PI;

	/** @type {number}
	 * @example
	 * // uses HALF_PI and converts it to degress
	 * var rot = MathUtils.HALF_PI * MathUtils.RAD_TO_DEG; // rot == 90
	 */
	MathUtils.HALF_PI = 0.5 * Math.PI;

	/** @type {number}
	 * @example
	 * // uses TWO_PI and converts it to degrees
	 * var rot = MathUtils.TWO_PI * RAD_TO_DEG; // rot == 360
	 */
	MathUtils.TWO_PI = 2.0 * Math.PI;

	/** @type {number}
	 * @example
	 * // uses EPSILON to approximate floating point equality
	 * if (Math.abs(a - b) > MathUtils.EPSILON) {
	 * 		// not equal
	 * }
	 */
	MathUtils.EPSILON = 0.00001; //! AT: unfortunately Matrix.invert is too unstable to use a smaller epsilon

	//! AT: why do we have both these functions and the constant above?
	// why are the constants named x_TO_y and and the functions y_FROM_x ?
	/**
	 * Converts an angle from degrees to radians.
	 * @param {Float} degrees Angle in degrees.
	 * @returns {Float} Angle in radians.
	 * @example
	 * // converts 70 degrees to a radian
	 * var a = MathUtils.radFromDeg(70);
	 */
	MathUtils.radFromDeg = function (degrees) {
		return degrees * MathUtils.DEG_TO_RAD;
	};

	/**
	 * Converts an angle from radians to degrees.
	 * @param {Float} radians Angle in radians.
	 * @returns {Float} Angle in degrees.
	 * @example
	 * // converts Math.PI to 180 degrees
	 * var a = MathUtils.degFromRad(Math.PI);
	 */
	MathUtils.degFromRad = function (radians) {
		return radians * MathUtils.RAD_TO_DEG;
	};

	/**
	 * Linearly interpolates between two values. Extrapolates if factor is smaller than zero or greater than one.
	 * @param {number} factor Factor of interpolation.
	 * @param {number} start Start value.
	 * @param {number} end End value.
	 * @returns {number} Interpolated value.
	 * @example
	 * // earlier in code (outside of the update loop)
	 * var x = 0;
	 * // inside the update loop
	 * x = MathUtils.lerp(tpf, x, 5);
	 */
	MathUtils.lerp = function (factor, start, end) {
		if (start === end) {
			return start;
		} else {
			return start + (end - start) * factor;
		}
	};

	/**
	 * Clamps a value to a given interval. The interval is defined by min and max where min should be smaller than max. If min is greater
	 * than max, the two parameters are reversed.
	 * @param {number} value Input value.
	 * @param {number} min Lower bound of interval (inclusive).
	 * @param {number} max Upper bound of interval (inclusive).
	 * @returns {number} Clamped value.
	 * @example
	 * var a = -1;
	 * a = Math.clamp(a, 0, 9); // a == 0
	 */
	MathUtils.clamp = function (value, min, max) {
		if (min < max) {
			return value < min ? min : value > max ? max : value;
		} else {
			return value < max ? max : value > min ? min : value;
		}
	};

	/**
	 * Clamps an angle to a given interval. The interval is defined by min and max. If min is larger than max, the clamp will wrap around.
	 * @param {number} value Input value.
	 * @param {number} min Lower bound of interval (inclusive).
	 * @param {number} max Upper bound of interval (inclusive).
	 * @returns {number} Clamped value.
	 * @example
	 * var a = -1;
	 * a = Math.radialClamp(a, 0, 9); // a == 0
	 */
	MathUtils.radialClamp = function (value, min, max) {
		// Rotating coordinates to be mirrored
		var zero = (min + max) / 2 + ((max > min) ? Math.PI : 0);
		var _value = MathUtils.moduloPositive(value - zero, MathUtils.TWO_PI);
		var _min = MathUtils.moduloPositive(min - zero, MathUtils.TWO_PI);
		var _max = MathUtils.moduloPositive(max - zero, MathUtils.TWO_PI);

		// Putting min, max and value on the same circle
		if (value < 0 && min > 0) { min -= MathUtils.TWO_PI; }
		else if (value > 0 && min < 0) { min += MathUtils.TWO_PI; }
		if (value > MathUtils.TWO_PI && max < MathUtils.TWO_PI) { max += MathUtils.TWO_PI; }

		return _value < _min ? min : _value > _max ? max : value;
	};


	/**
	 * Calculates the positive modulo
	 * @param {number} value
	 * @param {number} size
	 * @returns {number} Wrapped value
	 */
	MathUtils.moduloPositive = function (value, size) {
		var wrappedValue = value % size;
		wrappedValue += wrappedValue < 0 ? size : 0;
		return wrappedValue;
	};

	/**
	 * Computes a value on the c1-continuous cubic s-curve "y = -2x^3 + 3x^2".
	 * @param {number} x Input value in the range between zero and one.
	 * @returns {number} Value on curve.
	 */
	MathUtils.scurve3 = function (x) {
		return (-2.0 * x + 3.0) * x * x;
	};

	/**
	 * Computes a value on the c2-continuous quintic s-curve "y = 6x^5 - 15x^4 + 10x^3".
	 * @param {number} x Input value in the range between zero and one.
	 * @returns {number} Value on curve.
	 */
	MathUtils.scurve5 = function (x) {
		return ((6.0 * x - 15.0) * x + 10.0) * x * x * x;
	};

	/**
	 * Converts Spherical coordinates in radians to a Vector3 Cartesian point (using positive Y as up) and stores the results in the store var.
	 * @param {number} radius (distance)
	 * @param {number} azimuth (heading)
	 * @param {number} polar (elevation)
	 * @param {Vector3} store
	 * @example
	 * var distance = 5;
	 * var heading = 180;
	 * var elevation = 30;
	 * var position = new Vector3();
	 * MathUtils.sphericalToCartesian(distance, heading, elevation, position);
	 */
	MathUtils.sphericalToCartesian = function (radius, azimuth, polar, store) {
		var a = radius * Math.cos(polar);

		store.x = a * Math.cos(azimuth);
		store.y = radius * Math.sin(polar);
		store.z = a * Math.sin(azimuth);
	};

	/**
	 * Converts a point from Cartesian coordinates to Spherical radian coordinates (using positive Y as up) and stores the results in the store var.
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {Vector3} store
	 * @example
	 * var sphericalCoord = new Vector3();
	 * var pos = entity.transformComponent.transform.translation.
	 * MathUtils.cartesianToSpherical(pos.x, pos.y, pos.z, sphericalCoord);
	 */
	MathUtils.cartesianToSpherical = function (x, y, z, store) {
		var a = Math.sqrt(x * x + z * z);
		store.x = Math.sqrt(x * x + y * y + z * z); // radius
		store.y = Math.atan2(z, x); // azimuth
		store.z = Math.atan2(y, a); // polar
	};

	/**
	 * Computes the normal of a given triangle
	 * @param {number} P.x
	 * @param {number} P.y
	 * @param {number} P.z
	 * @param {number} Q.x
	 * @param {number} Q.y
	 * @param {number} Q.z
	 * @param {number} R.x
	 * @param {number} R.y
	 * @param {number} R.z
	 * @returns {Array<number>} The triangle's normal
	 */
	MathUtils.getTriangleNormal = function (p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z) {
		var ux = p2x - p1x;
		var uy = p2y - p1y;
		var uz = p2z - p1z;

		var vx = p3x - p1x;
		var vy = p3y - p1y;
		var vz = p3z - p1z;

		var nx = uy * vz - uz * vy;
		var ny = uz * vx - ux * vz;
		var nz = ux * vy - uy * vx;

		return [nx, ny, nz];
	};

	/**
	 * Checks if a value is power of two
	 * @param {number} value Number to check for power of two
	 * @returns {boolean} true if value is power of two
	 */
	MathUtils.isPowerOfTwo = function (value) {
		return (value & (value - 1)) === 0;
	};

	/**
	 * Gets the nearest higher power of two for a value
	 * @param {number} value Number to get the nearest power of two from
	 * @returns {number} Nearest power of two
	 */
	MathUtils.nearestPowerOfTwo = function (value) {
		value--;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		value++;
		return value;
	};

	/**
	 * Gets the nearest higher power of two for a value
	 * @deprecated Deprecated as of v0.14.x and scheduled for removal in v0.16.0;
	 * Consider using MathUtils.nearestPowerOfTwo instead
	 * @param {number} value Number to get the nearest power of two from
	 * @returns {number} Nearest power of two
	 */
	MathUtils.nearestHigherPowerOfTwo = MathUtils.nearestPowerOfTwo;

	/**
	 * Returns true if the 2 values supplied are approximately the same
	 * @param v1
	 * @param v2
	 * @param tolerance
	 * @returns {boolean}
	 */
	MathUtils.closeTo = function (v1, v2, tolerance) {
		tolerance = typeof tolerance !== 'undefined' ? tolerance : 0.001;
		return Math.abs(v1 - v2) <= tolerance;
	};

	/**
	 * Returns the sign of the supplied parameter
	 * @param value
	 * @returns {number}
	 */
	MathUtils.sign = function (value) {
		return value < 0 ? -1 : value > 0 ? 1 : 0;
	};

	/**
	 * Computes the area of a 2D triangle
	 * @param {Vector2} t1 First point of the triangle
	 * @param {Vector2} t2 Second point of the triangle
	 * @param {Vector2} t3 Third point of the triangle
	 * @returns {number}
	 */
	MathUtils.triangleArea = function (t1, t2, t3) {
		return Math.abs(t1.x * t2.y + t2.x * t3.y + t3.x * t1.y
			- t2.y * t3.x - t3.y * t1.x - t1.y * t2.x) / 2;
	};

	/**
	 * Computes the height of a point located inside a triangle. Height is assumed to bound to the Z axis.
	 * @param {Vector3} t1 First point of the triangle
	 * @param {Vector3} t2 Second point of the triangle
	 * @param {Vector3} t3 Third point of the triangle
	 * @param {Vector3} p The point for which to compute the height
	 * @returns {Vector3}
	 */
	MathUtils.barycentricInterpolation = function (t1, t2, t3, p) {
		var t1Area = MathUtils.triangleArea(t2, t3, p);
		var t2Area = MathUtils.triangleArea(t1, t3, p);
		var t3Area = MathUtils.triangleArea(t1, t2, p);

		// assuming the point is inside the triangle
		var totalArea = t1Area + t2Area + t3Area;
		if (!totalArea) {
			if (p[0] === t1[0] && p[2] === t1[2]) {
				return t1;
			} else if (p[0] === t2[0] && p[2] === t2[2]) {
				return t2;
			} else if (p[0] === t3[0] && p[2] === t3[2]) {
				return t3;
			}
		}

		p.z = (t1Area * t1.z + t2Area * t2.z + t3Area * t3.z) / totalArea;
		return p;
	};

	/**
	 * Performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1.
	 * This is useful in cases where a threshold function with a smooth transition is desired.
	 * @param {number} edge0 Specifies the value of the lower edge of the Hermite function.
	 * @param {number} edge1 Specifies the value of the upper edge of the Hermite function.
	 * @param {number} x Specifies the source value for interpolation.
	 * @returns {number}
	 */
	MathUtils.smoothstep = function (edge0, edge1, x) {
		x = MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
		return x * x * (3 - 2 * x);
	};

	/** @type {number}
	* @example
	* // sets random seed to use with MathUtils.fastRandom()
	* MathUtils.randomSeed = 1337;
	*/
	MathUtils.randomSeed = 1337;

	/**
	 * Rough random generation with seeding. Set random seed through MathUtils.randomSeed = {new seed value}
	 * @returns {number} Random number between 0 and 1.
	 */
	MathUtils.fastRandom = function () {
		MathUtils.randomSeed = (MathUtils.randomSeed * 9301 + 49297) % 233280;
		return MathUtils.randomSeed / 233280;
	};

	/**
	 * Converts a float to half-float representation.
	 * @param {number} value The float value to convert
	 * @returns {number} the half-float representation
	 */
	MathUtils.floatToHalfFloat = (function () {
	    var floatView = new Float32Array(1);
	    var int32View = new Int32Array(floatView.buffer);

	    return function (fval) {
	        floatView[0] = fval;
	        var fbits = int32View[0];
	        var sign = (fbits >> 16) & 0x8000;
	        var val = (fbits & 0x7fffffff) + 0x1000;

	        if (val >= 0x47800000) {
	            if ((fbits & 0x7fffffff) >= 0x47800000) {
	                if (val < 0x7f800000) {
	                    return sign | 0x7c00;
	                }
	                return sign | 0x7c00 | (fbits & 0x007fffff) >> 13;
	            }
	            return sign | 0x7bff;
	        }
	        if (val >= 0x38800000) {
	            return sign | val - 0x38000000 >> 13;
	        }
	        if (val < 0x33000000) {
	            return sign;
	        }
	        val = (fbits & 0x7fffffff) >> 23;
	        return sign | ((fbits & 0x7fffff | 0x800000) + (0x800000 >>> val - 102) >> 126 - val);
	    };
	})();

	/**
	 * Defines a property on an object that throws an exception when NaN is being assigned to it.
	 * Useful for debugging.
	 * @hidden
	 * @param object
	 * @param property
	 */
	MathUtils.warnNaN = function (object, property) {
		var value = object[property];

		Object.defineProperty(object, property, {
			get: function () { return value; },
			set: function (_value) {
				if (isNaN(_value)) { throw new Error('Tried to assign NaN to ' + property); }
				value = _value;
			}
		});
	};

	return MathUtils;
})();
goo.Vector = (function (
	ObjectUtils,
	MathUtils
	) {
	'use strict';

	/**
	 * Abstract vector class
	 */
	function Vector(size) {

		/**
		 * @hidden
		 * @deprecated
		 */
		this._size = size;
	}

	var COMPONENT_NAMES = ['x', 'y', 'z', 'w'];
	// #ifdef DEBUG
	var COMPONENT_NAMES = ['_x', '_y', '_z', '_w'];
	// #endif

	/**
	 * Binds aliases to the different vector components.
	 * @hidden
	 * @param {Object} prototype The prototype to bind to.
	 * @param {Array<Array<string>>} aliases Array of component aliases for each component index.
	 */
	Vector.setupAliases = function (prototype, aliases) {
		aliases.forEach(function (aliasesPerComponent, index) {
			var componentName = COMPONENT_NAMES[index];

			aliasesPerComponent.forEach(function (alias) {
				Object.defineProperty(prototype, alias, {
					get: function () {
						return this[componentName];
					},
					set: function (value) {
						this[componentName] = value;

						// #ifdef DEBUG
						if (isNaN(this[componentName])) {
							throw new Error('Tried setting NaN to vector component ' + alias);
						}
						// #endif
					}
				});
			});
		});
	};

	// #ifdef DEBUG
	Vector.setupIndices = function (prototype, count) {
		var raise = function () {
			throw new Error('Vector component access through indices is not supported anymore');
		};

		for (var i = 0; i < count; i++) {
			Object.defineProperty(prototype, i, {
				get: raise,
				set: raise
			});
		}
	};

	/**
	 * Replaces the supplied method of object and wraps it in a integrity check
	 * @hidden
	 * @param {Object} object The object to attach the post-check to
	 * @param {string} methodName The name of the original method the check is attached to
	 */
	Vector.addReturnCheck = function (object, methodName) {
		var originalMethod = object[methodName];
		object[methodName] = function () {
			var ret = originalMethod.apply(this, arguments);
			if (isNaN(ret)) {
				throw new Error('Vector method ' + methodName + ' returned NaN');
			}

			return ret;
		};
	};

	/**
	 * Adds more validators at once
	 * @hidden
	 * @param {Object} object
	 * @param {Array<string>} methodNames
	 */
	Vector.addReturnChecks = function (object, methodNames) {
		methodNames.forEach(Vector.addReturnCheck.bind(null, object));
	};
	// #endif

	// SHIM START
	Object.defineProperty(Vector.prototype, 'data', {
		get: ObjectUtils.warnOnce('The .data property of Vector was removed, please use the .x, .y, .z, .w properties instead.', function () {
			var data = [];
			var that = this;
			Object.defineProperties(data, {
				'0': {
					get: function () {
						return that.x;
					},
					set: function (value) {
						that.x = value;
					}
				},
				'1': {
					get: function () {
						return that.y;
					},
					set: function (value) {
						that.y = value;
					}
				},
				'2': {
					get: function () {
						return that.z;
					},
					set: function (value) {
						that.z = value;
					}
				},
				'3': {
					get: function () {
						return that.w;
					},
					set: function (value) {
						that.w = value;
					}
				}
			});
			return data;
		})
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.add = ObjectUtils.warnOnce('Vector.add is deprecated.', function (lhs, rhs, target) {
		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;
		var size = lhs._size;

		if (!target) {
			target = new Vector(size);
		}

		for (var i = 0; i < size; i++) {
			target.data[i] = ldata[i] + rdata[i];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.add = ObjectUtils.warnOnce('Vector.prototype.add is deprecated.', function (rhs) {
		return Vector.add(this, rhs, this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.sub = ObjectUtils.warnOnce('Vector.sub is deprecated.', function (lhs, rhs, target) {
		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;
		var size = lhs._size;

		if (!target) {
			target = new Vector(size);
		}

		for (var i = 0; i < size; i++) {
			target.data[i] = ldata[i] - rdata[i];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.sub = ObjectUtils.warnOnce('Vector.prototype.sub is deprecated.', function (rhs) {
		return Vector.sub(this, rhs, this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.mul = ObjectUtils.warnOnce('Vector.mul is deprecated.', function (lhs, rhs, target) {
		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;
		var size = lhs._size;

		if (!target) {
			target = new Vector(size);
		}

		for (var i = 0; i < size; i++) {
			target.data[i] = ldata[i] * rdata[i];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.mul = ObjectUtils.warnOnce('Vector.prototype.mul is deprecated.', function (rhs) {
		return Vector.mul(this, rhs, this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.div = ObjectUtils.warnOnce('Vector.div is deprecated.', function (lhs, rhs, target) {
		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;
		var size = lhs._size;

		if (!target) {
			target = new Vector(size);
		}

		for (var i = 0; i < size; i++) {
			target.data[i] = ldata[i] / rdata[i];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.div = ObjectUtils.warnOnce('Vector.prototype.div is deprecated.', function (rhs) {
		return Vector.div(this, rhs, this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.copy = ObjectUtils.warnOnce('Vector.copy is deprecated.', function (source, target) {
		var size = source._size;

		if (!target) {
			target = new Vector(size);
		}

		for(var i=0; i<size; i++){
			target.data[i] = source.data[i];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.copy = ObjectUtils.warnOnce('Vector.prototype.copy  is deprecated.', function (source) {
		var size = source._size;
		for(var i=0; i<size; i++){
			this.data[i] = source.data[i];
		}
		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.dot = ObjectUtils.warnOnce('Vector.dot is deprecated.', function (lhs, rhs) {
		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;
		var size = lhs._size;

		var sum = 0;

		for (var i = 0; i < size; i++) {
			sum += ldata[i] * rdata[i];
		}

		return sum;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.dot = ObjectUtils.warnOnce('Vector.prototype.dot is deprecated.', function (rhs) {
		return Vector.dot(this, rhs);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.apply = ObjectUtils.warnOnce('Vector.apply is deprecated.', function (lhs, rhs, target) {
		var rows = lhs.rows;
		var cols = lhs.cols;
		var size = rhs._size;

		if (!target) {
			target = new Vector(rows);
		}

		if (target === rhs) {
			return Vector.copy(Vector.apply(lhs, rhs), target);
		}

		for (var c = 0; c < cols; c++) {
			var o = c * rows;

			for (var r = 0; r < rows; r++) {
				var sum = 0.0;

				for (var i = 0; i < size; i++) {
					sum += lhs.data[i * lhs.rows + r] * rhs.data[i];
				}

				target.data[o + r] = sum;
			}
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.apply = ObjectUtils.warnOnce('Vector.prototype.apply is deprecated.', function (lhs) {
		return Vector.apply(lhs, this, this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.equals = ObjectUtils.warnOnce('Vector.equals is deprecated.', function (lhs, rhs) {
		var lhsLength = lhs._size;
		if (lhsLength !== rhs._size) {
			return false;
		}

		for (var i = 0; i < lhsLength; i++) {
			// why the backwards check? because otherwise if NaN is present in either lhs or rhs
			// then Math.abs(NaN) is NaN which is neither bigger or smaller than EPSILON
			// which never satisfies the condition
			// NaN is not close to to NaN and we want to preserve that for vectors as well
			if (!(Math.abs(lhs.data[i] - rhs.data[i]) <= MathUtils.EPSILON)) {
				return false;
			}
		}

		return true;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.equals = ObjectUtils.warnOnce('Vector.prototype.equals is deprecated.', function (rhs) {
		return Vector.equals(this, rhs);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.distanceSquared = ObjectUtils.warnOnce('Vector.distanceSquared is deprecated.', function (lhs, rhs) {
		return Vector.sub(lhs, rhs).lengthSquared();
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.distanceSquared = ObjectUtils.warnOnce('Vector.prototype.distanceSquared is deprecated.', function (rhs) {
		return Vector.sub(this, rhs).lengthSquared();
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.distance = ObjectUtils.warnOnce('Vector.distance is deprecated.', function (lhs, rhs) {
		return Vector.sub(lhs, rhs).length();
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.distance = ObjectUtils.warnOnce('Vector.prototype.distance is deprecated.', function (rhs) {
		return Vector.sub(this, rhs).length();
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.lengthSquared = ObjectUtils.warnOnce('Vector.prototype.lengthSquared is deprecated.', function () {
		return Vector.dot(this, this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.length = ObjectUtils.warnOnce('Vector.prototype.length is deprecated.', function () {
		return Math.sqrt(Vector.dot(this, this));
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.scale = ObjectUtils.warnOnce('Vector.prototype.scale is deprecated.', function(factor) {
		for (var i = this._size - 1; i >= 0; i--) {
			this.data[i] *= factor;
		}
		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.invert = ObjectUtils.warnOnce('Vector.prototype.invert is deprecated.', function () {
		for (var i = 0; i < this._size; i++) {
			this.data[i] = 0.0 - this.data[i];
		}

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.normalize = ObjectUtils.warnOnce('Vector.prototype.normalize is deprecated.', function () {
		var l = this.length();
		var dataLength = this._size;

		if (l < MathUtils.EPSILON) {
			for (var i = 0; i < dataLength; i++) {
				this.data[i] = 0;
			}
		} else {
			l = 1.0 / l;
			for (var i = 0; i < dataLength; i++) {
				this.data[i] *= l;
			}
		}

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.clone = ObjectUtils.warnOnce('Vector.prototype.clone is deprecated.', function () {
		return Vector.copy(this);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.set = ObjectUtils.warnOnce('Vector.prototype.set is deprecated.', function () {
		if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Vector) {
				this.copy(arguments[0]);
			} else {
				for (var i = 0; i < arguments[0].length; i++) {
					this.data[i] = arguments[0][i];
				}
			}
		} else {
			for (var i = 0; i < arguments.length; i++) {
				this.data[i] = arguments[i];
			}
		}

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector.prototype.toString = ObjectUtils.warnOnce('Vector.prototype.toString is deprecated.', function () {
		var string = '';

		string += '[';

		for (var i = 0; i < this._size; i++) {
			string += this.data[i];
			string += i !== this._size - 1 ? ', ' : '';
		}

		string += ']';

		return string;
	});
	// SHIM END

	return Vector;
})(goo.ObjectUtils,goo.MathUtils);
goo.Vector4 = (function (
	ObjectUtils,
	MathUtils,
	Vector
) {
	'use strict';

	/**
	 * Vector with 4 components
	 * @extends Vector
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @example
	 * var v1 = new Vector4(); // v1 == (0, 0, 0, 0)
	 * var v2 = new Vector4(1, 2, 3, 4); // v2 == (1, 2, 3, 4)
	 */
	function Vector4(x, y, z, w) {
		// #ifdef DEBUG
		this._x = 0;
		this._y = 0;
		this._z = 0;
		this._w = 0;
		// #endif

		if (arguments.length === 0) {
			// Nothing given
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Vector4) {
				// Vector4
				this.copy(arguments[0]);
			} else {
				// Array
				this.x = arguments[0][0];
				this.y = arguments[0][1];
				this.z = arguments[0][2];
				this.w = arguments[0][3];
			}
		} else {
			// Numbers
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	Vector4.prototype = Object.create(Vector.prototype);
	Vector4.prototype.constructor = Vector4;

	// #ifdef DEBUG
	Vector.setupAliases(Vector4.prototype, [['x'], ['y'], ['z'], ['w']]);
	Vector.setupIndices(Vector4.prototype, 4);
	// #endif

	Vector.setupAliases(Vector4.prototype, [['r'], ['g'], ['b'], ['a']]);

	/**
	 * Zero-vector (0, 0, 0, 0)
	 * @type {Vector4}
	 */
	Vector4.ZERO = new Vector4(0, 0, 0, 0);

	/**
	 * One-vector (1, 1, 1, 1)
	 * @type {Vector4}
	 */
	Vector4.ONE = new Vector4(1, 1, 1, 1);

	/**
	 * Unit-X (1, 0, 0, 0)
	 * @type {Vector4}
	 */
	Vector4.UNIT_X = new Vector4(1, 0, 0, 0);

	/**
	 * Unit-Y (0, 1, 0, 0)
	 * @type {Vector4}
	 */
	Vector4.UNIT_Y = new Vector4(0, 1, 0, 0);

	/**
	 * Unit-Z (0, 0, 1, 0)
	 * @type {Vector4}
	 */
	Vector4.UNIT_Z = new Vector4(0, 0, 1, 0);

	/**
	 * Unit-W (0, 0, 0, 1)
	 * @type {Vector4}
	 */
	Vector4.UNIT_W = new Vector4(0, 0, 0, 1);

	/**
	 * Returns the vector component associated with the given index.
	 * Vector components are numbered from 0 to 3 in this order: x, y, z, w.
	 * @param {number} index
	 * @returns {number}
	 */
	Vector4.prototype.getComponent = function (index) {
		switch (index) {
			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
		}
	};

	/**
	 * Sets the vector component associated with the given index to a given value.
	 * Vector components are numbered from 0 to 3 in this order: x, y, z, w.
	 * @param {number} index
	 * @param {number} value
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.setComponent = function (index, value) {
		switch (index) {
			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
		}
		return this;
	};

	/**
	 * Adds a vector to the current vector
	 * @param {Vector4} rhs
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v1 = new Vector4(1, 2, 3, 4);
	 * var v2 = new Vector4(4, 5, 6, 7);
	 * v1.add(v2); // v1 == (5, 7, 9, 11)
	 */
	Vector4.prototype.add = function (rhs) {
		this.x += rhs.x;
		this.y += rhs.y;
		this.z += rhs.z;
		this.w += rhs.w;

		return this;
	};

	/**
	 * Adds numbers 'x', 'y', 'z', 'w' to the current Vector4 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(1, 2, 3, 4);
	 * v.addDirect(2, 4, 6, 8); // v == (3, 6, 9, 12)
	 */
	Vector4.prototype.addDirect = function (x, y, z, w) {
		this.x += x;
		this.y += y;
		this.z += z;
		this.w += w;

		return this;
	};

	/**
	 * Adds a vector from the current vector
	 * @param {Vector4} rhs
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v1 = new Vector4(4, 5, 6, 7);
	 * var v2 = new Vector4(1, 2, 3, 4);
	 * v1.sub(v2); // v1 == (3, 3, 3, 3)
	 */
	Vector4.prototype.sub = function (rhs) {
		this.x -= rhs.x;
		this.y -= rhs.y;
		this.z -= rhs.z;
		this.w -= rhs.w;

		return this;
	};

	/**
	 * Subtracts numbers 'x', 'y', 'z', 'w' from the current Vector4
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(); // v == (0, 0, 0, 0)
	 * v.subDirect(1, 2, 3); // v == (-1, -2, -3, -4)
	 */
	Vector4.prototype.subDirect = function (x, y, z, w) {
		this.x -= x;
		this.y -= y;
		this.z -= z;
		this.w -= w;

		return this;
	};

	/**
	 * Performs component-wise negation of the vector
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.negate = function () {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		this.w = -this.w;

		return this;
	};

	/**
	 * Multiplies the current vector by another vector
	 * @param {Vector4} rhs
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v1 = new Vector4(4, 5, 6, 7);
	 * var v2 = new Vector4(1, 2, 3, 4);
	 * v1.mul(v2); // v1 == (4, 10, 18, 28)
	 */
	Vector4.prototype.mul = function (rhs) {
		this.x *= rhs.x;
		this.y *= rhs.y;
		this.z *= rhs.z;
		this.w *= rhs.w;

		return this;
	};

	/**
	 * Multiplies the current Vector4 by numbers 'x', 'y', 'z', 'w' as inputs
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(1, 2, 3, 4);
	 * v.mulDirect(2, 4, 6, 8); // v == (2, 8, 18, 32)
	 */
	Vector4.prototype.mulDirect = function (x, y, z, w) {
		this.x *= x;
		this.y *= y;
		this.z *= z;
		this.w *= w;

		return this;
	};

	/**
	 * Scales the vector by a factor
	 * @param {number} factor
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.scale = function (factor) {
		this.x *= factor;
		this.y *= factor;
		this.z *= factor;
		this.w *= factor;

		return this;
	};

	/**
	 * Divides the current Vector4 by another vector
	 * @param {Vector4} rhs
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(2, 4, 6, 8);
	 * v.divDirect(1, 2, 3, 4); // v == (2, 2, 2, 2)
	 */
	Vector4.prototype.div = function (rhs) {
		this.x /= rhs.x;
		this.y /= rhs.y;
		this.z /= rhs.z;
		this.w /= rhs.w;

		return this;
	};

	/**
	 * Divides the current Vector4 by numbers 'x', 'y', 'z', 'w' as inputs
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(4, 9, 16, 25);
	 * v.divDirect(2, 3, 4, 5); // v == (2, 3, 4, 5)
	 */
	Vector4.prototype.divDirect = function (x, y, z, w) {
		this.x /= x;
		this.y /= y;
		this.z /= z;
		this.w /= w;

		return this;
	};

	/**
	 * Computes the dot product between the current vector and another vector
	 * @param {Vector4} rhs
	 * @returns {number}
	 */
	Vector4.prototype.dot = function (rhs) {
		return this.x * rhs.x +
			this.y * rhs.y +
			this.z * rhs.z +
			this.w * rhs.w;
	};

	/**
	 * Computes the dot product between the current vector and another vector given as 3 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {number}
	 */
	Vector4.prototype.dotDirect = function (x, y, z, w) {
		return this.x * x +
			this.y * y +
			this.z * z +
			this.w * w;
	};

	/**
	 * Returns whether this vector is aproximately equal to a given vector
	 * @param rhs
	 * @returns {boolean}
	 */
	Vector4.prototype.equals = function (rhs) {
		return (Math.abs(this.x - rhs.x) <= MathUtils.EPSILON) &&
			(Math.abs(this.y - rhs.y) <= MathUtils.EPSILON) &&
			(Math.abs(this.z - rhs.z) <= MathUtils.EPSILON) &&
			(Math.abs(this.w - rhs.w) <= MathUtils.EPSILON);
	};

	/**
	 * Returns whether this vector is approximately equal to a given vector given as 3 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {boolean}
	 */
	Vector4.prototype.equalsDirect = function (x, y, z, w) {
		return (Math.abs(this.x - x) <= MathUtils.EPSILON) &&
			(Math.abs(this.y - y) <= MathUtils.EPSILON) &&
			(Math.abs(this.z - z) <= MathUtils.EPSILON) &&
			(Math.abs(this.w - w) <= MathUtils.EPSILON);
	};

	/**
	 * Linearly interpolates between the current Vector4 and an 'end' Vector4
	 * @param {Vector4} end End Vector4
	 * @param {number} factor Interpolation factor between 0.0 and 1.0
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var from = new Vector4(1, 2, 3, 4);
	 * var to = new Vector4(3, 4, 5, 6);
	 * var midway = from.clone().lerp(to, 0.5); // midway == (2, 3, 4, 5)
	 */
	Vector4.prototype.lerp = function (end, factor) {
		this.x += (end.x - this.x) * factor;
		this.y += (end.y - this.y) * factor;
		this.z += (end.z - this.z) * factor;
		this.w += (end.w - this.w) * factor;

		return this;
	};

	(function () {
		var tmpVec = new Vector4();

		/**
		 * Reflects a vector relative to the plane obtained from the normal parameter.
		 * @param {Vector4} normal Defines the plane that reflects the vector. Assumed to be of unit length.
		 * @returns {Vector4} Self to allow chaining
		 */
		Vector4.prototype.reflect = function (normal) {
			tmpVec.copy(normal);
			tmpVec.scale(2 * this.dot(normal));
			this.sub(tmpVec);
			return this;
		};
	})();

	/**
	 * Sets the vector's values from another vector's values
	 * @param {Vector4} rhs
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(); // v == (0, 0, 0, 0)
	 * v.set(new Vector4(2, 4, 6, 8)); // v == (2, 4, 6, 8)
	 */
	Vector4.prototype.set = function (rhs) {
		if (rhs instanceof Vector4) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			this.w = rhs.w;
		} else {
			this.x = arguments[0];
			this.y = arguments[1];
			this.z = arguments[2];
			this.w = arguments[3];
		}

		return this;
	};

	/**
	 * Sets the vector's values from 4 numeric arguments
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {Vector4} Self to allow chaining
	 * @example
	 * var v = new Vector4(); // v == (0, 0, 0, 0)
	 * v.setDirect(2, 4, 6, 8); // v == (2, 4, 6, 8)
	 */
	Vector4.prototype.setDirect = function (x, y, z, w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;
	};

	/**
	 * Calculates the squared length/magnitude of the current Vector4.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @returns {number} squared length
	 * @example
	 * var v = new Vector4(0, 9, 0, 0);
	 * v.lengthSquared(); // 81
	 */
	Vector4.prototype.lengthSquared = function () {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	};

	/**
	 * Calculates length squared of vector
	 * @returns {number} length squared
	 */
	Vector4.prototype.length = function () {
		return Math.sqrt(this.lengthSquared());
	};

	/**
	 * Normalizes the current vector
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.normalize = function () {
		var length = this.length();

		if (length < MathUtils.EPSILON) {
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;
		} else {
			this.x /= length;
			this.y /= length;
			this.z /= length;
			this.w /= length;
		}

		return this;
	};

	/**
	 * Normalizes the current vector; this method does not perform special checks for zero length vectors
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.unsafeNormalize = function () {
		var length = this.length();

		this.x /= length;
		this.y /= length;
		this.z /= length;
		this.w /= length;

		return this;
	};

	/**
	 * Computes the squared distance between the current Vector4 and another Vector4.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @param {Vector4} rhs Vector4
	 * @returns {number} distance squared
	 * @example
	 * var v1 = new Vector4(); // v1 == (0, 0, 0, 0)
	 * var v2 = new Vector4(0, 9, 0, 0);
	 * v1.distanceSquared(v2); // 81
	 */
	Vector4.prototype.distanceSquared = function (rhs) {
		var deltaX = this.x - rhs.x;
		var deltaY = this.y - rhs.y;
		var deltaZ = this.z - rhs.z;
		var deltaW = this.w - rhs.w;

		return deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ + deltaW * deltaW;
	};

	/**
	 * Computes the distance between the current Vector4 and another Vector4.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @param {Vector4} rhs Vector4
	 * @returns {number} distance
	 * @example
	 * var v1 = new Vector4(); // v1 == (0, 0, 0, 0)
	 * var v2 = new Vector4(0, 9, 0, 0);
	 * v1.distance(v2); // 9
	 */
	Vector4.prototype.distance = function (rhs) {
		return Math.sqrt(this.distanceSquared(rhs));
	};

	/**
	 * Multiplies this vector with a Matrix4
	 * @param {Matrix4} matrix
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.applyPre = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		this.x = source[ 0] * x + source[ 1] * y + source[ 2] * z + source[ 3] * w;
		this.y = source[ 4] * x + source[ 5] * y + source[ 6] * z + source[ 7] * w;
		this.z = source[ 8] * x + source[ 9] * y + source[10] * z + source[11] * w;
		this.w = source[12] * x + source[13] * y + source[14] * z + source[15] * w;

		return this;
	};

	/**
	 * Multiplies a Matrix4 with this vector
	 * @param {Matrix4} matrix
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.applyPost = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		this.x = source[0] * x + source[4] * y + source[ 8] * z + source[12] * w;
		this.y = source[1] * x + source[5] * y + source[ 9] * z + source[13] * w;
		this.z = source[2] * x + source[6] * y + source[10] * z + source[14] * w;
		this.w = source[3] * x + source[7] * y + source[11] * z + source[15] * w;

		return this;
	};

	/**
	 * Clones the vector
	 * @returns {Vector4} Clone of self
	 */
	Vector4.prototype.clone = function () {
		return new Vector4(this.x, this.y, this.z, this.w);
	};

	/**
	 * Copies the values of another vector to this vector; an alias for .setVector
	 * @param {Vector4} Source vector
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.copy = Vector4.prototype.set;

	/**
	 * Copies this vector over another. Not equivalent to `target.copy(this)` when
	 * the target vector has more components than the source vector
	 * @param {Vector} target
	 * @returns {Vector4} Self to allow chaining
	 */
	Vector4.prototype.copyTo = function (target) {
		target.x = this.x;
		target.y = this.y;
		target.z = this.z;
		target.w = this.w;

		return this;
	};

	/**
	 * Creates a Vector4 given an array
	 * @param {Array<number>} array
	 * @returns {Vector4}
	 */
	Vector4.fromArray = function (array) {
		return new Vector4(array[0], array[1], array[2], array[3]);
	};

	/**
	 * Creates a Vector4 given 4 numbers, an array, an {x, y, z, w} object or another Vector4
	 * @returns {Vector4}
	 */
	Vector4.fromAny = function () {
		if (arguments.length === 4) {
			return Vector4.fromArray(arguments);
		} else if (arguments[0] instanceof Array) {
			return Vector4.fromArray(arguments[0]);
		} else {
			var vectorLike = arguments[0];
			return new Vector4(vectorLike.x, vectorLike.y, vectorLike.z, vectorLike.w);
		}
	};

	/**
	 * Sets the vector content from an array of numbers.
	 * @param {Array<number>} array
	 */
	Vector4.prototype.setArray = function (array) {
		this.x = array[0];
		this.y = array[1];
		this.z = array[2];
		this.w = array[3];
		return this;
	};

	/**
	 * Returns the components of the vector in array form
	 * @returns {Array<number>}
	 */
	Vector4.prototype.toArray = function () {
		return [this.x, this.y, this.z, this.w];
	};

	// #ifdef DEBUG
	Vector.addReturnChecks(Vector4.prototype, [
		'dot', 'dotDirect',
		'length', 'lengthSquared',
		'distance', 'distanceSquared'
	]);
	// #endif

	// SHIM START
	Object.defineProperty(Vector4.prototype, 'data', {
		get: ObjectUtils.warnOnce('The .data property of Vector4 was removed. Please use the .x, .y, .z and .w properties instead.', function () {
			var data = [];
			var that = this;
			Object.defineProperties(data, {
				'0': {
					get: function () {
						return that.x;
					},
					set: function (value) {
						that.x = value;
					}
				},
				'1': {
					get: function () {
						return that.y;
					},
					set: function (value) {
						that.y = value;
					}
				},
				'2': {
					get: function () {
						return that.z;
					},
					set: function (value) {
						that.z = value;
					}
				},
				'3': {
					get: function () {
						return that.w;
					},
					set: function (value) {
						that.w = value;
					}
				}
			});
			return data;
		})
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.prototype.setVector = ObjectUtils.warnOnce('The setVector method of Vector4 is deprecated. Please use the set method instead.', function (rhs) {
		return this.set(rhs);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.add = ObjectUtils.warnOnce('Vector4.add is deprecated. Use Vector4.prototype.add instead.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs, rhs];
		}

		if (!target) {
			target = new Vector4();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] + rdata[0];
		target.data[1] = ldata[1] + rdata[1];
		target.data[2] = ldata[2] + rdata[2];
		target.data[3] = ldata[3] + rdata[3];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.sub = ObjectUtils.warnOnce('Vector4.sub is deprecated. Use Vector4.prototype.sub instead.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs, rhs];
		}

		if (!target) {
			target = new Vector4();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] - rdata[0];
		target.data[1] = ldata[1] - rdata[1];
		target.data[2] = ldata[2] - rdata[2];
		target.data[3] = ldata[3] - rdata[3];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.mul = ObjectUtils.warnOnce('Vector4.mul is deprecated. Use Vector4.prototype.mul instead.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs, rhs];
		}

		if (!target) {
			target = new Vector4();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] * rdata[0];
		target.data[1] = ldata[1] * rdata[1];
		target.data[2] = ldata[2] * rdata[2];
		target.data[3] = ldata[3] * rdata[3];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.div = ObjectUtils.warnOnce('Vector4.div is deprecated. Use Vector4.prototype.div instead.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs, rhs];
		}

		if (!target) {
			target = new Vector4();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] / rdata[0];
		target.data[1] = ldata[1] / rdata[1];
		target.data[2] = ldata[2] / rdata[2];
		target.data[3] = ldata[3] / rdata[3];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.dot = ObjectUtils.warnOnce('Vector4.dot is deprecated. Use Vector4.prototype.dot instead.', function (lhs, rhs) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs, rhs];
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		return ldata[0] * rdata[0] +
			ldata[1] * rdata[1] +
			ldata[2] * rdata[2] +
			ldata[3] * rdata[3];
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.prototype.addVector = ObjectUtils.warnOnce('Vector4.prototype.addVector is deprecated. Use .add instead.', function (vector) {
		this.data[0] += vector.data[0];
		this.data[1] += vector.data[1];
		this.data[2] += vector.data[2];
		this.data[3] += vector.data[3];

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.prototype.dotVector = ObjectUtils.warnOnce('Vector4.prototype.dotVector is deprecated. Use .dot instead.', function (rhs) {
		var ldata = this.data;
		var rdata = rhs.data;

		return ldata[0] * rdata[0] +
			ldata[1] * rdata[1] +
			ldata[2] * rdata[2] +
			ldata[3] * rdata[3];
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.prototype.mulVector = ObjectUtils.warnOnce('Vector4.prototype.mulVector is deprecated. Use .mul instead.', function (vector) {
		this.data[0] *= vector.data[0];
		this.data[1] *= vector.data[1];
		this.data[2] *= vector.data[2];
		this.data[3] *= vector.data[3];

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.prototype.setVector = ObjectUtils.warnOnce('Vector4.prototype.setVector is deprecated. Use .set instead.', function (vector) {
		this.data[0] = vector.data[0];
		this.data[1] = vector.data[1];
		this.data[2] = vector.data[2];
		this.data[3] = vector.data[3];

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector4.prototype.subVector = ObjectUtils.warnOnce('Vector4.prototype.subVector is deprecated. Use .sub instead.', function (vector) {
		this.data[0] -= vector.data[0];
		this.data[1] -= vector.data[1];
		this.data[2] -= vector.data[2];
		this.data[3] -= vector.data[3];

		return this;
	});

	// SHIM END

	return Vector4;
})(goo.ObjectUtils,goo.MathUtils,goo.Vector);
goo.Vector3 = (function (
	ObjectUtils,
	MathUtils,
	Vector,
	Vector4
) {
	'use strict';

	/**
	 * Vector with 3 components
	 * @extends Vector
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @example
	 * var v1 = new Vector3(); // v1 == (0, 0, 0)
	 * var v2 = new Vector3(1, 2, 3); // v2 == (1, 2, 3)
	 */
	function Vector3(x, y, z) {
		// #ifdef DEBUG
		this._x = 0;
		this._y = 0;
		this._z = 0;
		// #endif

		if (arguments.length === 0) {
			// Nothing given
			this.x = 0;
			this.y = 0;
			this.z = 0;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Vector3) {
				// Vector3
				this.copy(arguments[0]);
			} else {
				// Array
				this.x = arguments[0][0];
				this.y = arguments[0][1];
				this.z = arguments[0][2];
			}
		} else {
			// Numbers
			this.x = x;
			this.y = y;
			this.z = z;
		}

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	Vector3.prototype = Object.create(Vector.prototype);
	Vector3.prototype.constructor = Vector3;

	// #ifdef DEBUG
	Vector.setupAliases(Vector3.prototype, [['x'], ['y'], ['z']]);
	Vector.setupIndices(Vector3.prototype, 3);
	// #endif

	Vector.setupAliases(Vector3.prototype, [['u', 'r'], ['v', 'g'], ['w', 'b']]);

	/**
	 * Zero-vector (0, 0, 0)
	 * @type {Vector3}
	 */
	Vector3.ZERO = new Vector3(0, 0, 0);

	/**
	 * One-vector (1, 1, 1)
	 * @type {Vector3}
	 */
	Vector3.ONE = new Vector3(1, 1, 1);

	/**
	 * Unit-X (1, 0, 0)
	 * @type {Vector3}
	 */
	Vector3.UNIT_X = new Vector3(1, 0, 0);

	/**
	 * Unit-Y (0, 1, 0)
	 * @type {Vector3}
	 */
	Vector3.UNIT_Y = new Vector3(0, 1, 0);

	/**
	 * Unit-Z (0, 0, 1)
	 * @type {Vector3}
	 */
	Vector3.UNIT_Z = new Vector3(0, 0, 1);

	/**
	 * Returns the vector component associated with the given index.
	 * Vector components are numbered from 0 to 2 in this order: x, y, z.
	 * @param {number} index
	 * @returns {number}
	 */
	Vector3.prototype.getComponent = function (index) {
		switch (index) {
			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
		}
	};

	/**
	 * Sets the vector component associated with the given index to a given value.
	 * Vector components are numbered from 0 to 2 in this order: x, y, z.
	 * @param {number} index
	 * @param {number} value
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.setComponent = function (index, value) {
		switch (index) {
			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
		}
		return this;
	};

	/**
	 * Adds a vector to the current vector
	 * @param {Vector3} rhs
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v1 = new Vector3(1, 2, 3);
	 * var v2 = new Vector3(4, 5, 6);
	 * v1.add(v2); // v1 == (5, 7, 9)
	 */
	Vector3.prototype.add = function (rhs) {
		if (rhs instanceof Vector3) {
			this.x += rhs.x;
			this.y += rhs.y;
			this.z += rhs.z;
		} else if (rhs instanceof Vector4) {
			console.warn('Passing a Vector4 argument to Vector3.prototype.add is deprecated. Consider using .addDirect instead.');
			this.x += rhs.x;
			this.y += rhs.y;
			this.z += rhs.z;
		} else if (typeof (rhs) === 'object' && typeof (rhs.length) === 'number') {
			console.warn('Passing arrays to Vector3.prototype.add is deprecated - use Vector3.prototype.addDirect instead.');
			this.x += rhs[0];
			this.y += rhs[1];
			this.z += rhs[2];
		} else if (typeof (rhs) === 'number') {
			console.warn('Passing numbers to Vector3.prototype.add is deprecated - use Vector3.prototype.addDirect instead.');
			this.x += rhs;
			this.y += rhs;
			this.z += rhs;
		} else {
			console.warn('Vector3.prototype.add only supports vector arguments now.');
		}

		return this;
	};

	/**
	 * Adds numbers 'x', 'y', 'z' to the current Vector3 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(1, 2, 3);
	 * v.addDirect(2, 4, 6); // v == (3, 6, 9)
	 */
	Vector3.prototype.addDirect = function (x, y, z) {
		this.x += x;
		this.y += y;
		this.z += z;

		return this;
	};

	/**
	 * Adds a vector from the current vector
	 * @param {Vector3} rhs
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v1 = new Vector3(4, 5, 6);
	 * var v2 = new Vector3(1, 2, 3);
	 * v1.sub(v2); // v1 == (3, 3, 3)
	 */
	Vector3.prototype.sub = function (rhs) {
		this.x -= rhs.x;
		this.y -= rhs.y;
		this.z -= rhs.z;

		return this;
	};

	/**
	 * Subtracts numbers 'x', 'y', 'z' from the current Vector3
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(); // v == (0, 0, 0)
	 * v.subDirect(1, 2, 3); // v == (-1, -2, -3)
	 */
	Vector3.prototype.subDirect = function (x, y, z) {
		this.x -= x;
		this.y -= y;
		this.z -= z;

		return this;
	};

	/**
	 * Performs component-wise negation of the vector
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.negate = function () {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;

		return this;
	};

	/**
	 * Multiplies the current vector by another vector
	 * @param {Vector3} rhs
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v1 = new Vector3(4, 5, 6);
	 * var v2 = new Vector3(1, 2, 3);
	 * v1.mul(v2); // v1 == (4, 10, 18)
	 */
	Vector3.prototype.mul = function (rhs) {
		if (typeof (rhs) === 'number') {
			console.warn('Vector3.prototype.mul only accepts vector arguments now. Please use Vector3.prototype.scale instead.');
			this.x *= rhs;
			this.y *= rhs;
			this.z *= rhs;
		} else {
			this.x *= rhs.x;
			this.y *= rhs.y;
			this.z *= rhs.z;
		}

		return this;
	};

	/**
	 * Multiplies the current Vector3 by numbers 'x', 'y', 'z' as inputs
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(1, 2, 3);
	 * v.mulDirect(2, 4, 6); // v == (2, 8, 18)
	 */
	Vector3.prototype.mulDirect = function (x, y, z) {
		this.x *= x;
		this.y *= y;
		this.z *= z;

		return this;
	};

	/**
	 * Scales the vector by a factor
	 * @param {number} factor
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.scale = function (factor) {
		this.x *= factor;
		this.y *= factor;
		this.z *= factor;

		return this;
	};

	/**
	 * Divides the current Vector3 by another vector
	 * @param {Vector3} rhs
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(2, 4, 6);
	 * v.div(1, 2, 3); // v == (2, 2, 2)
	 */
	Vector3.prototype.div = function (rhs) {
		if (typeof (rhs) === 'number') {
			console.warn('Passing a number argument to Vector3.prototype.div is deprecated. Use Vector3.prototype.divDirect instead.');
			this.x /= rhs;
			this.y /= rhs;
			this.z /= rhs;
		} else {
			this.x /= rhs.x;
			this.y /= rhs.y;
			this.z /= rhs.z;
		}

		return this;
	};

	/**
	 * Divides the current Vector3 by numbers 'x', 'y', 'z' as inputs
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(2, 4, 6);
	 * v.divDirect(1, 2, 3); // v == (2, 2, 2)
	 */
	Vector3.prototype.divDirect = function (x, y, z) {
		this.x /= x;
		this.y /= y;
		this.z /= z;

		return this;
	};

	/**
	 * Computes the dot product between the current vector and another vector
	 * @param {Vector3} rhs
	 * @returns {number}
	 */
	Vector3.prototype.dot = function (rhs) {
		return this.x * rhs.x +
			this.y * rhs.y +
			this.z * rhs.z;
	};

	/**
	 * Computes the dot product between the current vector and another vector given as 3 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {number}
	 */
	Vector3.prototype.dotDirect = function (x, y, z) {
		return this.x * x +
			this.y * y +
			this.z * z;
	};

	/**
	 * Returns whether this vector is aproximately equal to a given vector
	 * @param rhs
	 * @returns {boolean}
	 */
	Vector3.prototype.equals = function (rhs) {
		return (Math.abs(this.x - rhs.x) <= MathUtils.EPSILON) &&
			(Math.abs(this.y - rhs.y) <= MathUtils.EPSILON) &&
			(Math.abs(this.z - rhs.z) <= MathUtils.EPSILON);
	};

	/**
	 * Returns whether this vector is approximately equal to a given vector given as 3 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {boolean}
	 */
	Vector3.prototype.equalsDirect = function (x, y, z) {
		return (Math.abs(this.x - x) <= MathUtils.EPSILON) &&
			(Math.abs(this.y - y) <= MathUtils.EPSILON) &&
			(Math.abs(this.z - z) <= MathUtils.EPSILON);
	};

	/**
	 * Computes the cross product between the current Vector3 and another vector
	 * @param {Vector3} rhs
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v1 = new Vector3(0, 1, 0);
	 * var v2 = new Vector3(0, 0, -1);
	 * v1.cross(v2); // v1 == (-1, 0, 0)
	 */
	Vector3.prototype.cross = function (rhs) {
		var x = this.x;
		var y = this.y;
		var z = this.z;

		this.x = rhs.z * y - rhs.y * z;
		this.y = rhs.x * z - rhs.z * x;
		this.z = rhs.y * x - rhs.x * y;

		return this;
	};

	/**
	 * Computes the cross product between the current Vector3 and another vector given as 3 values
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v1 = new Vector3(0, 1, 0);
	 * var v2 = new Vector3(0, 0, -1);
	 * v1.cross(v2); // v1 == (-1, 0, 0)
	 */
	Vector3.prototype.crossDirect = function (x, y, z) {
		var thisX = this.x;
		var thisY = this.y;
		var thisZ = this.z;

		this.x = z * thisY - y * thisZ;
		this.y = x * thisZ - z * thisX;
		this.z = y * thisX - x * thisY;

		return this;
	};

	/**
	 * Linearly interpolates between the current Vector3 and an 'end' Vector3
	 * @param {Vector3} end End Vector3
	 * @param {number} factor Interpolation factor between 0.0 and 1.0
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var from = new Vector3(1, 2, 3);
	 * var to = new Vector3(3, 4, 5);
	 * var midway = from.clone().lerp(to, 0.5); // midway == (2, 3, 4)
	 */
	Vector3.prototype.lerp = function (end, factor) {
		this.x += (end.x - this.x) * factor;
		this.y += (end.y - this.y) * factor;
		this.z += (end.z - this.z) * factor;

		return this;
	};

	(function () {
		var tmpVec = new Vector3();

		/**
		 * Reflects a vector relative to the plane obtained from the normal parameter.
		 * @param {Vector3} normal Defines the plane that reflects the vector. Assumed to be of unit length.
		 * @returns {Vector3} Self to allow chaining
		 */
		Vector3.prototype.reflect = function (normal) {
			tmpVec.copy(normal);
			tmpVec.scale(2 * this.dot(normal));
			this.sub(tmpVec);
			return this;
		};
	})();

	/**
	 * Sets the vector's values from another vector's values
	 * @param {Vector3} rhs
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(); // v == (0, 0, 0)
	 * v.set(new Vector3(2, 4, 6)); // v == (2, 4, 6)
	 */
	Vector3.prototype.set = function (rhs) {
		if (rhs instanceof Vector3 || rhs instanceof Vector4) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
		} else {
			this.x = arguments[0];
			this.y = arguments[1];
			this.z = arguments[2];
		}

		return this;
	};

	/**
	 * Sets the vector's values from 3 numeric arguments
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Vector3} Self to allow chaining
	 * @example
	 * var v = new Vector3(); // v == (0, 0, 0)
	 * v.setDirect(2, 4, 6); // v == (2, 4, 6)
	 */
	Vector3.prototype.setDirect = function (x, y, z) {
		this.x = x;
		this.y = y;
		this.z = z;

		return this;
	};

	/**
	 * Calculates the squared length/magnitude of the current Vector3.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @returns {number} squared length
	 * @example
	 * var v = new Vector3(0, 9, 0);
	 * v.lengthSquared(); // 81
	 */
	Vector3.prototype.lengthSquared = function () {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	};

	/**
	 * Calculates length squared of vector
	 * @returns {number} length squared
	 */
	Vector3.prototype.length = function () {
		return Math.sqrt(this.lengthSquared());
	};

	/**
	 * Normalizes the current vector
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.normalize = function () {
		var length = this.length();

		if (length < MathUtils.EPSILON) {
			this.x = 0;
			this.y = 0;
			this.z = 0;
		} else {
			this.x /= length;
			this.y /= length;
			this.z /= length;
		}

		return this;
	};

	/**
	 * Normalizes the current vector; this method does not perform special checks for zero length vectors
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.unsafeNormalize = function () {
		var length = this.length();

		this.x /= length;
		this.y /= length;
		this.z /= length;

		return this;
	};

	/**
	 * Computes the squared distance between the current Vector3 and another Vector3.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @param {Vector3} rhs Vector3
	 * @returns {number} distance squared
	 * @example
	 * var v1 = new Vector3(); // v1 == (0, 0, 0)
	 * var v2 = new Vector3(0, 9, 0);
	 * v1.distanceSquared(v2); // 81
	 */
	Vector3.prototype.distanceSquared = function (rhs) {
		var deltaX = this.x - rhs.x;
		var deltaY = this.y - rhs.y;
		var deltaZ = this.z - rhs.z;

		return deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ;
	};

	/**
	 * Computes the distance between the current Vector3 and another Vector3.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @param {Vector3} rhs Vector3
	 * @returns {number} distance
	 * @example
	 * var v1 = new Vector3(); // v1 == (0, 0, 0)
	 * var v2 = new Vector3(0, 9, 0);
	 * v1.distance(v2); // 9
	 */
	Vector3.prototype.distance = function (rhs) {
		return Math.sqrt(this.distanceSquared(rhs));
	};

	/**
	 * Multiplies this vector with a Matrix3
	 * @param {Matrix3} matrix
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.applyPre = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;
		var z = this.z;

		this.x = source[0] * x + source[1] * y + source[2] * z;
		this.y = source[3] * x + source[4] * y + source[5] * z;
		this.z = source[6] * x + source[7] * y + source[8] * z;

		return this;
	};

	/**
	 * Multiplies a Matrix3 with this vector
	 * @param {Matrix3} matrix
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.applyPost = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;
		var z = this.z;

		this.x = source[0] * x + source[3] * y + source[6] * z;
		this.y = source[1] * x + source[4] * y + source[7] * z;
		this.z = source[2] * x + source[5] * y + source[8] * z;

		return this;
	};

	/**
	 * Applies a Matrix4 (rotation, scale, translation) to this vector
	 * @param {Matrix4} matrix
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.applyPostPoint = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;
		var z = this.z;

		this.x = source[0] * x + source[4] * y + source[ 8] * z + source[12];
		this.y = source[1] * x + source[5] * y + source[ 9] * z + source[13];
		this.z = source[2] * x + source[6] * y + source[10] * z + source[14];

		return this;
	};

	/**
	 * Applies a Matrix4 (rotation, scale) to this vector
	 * @param {Matrix4} matrix
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.applyPostVector = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;
		var z = this.z;

		this.x = source[0] * x + source[4] * y + source[8] * z;
		this.y = source[1] * x + source[5] * y + source[9] * z;
		this.z = source[2] * x + source[6] * y + source[10] * z;

		return this;
	};

	/**
	 * Clones the vector
	 * @returns {Vector3} Clone of self
	 */
	Vector3.prototype.clone = function () {
		return new Vector3(this.x, this.y, this.z);
	};

	/**
	 * Copies the values of another vector to this vector; an alias for .setVector
	 * @param {Vector3} Source vector
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.copy = Vector3.prototype.set;

	/**
	 * Copies this vector over another. Not equivalent to `target.copy(this)` when
	 * the target vector has more components than the source vector
	 * @param {Vector} target
	 * @returns {Vector3} Self to allow chaining
	 */
	Vector3.prototype.copyTo = function (target) {
		target.x = this.x;
		target.y = this.y;
		target.z = this.z;

		return this;
	};

	/**
	 * Returns the components of the vector in array form
	 * @returns {Array<number>}
	 */
	Vector3.prototype.toArray = function () {
		return [this.x, this.y, this.z];
	};

	/**
	 * Creates a Vector3 given an array
	 * @param {Array<number>} array
	 * @returns {Vector3}
	 */
	Vector3.fromArray = function (array) {
		return new Vector3(array[0], array[1], array[2]);
	};

	/**
	 * Creates a Vector3 given 3 numbers, an array, an {x, y, z} object or another Vector3
	 * @returns {Vector3}
	 */
	Vector3.fromAny = function () {
		if (arguments.length === 3) {
			return Vector3.fromArray(arguments);
		} else if (arguments[0] instanceof Array) {
			return Vector3.fromArray(arguments[0]);
		} else {
			var vectorLike = arguments[0];
			return new Vector3(vectorLike.x, vectorLike.y, vectorLike.z);
		}
	};

	/**
	 * Sets the vector content from an array of numbers.
	 * @param {Array<number>} array
	 */
	Vector3.prototype.setArray = function (array) {
		this.x = array[0];
		this.y = array[1];
		this.z = array[2];
		
		return this;
	};

	// SHIM START
	Object.defineProperty(Vector3.prototype, 'data', {
		get: ObjectUtils.warnOnce('The .data property of Vector3 was removed. Please use the .x, .y and .z properties instead.', function () {
			var data = [];
			var that = this;
			Object.defineProperties(data, {
				'0': {
					get: function () {
						return that.x;
					},
					set: function (value) {
						that.x = value;
					}
				},
				'1': {
					get: function () {
						return that.y;
					},
					set: function (value) {
						that.y = value;
					}
				},
				'2': {
					get: function () {
						return that.z;
					},
					set: function (value) {
						that.z = value;
					}
				}
			});
			return data;
		})
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.prototype.setVector = ObjectUtils.warnOnce('The setVector method of Vector3 is deprecated. Please use the set method instead.', function (rhs) {
		return this.set(rhs);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.add = ObjectUtils.warnOnce('Vector3.add is deprecated. Use Vector3.prototype.add instead.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs];
		}

		if (!target) {
			target = new Vector3();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] + rdata[0];
		target.data[1] = ldata[1] + rdata[1];
		target.data[2] = ldata[2] + rdata[2];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.cross = ObjectUtils.warnOnce('Vector3.cross is deprecated. Use Vector3.prototype.cross instead.', function (lhs, rhs, target) {
		if (!target) {
			target = new Vector3();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		var x = rdata[2] * ldata[1] - rdata[1] * ldata[2];
		var y = rdata[0] * ldata[2] - rdata[2] * ldata[0];
		var z = rdata[1] * ldata[0] - rdata[0] * ldata[1];

		target.data[0] = x;
		target.data[1] = y;
		target.data[2] = z;

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.distance = ObjectUtils.warnOnce('Vector3.distance is deprecated. Use Vector3.prototype.distance instead.', function (lhs, rhs) {
		return Math.sqrt(Vector3.distanceSquared(lhs, rhs));
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.distanceSquared = ObjectUtils.warnOnce('Vector3.distanceSquared is deprecated. Use Vector3.prototype.distanceSquared instead.', function (lhs, rhs) {
		var x = lhs.x - rhs.x,
			y = lhs.y - rhs.y,
			z = lhs.z - rhs.z;
		return x * x + y * y + z * z;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.div = ObjectUtils.warnOnce('Vector3.div is deprecated. Use Vector3.prototype.div instead.', function (lhs, rhs, target) {
		if (!target) {
			target = new Vector3();
		}

		if (typeof lhs === 'number') {
			var rdata = rhs.data || rhs;

			target.data[0] = lhs / rdata[0];
			target.data[1] = lhs / rdata[1];
			target.data[2] = lhs / rdata[2];
		} else if (typeof rhs === 'number') {
			var irhs = 1 / rhs;
			var ldata = lhs.data || lhs;

			target.data[0] = ldata[0] * irhs;
			target.data[1] = ldata[1] * irhs;
			target.data[2] = ldata[2] * irhs;
		} else {
			var ldata = lhs.data || lhs;
			var rdata = rhs.data || rhs;

			target.data[0] = ldata[0] / rdata[0];
			target.data[1] = ldata[1] / rdata[1];
			target.data[2] = ldata[2] / rdata[2];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.dot = ObjectUtils.warnOnce('Vector3.dot is deprecated. Use Vector3.prototype.dot instead.', function (lhs, rhs) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs];
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		return ldata[0] * rdata[0] +
			ldata[1] * rdata[1] +
			ldata[2] * rdata[2];
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.mul = ObjectUtils.warnOnce('Vector3.mul is deprecated. Use Vector3.prototype.mul instead.', function (lhs, rhs, target) {
		if (!target) {
			target = new Vector3();
		}

		if (typeof lhs === 'number') {
			var rdata = rhs.data || rhs;

			target.data[0] = lhs * rdata[0];
			target.data[1] = lhs * rdata[1];
			target.data[2] = lhs * rdata[2];
		} else if (typeof rhs === 'number') {
			var ldata = lhs.data || lhs;

			target.data[0] = ldata[0] * rhs;
			target.data[1] = ldata[1] * rhs;
			target.data[2] = ldata[2] * rhs;
		} else {
			var ldata = lhs.data || lhs;
			var rdata = rhs.data || rhs;

			target.data[0] = ldata[0] * rdata[0];
			target.data[1] = ldata[1] * rdata[1];
			target.data[2] = ldata[2] * rdata[2];
		}

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.prototype.addVector = ObjectUtils.warnOnce('Vector3.prototype.addVector is deprecated. Use Vector3.prototype.add instead.', function (vector) {
		this.x += vector.x;
		this.y += vector.y;
		this.z += vector.z;

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.prototype.mulVector = ObjectUtils.warnOnce('Vector3.prototype.mulVector is deprecated. Use .mul instead.', function (vec3) {
		this.x *= vec3.x;
		this.y *= vec3.y;
		this.z *= vec3.z;

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.prototype.dotVector = ObjectUtils.warnOnce('Vector3.prototype.dotVector is deprecated. Use .dot instead.', function (rhs) {
		var ldata = this.data;
		var rdata = rhs.data;

		return ldata[0] * rdata[0] +
			ldata[1] * rdata[1] +
			ldata[2] * rdata[2];
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.prototype.invert = ObjectUtils.warnOnce('Vector3.prototype.invert is deprecated. Use .negate instead.', function () {
		this.x = 0.0 - this.x;
		this.y = 0.0 - this.y;
		this.z = 0.0 - this.z;

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.prototype.subVector = ObjectUtils.warnOnce('Vector3.prototype.subVector is deprecated. Use .sub instead.', function (vector) {
		this.x -= vector.x;
		this.y -= vector.y;
		this.z -= vector.z;

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector3.sub = ObjectUtils.warnOnce('Vector3.sub is deprecated. Use Vector3.prototype.sub instead.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs, rhs];
		}

		if (!target) {
			target = new Vector3();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] - rdata[0];
		target.data[1] = ldata[1] - rdata[1];
		target.data[2] = ldata[2] - rdata[2];

		return target;
	});
	// SHIM END

	// #ifdef DEBUG
	Vector.addReturnChecks(Vector3.prototype, [
		'dot', 'dotDirect',
		'length', 'lengthSquared',
		'distance', 'distanceSquared'
	]);
	// #endif

	return Vector3;
})(goo.ObjectUtils,goo.MathUtils,goo.Vector,goo.Vector4);
goo.BoundingVolume = (function (
	Vector3
) {
	'use strict';

	/**
	 * <code>BoundingVolume</code> Base class for boundings
	 */
	function BoundingVolume(center) {
		//! AT: this is one of the few classes that's cloning its input
		// I don't dare change the behaviour since there's no telling what will break
		this.center = new Vector3();
		if (center) {
			this.center.set(center);
		}

		//! AT: can these be private?
		// they are updated only by some methods and would therefore be useless for external use
		this.min = new Vector3(Infinity, Infinity, Infinity);
		this.max = new Vector3(-Infinity, -Infinity, -Infinity);
	}

	/**
	 * Copies data from another bounding volume
	 * @param {BoundingVolume} source
	 * @returns {BoundingVolume}
	 */
	BoundingVolume.prototype.copy = function (source) {
		this.center.copy(source.center);
		this.min.copy(source.min);
		this.min.copy(source.min);
		return this;
	};

	/**
	 * Intersection type
	 */
	BoundingVolume.Outside = 0;
	BoundingVolume.Inside = 1;
	BoundingVolume.Intersects = 2;

	return BoundingVolume;
})(goo.Vector3);
goo.Capabilities = (function () {
	'use strict';

	/**
	 * Enabled and stores webgl extensions and capabilities

	 * Extensions
	 * @property {Object} CompressedTextureS3TC S3TC (DXT) compression, WEBGL_compressed_texture_s3tc
	 * @property {Object} TextureFloat Floating point textures, OES_texture_float
	 * @property {Object} TextureFloatLinear Linear filtering of floating point textures, OES_texture_float_linear
	 * @property {Object} TextureHalfFloat 16-bit floating point textures, OES_texture_half_float
	 * @property {Object} TextureHalfFloatLinear Linear filtering of 16-bit floating point textures, OES_texture_half_float_linear
	 * @property {Object} StandardDerivatives Enabled dFdx/dFdy/fwidth in fragment shaders, OES_standard_derivatives
	 * @property {Object} TextureFilterAnisotropic Anisotropic filtering of textures, EXT_texture_filter_anisotropic
	 * @property {Object} DepthTexture Depth textures, WEBGL_depth_texture
	 * @property {Object} ElementIndexUInt 32-bit index buffers, OES_element_index_uint
	 * @property {Object} InstancedArrays Instanced arrays, ANGLE_instanced_arrays
	 * @property {Object} BlendMinmax BlendMinmax, EXT_blend_minmax
	 * @property {Object} FragDepth FragDepth, EXT_frag_depth
	 * @property {Object} ShaderTextureLod ShaderTextureLod, EXT_shader_texture_lod
	 * @property {Object} VertexArrayObject VertexArrayObject, OES_vertex_array_object
	 * @property {Object} DrawBuffers Multiple rendertargets, WEBGL_draw_buffers

	 * Properties
	 * @property {number} maxTexureSize Maximum 2D texture size
	 * @property {number} maxCubemapSize Maximum cubemap size
	 * @property {number} maxRenderbufferSize Maximum renderbuffer size
	 * @property {Array<number>} maxViewPortDims Maximum viewport size [x, y]
	 * @property {number} maxVertexTextureUnits Maximum vertex shader texture units
	 * @property {number} maxFragmentTextureUnits Maximum fragment shader texture units
	 * @property {number} maxCombinedTextureUnits Maximum total texture units
	 * @property {number} maxVertexAttributes Maximum vertex attributes
	 * @property {number} maxVertexUniformVectors Maximum vertex uniform vectors
	 * @property {number} maxFragmentUniformVectors Maximum fragment uniform vectors
	 * @property {number} maxVaryingVectors Maximum varying vectors
	 * @property {number} aliasedPointSizeRange Point size min/max [min, max]
	 * @property {number} aliasedLineWidthRange Line width min/max [min, max]
	 * @property {number} samples Antialiasing sample size
	 * @property {number} sampleBuffers Sample buffer count
	 * @property {number} depthBits Depth bits
	 * @property {number} stencilBits Stencil bits
	 * @property {number} subpixelBits Sub-pixel bits
	 * @property {number} supportedExtensionsList Supported extension as an array
	 * @property {number} renderer Renderer name
	 * @property {number} vendor Vendor name
	 * @property {number} version Version string
	 * @property {number} shadingLanguageVersion Shadinglanguage version string
	 */
	function Capabilities() {}

	/**
	 * Initialize capabilities from rendering context.
	 * @param {WebGLRenderingContext} context WebGLRenderingContext
	 */
	Capabilities.init = function (context) {
		// Extensions
		Capabilities.CompressedTextureS3TC = context.getExtension('WEBGL_compressed_texture_s3tc')
										|| context.getExtension('MOZ_WEBGL_compressed_texture_s3tc')
										|| context.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
		Capabilities.TextureFloat = context.getExtension('OES_texture_float');
		Capabilities.TextureFloatLinear = context.getExtension('OES_texture_float_linear');
		Capabilities.TextureHalfFloat = context.getExtension('OES_texture_half_float');
		Capabilities.TextureHalfFloatLinear = context.getExtension('OES_texture_half_float_linear');
		Capabilities.StandardDerivatives = context.getExtension('OES_standard_derivatives');
		Capabilities.TextureFilterAnisotropic = context.getExtension('EXT_texture_filter_anisotropic')
										|| context.getExtension('MOZ_EXT_texture_filter_anisotropic')
										|| context.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
		Capabilities.DepthTexture = context.getExtension('WEBGL_depth_texture')
										|| context.getExtension('WEBKIT_WEBGL_depth_texture')
										|| context.getExtension('MOZ_WEBGL_depth_texture');
		Capabilities.ElementIndexUInt = context.getExtension('OES_element_index_uint');

		// verify these
		Capabilities.InstancedArrays = context.getExtension('ANGLE_instanced_arrays');
		Capabilities.BlendMinmax = context.getExtension('EXT_blend_minmax');
		Capabilities.FragDepth = context.getExtension('EXT_frag_depth');
		Capabilities.ShaderTextureLod = context.getExtension('EXT_shader_texture_lod');
		Capabilities.VertexArrayObject = context.getExtension('OES_vertex_array_object');
		Capabilities.DrawBuffers = context.getExtension('WEBGL_draw_buffers');
		// end verify

		// Parameters
		Capabilities.maxTexureSize = context.getParameter(context.MAX_TEXTURE_SIZE);
		Capabilities.maxCubemapSize = context.getParameter(context.MAX_CUBE_MAP_TEXTURE_SIZE);
		Capabilities.maxRenderbufferSize = context.getParameter(context.MAX_RENDERBUFFER_SIZE);
		Capabilities.maxViewPortDims = context.getParameter(context.MAX_VIEWPORT_DIMS); // [x, y]
		Capabilities.maxAnisotropy = Capabilities.TextureFilterAnisotropic ? context.getParameter(Capabilities.TextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;

		Capabilities.maxVertexTextureUnits = context.getParameter(context.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		Capabilities.maxFragmentTextureUnits = context.getParameter(context.MAX_TEXTURE_IMAGE_UNITS);
		Capabilities.maxCombinedTextureUnits = context.getParameter(context.MAX_COMBINED_TEXTURE_IMAGE_UNITS);

		Capabilities.maxVertexAttributes = context.getParameter(context.MAX_VERTEX_ATTRIBS);
		Capabilities.maxVertexUniformVectors = context.getParameter(context.MAX_VERTEX_UNIFORM_VECTORS);
		Capabilities.maxFragmentUniformVectors = context.getParameter(context.MAX_FRAGMENT_UNIFORM_VECTORS);
		Capabilities.maxVaryingVectors = context.getParameter(context.MAX_VARYING_VECTORS);

		Capabilities.aliasedPointSizeRange = context.getParameter(context.ALIASED_POINT_SIZE_RANGE); // [min, max]
		Capabilities.aliasedLineWidthRange = context.getParameter(context.ALIASED_LINE_WIDTH_RANGE); // [min, max]

		Capabilities.samples = context.getParameter(context.SAMPLES);
		Capabilities.sampleBuffers = context.getParameter(context.SAMPLE_BUFFERS);

		Capabilities.depthBits = context.getParameter(context.DEPTH_BITS);
		Capabilities.stencilBits = context.getParameter(context.STENCIL_BITS);
		Capabilities.subpixelBits = context.getParameter(context.SUBPIXEL_BITS);
		Capabilities.supportedExtensionsList = context.getSupportedExtensions();

		Capabilities.renderer = context.getParameter(context.RENDERER);
		Capabilities.vendor = context.getParameter(context.VENDOR);
		Capabilities.version = context.getParameter(context.VERSION);
		Capabilities.shadingLanguageVersion = context.getParameter(context.SHADING_LANGUAGE_VERSION);

		Capabilities.vertexShaderHighpFloat = context.getShaderPrecisionFormat(context.VERTEX_SHADER, context.HIGH_FLOAT);
		Capabilities.vertexShaderMediumpFloat = context.getShaderPrecisionFormat(context.VERTEX_SHADER, context.MEDIUM_FLOAT);
		Capabilities.vertexShaderLowpFloat = context.getShaderPrecisionFormat(context.VERTEX_SHADER, context.LOW_FLOAT);
		Capabilities.fragmentShaderHighpFloat = context.getShaderPrecisionFormat(context.FRAGMENT_SHADER, context.HIGH_FLOAT);
		Capabilities.fragmentShaderMediumpFloat = context.getShaderPrecisionFormat(context.FRAGMENT_SHADER, context.MEDIUM_FLOAT);
		Capabilities.fragmentShaderLowpFloat = context.getShaderPrecisionFormat(context.FRAGMENT_SHADER, context.LOW_FLOAT);

		Capabilities.vertexShaderHighpInt = context.getShaderPrecisionFormat(context.VERTEX_SHADER, context.HIGH_INT);
		Capabilities.vertexShaderMediumpInt = context.getShaderPrecisionFormat(context.VERTEX_SHADER, context.MEDIUM_INT);
		Capabilities.vertexShaderLowpInt = context.getShaderPrecisionFormat(context.VERTEX_SHADER, context.LOW_INT);
		Capabilities.fragmentShaderHighpInt = context.getShaderPrecisionFormat(context.FRAGMENT_SHADER, context.HIGH_INT);
		Capabilities.fragmentShaderMediumpInt = context.getShaderPrecisionFormat(context.FRAGMENT_SHADER, context.MEDIUM_INT);
		Capabilities.fragmentShaderLowpInt = context.getShaderPrecisionFormat(context.FRAGMENT_SHADER, context.LOW_INT);
	};

	/**
	 * Gets a string representation of the current capabilities
	 * @returns {string} string representation of capabilities
	 */
	Capabilities.getCapabilitiesString = function () {
		var caps = [];
		var isArrayBufferView = function (value) {
			return value && value.buffer instanceof ArrayBuffer && value.byteLength !== undefined;
		};
		for (var name in Capabilities) {
			var cap = Capabilities[name];
			if (cap instanceof Function || (typeof cap === 'object' && !(cap instanceof Array || isArrayBufferView(cap)))) {
				continue;
			}
			var str = '';
			if (isArrayBufferView(cap)) {
				str += '[';
				for (var i = 0; i < cap.length; i++) {
					str += cap[i];
					if (i < cap.length - 1) {
						str += ',';
					}
				}
				str += ']';
			} else {
				str = cap;
			}
			caps.push(name + ': ' + str);
		}
		return caps.join('\n');
	};

	return Capabilities;
})();
goo.BufferUtils = (function (
	Capabilities
) {
	'use strict';

	/**
	 * Utility for creating index buffers of appropriate type
	 */
	function BufferUtils() {}

	/**
	 * Creates an index buffer of a type appropriate to store the supplied number of vertices
	 * @param {number} indexCount Number of indices
	 * @param {number} vertexCount Number of vertices
	 * @returns {TypedArray} Index buffer
	 */
	BufferUtils.createIndexBuffer = function (indexCount, vertexCount) {
		var indices;
		if (vertexCount <= 256) { // 2^8
			if (BufferUtils.browserType === 'Trident') { // IE 11 case
				indices = new Uint16Array(indexCount);
			} else {
				indices = new Uint8Array(indexCount);
			}
		} else if (vertexCount <= 65536) { // 2^16
			indices = new Uint16Array(indexCount);
		} else if (Capabilities.ElementIndexUInt) { // 2^32
			indices = new Uint32Array(indexCount);
		} else {
			throw new Error('Maximum number of vertices is 65536. Got: ' + vertexCount);
		}
		return indices;
	};

	function storeBrowserType() {
		var aKeys = ['Trident', 'MSIE', 'Firefox', 'Safari', 'Chrome', 'Opera'],
			sUsrAg = navigator.userAgent,
			nIdx = aKeys.length - 1;
		for (nIdx; nIdx > -1 && sUsrAg.indexOf(aKeys[nIdx]) === -1; nIdx--) {
			// nothing
		}
		BufferUtils.browserType = aKeys[nIdx];
	}

	storeBrowserType();

	/**
	 * Returns a clone of the supplied typed array
	 * @param {TypedArray} source
	 * @returns {TypedArray}
	 */
	BufferUtils.cloneTypedArray = function (source) {
		return new source.constructor(source);
	};

	return BufferUtils;
})(goo.Capabilities);
goo.BufferData = (function (
	BufferUtils
) {
	'use strict';

	/**
	 * The purpose of this class is to hold additional information regarding a typedarray buffer, like vbo 'usage' flags
	 * @param {ArrayBuffer} data Data to wrap
	 * @param {string} target Type of data ('ArrayBuffer'/'ElementArrayBuffer')
	 * @property {ArrayBuffer} data Data to wrap
	 * @property {string} target Type of data ('ArrayBuffer'/'ElementArrayBuffer')
	 */
	function BufferData(data, target) {
		this.data = data;
		this.target = target;

		this.glBuffer = null;

		this._dataUsage = 'StaticDraw';
		this._dataNeedsRefresh = false;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	/**
	 * Set the usage type of this bufferdata.
	 * @param {string} dataUsage Usage Type
	 * <pre>
	 * Usage Type:
	 *  	'StaticDraw' - The data store contents will be specied once by the application,
	 *	  		and used many times as the source for GL drawing commands
	 *   	'DynamicDraw' - The data store contents will be respecied repeatedly by the application, and used many times as the source for GL drawing commands.
	 *    	'StreamDraw' - The data store contents will be specied once by the application,
	 *	    	and used at most a few times as the source of a GL drawing command
	 * </pre>
	 */
	BufferData.prototype.setDataUsage = function (dataUsage) {
		this._dataUsage = dataUsage;
	};

	/**
	 * Tell the engine that a buffer has been updated and needs to be refreshed.
	 */
	BufferData.prototype.setDataNeedsRefresh = function () {
		this._dataNeedsRefresh = true;
	};

	/**
	 * Releases the allocated buffer
	 * @param {WebGLRenderingContext} context
	 */
	BufferData.prototype.destroy = function (context) {
		context.deleteBuffer(this.glBuffer);
		this.glBuffer = null;
	};

	BufferData.prototype.copy = function (source) {
		if (this.data instanceof ArrayBuffer) {
			var sourceView = new Uint8Array(source.data);
			var destinationView = new Uint8Array(this.data);
			destinationView.set(sourceView);
		} else { // TypedArray
			this.data.set(source.data);
		}
		this.target = source.target;

		this.glBuffer = null;

		this._dataUsage = source._dataUsage;
		this._dataNeedsRefresh = false; //?

		return this;
	};

	BufferData.prototype.clone = function () {
		var clonedData;
		if (this.data instanceof ArrayBuffer) {
			clonedData = this.data.slice(0);
		} else { // TypedArray
			clonedData = BufferUtils.cloneTypedArray(this.data);
		}

		var clone = new BufferData(clonedData, this.target);
		clone._dataUsage = this._dataUsage;
		clone._dataNeedsRefresh = false; //?
		return clone;
	};

	return BufferData;
})(goo.BufferUtils);
goo.RendererUtils = (function (
	ObjectUtils,
	Capabilities,
	MathUtils
) {
	'use strict';

	/**
	 * Renderer-related utilities
	 */
	function RendererUtils() {}

	/**
	 * Get size in bytes of a specific type.
	 *
	 * @param {string} type Type to retrieve bytesize for
	 */
	RendererUtils.getByteSize = function (type) {
		var byteSize;

		switch (type) {
			case 'Byte':
			case 'UnsignedByte':
				byteSize = 1;
				break;
			case 'Short':
			case 'UnsignedShort':
			case 'HalfFloat':
				byteSize = 2;
				break;
			case 'Int':
			case 'Float':
				byteSize = 4;
				break;
			case 'Double':
				byteSize = 8;
				break;

			default:
				throw new Error('Unknown type: ' + type);
		}

		return byteSize;
	};

	/**
	 * Check if the webgl context contains any errors in the current state
	 *
	 * @param {WebGLRenderingContext} gl A valid WebGL context
	 */
	RendererUtils.checkGLError = function (gl) {
		var error = gl.getError();
		var wasError = false;
		while (error !== gl.NO_ERROR) {
			wasError = true;
			if (error === gl.INVALID_ENUM) {
				console
					.error('An unacceptable value is specified for an enumerated argument. The offending command is ignored and has no other side effect than to set the error flag.');
			} else if (error === gl.INVALID_VALUE) {
				console
					.error('A numeric argument is out of range. The offending command is ignored and has no other side effect than to set the error flag.');
			} else if (error === gl.INVALID_OPERATION) {
				console
					.error('The specified operation is not allowed in the current state. The offending command is ignored and has no other side effect than to set the error flag.');
			} else if (error === gl.FRAMEBUFFER_COMPLETE) {
				console
					.error('The command is trying to render to or read from the framebuffer while the currently bound framebuffer is not framebuffer complete (i.e. the return value from glCheckFramebufferStatus is not GL_FRAMEBUFFER_COMPLETE). The offending command is ignored and has no other side effect than to set the error flag.');
			} else if (error === gl.OUT_OF_MEMORY) {
				throw new Error('There is not enough memory left to execute the command. The state of the GL is undefined, except for the state of the error flags, after this error is recorded.');
			}
			error = gl.getError();
		}

		if (wasError) {
			throw new Error('Stopping due to error');
		}
	};

	/**
	 * Checks if a value is power of two
	 * @deprecated Deprecated as of v0.14.x and scheduled for removal in v0.16.0; Consider using
	 * MathUtils.isPowerOfTwo instead
	 * @param {number} value Number to check for power of two
	 * @returns true if value is power of two
	 */
	RendererUtils.isPowerOfTwo = MathUtils.isPowerOfTwo;

	/**
	 * Converts input number to closest power of two
	 * @deprecated Deprecated as of v0.14.x and scheduled for removal in v0.16.0; Consider using
	 * MathUtils.nearestPowerOfTwo instead
	 * @param {number} number Number to convert to power of two
	 * @returns {number} Nearest power of two of input
	 */
	RendererUtils.nearestPowerOfTwo = MathUtils.nearestPowerOfTwo;

	/**
	 * Clones an object recursively
	 * @deprecated Deprecated as of 0.12.x and scheduled for removal in 0.14.0; Please use `ObjectUtils.deepClone` instead
	 * @param {*} object Object to clone
	 * @returns {*} Cloned object
	 */
	RendererUtils.clone = ObjectUtils.deepClone;

	RendererUtils._blankImages = {};
	RendererUtils.getBlankImage = function (texture, color, width, height, maxSize, index) {
		var newWidth = MathUtils.nearestPowerOfTwo(width);
		var newHeight = MathUtils.nearestPowerOfTwo(height);
		newWidth = Math.min(newWidth, maxSize);
		newHeight = Math.min(newHeight, maxSize);

		var strColor = color.length === 4 ? 'rgba(' + Number(color[0] * 255).toFixed(0) + ',' + Number(color[1] * 255).toFixed(0) + ',' + Number(color[2] * 255).toFixed(0) + ',' + Number(color[3]).toFixed(2) + ')' : 'rgb(' + Number(color[0] * 255).toFixed(0) + ',' + Number(color[1] * 255).toFixed(0) + ',' + Number(color[2] * 255).toFixed(0) + ')';
		var cacheKey = strColor + newWidth + 'x' + newHeight;
		var canvas = RendererUtils._blankImages[cacheKey];
		if (!canvas) {
			canvas = document.createElement('canvas');
			canvas.width = newWidth;
			canvas.height = newHeight;
			var ctx = canvas.getContext('2d');
			ctx.beginPath();
			ctx.rect(0, 0, newWidth, newHeight);
			ctx.fillStyle = strColor;
			ctx.fill();
			RendererUtils._blankImages[cacheKey] = canvas;
		}
		if (index === undefined) {
			texture.image = canvas;
		} else {
			texture.image.isData = false;
			texture.image.data[index] = canvas;
		}
	};

	function getImage(data, width, height) {
		var canvas = document.createElement('canvas');
		canvas.width = width;
		canvas.height = height;

		var context = canvas.getContext('2d');

		var imageData = context.createImageData(width, height);
		imageData.data.set(data);
		context.putImageData(imageData, 0, 0);

		return canvas;
	}

	RendererUtils.scaleImage = function (texture, image, width, height, maxSize, index) {
		var newWidth = MathUtils.nearestPowerOfTwo(width);
		var newHeight = MathUtils.nearestPowerOfTwo(height);
		newWidth = Math.min(newWidth, maxSize);
		newHeight = Math.min(newHeight, maxSize);

		if (image.width !== newWidth || image.height !== newHeight) {
			var canvas = document.createElement('canvas');
			canvas.width = newWidth;
			canvas.height = newHeight;
			if (image.getAttribute) {
				canvas.setAttribute('data-ref', image.getAttribute('data-ref'));
			}
			var ctx = canvas.getContext('2d');

			if (image.data) {
				// putImageData directly on this canvas will not resize
				// have to putImageData on another canvas and drawImage that afterwards
				ctx.drawImage(getImage(image.data, image.width, image.height), 0, 0, image.width, image.height, 0, 0, newWidth, newHeight);
			} else {
				//! AT: this will choke if fed with a manually created texture ([0, 0, 0, 255, ...])
				ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight);
			}
			//document.body.appendChild(canvas);
			canvas.dataReady = true;
			canvas.src = image.src;
			canvas.originalWidth = width;
			canvas.originalHeight = height;
			if (index === undefined) {
				texture.image = canvas;
			} else {
				texture.image.data[index] = canvas;
			}
			//canvas.parentNode.removeChild(canvas);
		}
	};

	RendererUtils.getGLType = function (context, type) {
		var glType;

		switch (type) {
			case '2D':
				glType = context.TEXTURE_2D;
				break;
			case 'CUBE':
				glType = context.TEXTURE_CUBE_MAP;
				break;

			default:
				throw new Error('Invalid texture type: ' + type);
		}

		return glType;
	};

	RendererUtils.getGLWrap = function (context, wrap) {
		var glWrap;

		switch (wrap) {
			case 'Repeat':
				glWrap = context.REPEAT;
				break;
			case 'MirroredRepeat':
				glWrap = context.MIRRORED_REPEAT;
				break;
			case 'EdgeClamp':
				glWrap = context.CLAMP_TO_EDGE;
				break;

			default:
				throw new Error('Invalid WrapMode type: ' + wrap);
		}

		return glWrap;
	};

	RendererUtils.getGLInternalFormat = function (context, format) {
		var glInternalFormat;

		switch (format) {
			case 'RGBA':
				glInternalFormat = context.RGBA;
				break;
			case 'RGB':
				glInternalFormat = context.RGB;
				break;
			case 'Alpha':
				glInternalFormat = context.ALPHA;
				break;
			case 'Luminance':
				glInternalFormat = context.LUMINANCE;
				break;
			case 'LuminanceAlpha':
				glInternalFormat = context.LUMINANCE_ALPHA;
				break;

			default:
				throw new Error('Unsupported format: ' + format);
		}

		return glInternalFormat;
	};

	RendererUtils.getGLPixelDataType = function (context, type) {
		return RendererUtils.getGLDataType(context, type);
	};

	RendererUtils.getGLDataType = function (context, type) {
		var glDataType;

		switch (type) {
			case 'Float':
			case 'Double':
				glDataType = context.FLOAT;
				break;
			case 'Byte':
				glDataType = context.BYTE;
				break;
			case 'UnsignedByte':
				glDataType = context.UNSIGNED_BYTE;
				break;
			case 'Short':
				glDataType = context.SHORT;
				break;
			case 'UnsignedShort':
				glDataType = context.UNSIGNED_SHORT;
				break;
			case 'Int':
				glDataType = context.INT;
				break;
			case 'UnsignedInt':
				glDataType = context.UNSIGNED_INT;
				break;
			case 'UnsignedShort565':
				glDataType = context.UNSIGNED_SHORT_5_6_5;
				break;
			case 'UnsignedShort4444':
				glDataType = context.UNSIGNED_SHORT_4_4_4_4;
				break;
			case 'UnsignedShort5551':
				glDataType = context.UNSIGNED_SHORT_5_5_5_1;
				break;
			case 'HalfFloat':
				glDataType = Capabilities.TextureHalfFloat.HALF_FLOAT_OES;
				break;

			default:
				throw new Error('Unknown datatype: ' + type);
		}

		return glDataType;
	};

	RendererUtils.getFilterFallback = function (filter) {
		var filterFallback;

		switch (filter) {
			case 'NearestNeighborNoMipMaps':
			case 'NearestNeighborNearestMipMap':
			case 'NearestNeighborLinearMipMap':
				filterFallback = 'NearestNeighborNoMipMaps';
				break;
			case 'BilinearNoMipMaps':
			case 'Trilinear':
			case 'BilinearNearestMipMap':
				filterFallback = 'BilinearNoMipMaps';
				break;

			default:
				filterFallback = 'NearestNeighborNoMipMaps';
				break;
		}

		return filterFallback;
	};

	RendererUtils.getGLMagFilter = function (context, filter) {
		var glMagFilter;

		switch (filter) {
			case 'Bilinear':
				glMagFilter = context.LINEAR;
				break;
			case 'NearestNeighbor':
				glMagFilter = context.NEAREST;
				break;

			default:
				throw new Error('Invalid MagnificationFilter type: ' + filter);
		}

		return glMagFilter;
	};

	RendererUtils.getGLMinFilter = function (context, filter) {
		var glMinFilter;

		switch (filter) {
			case 'BilinearNoMipMaps':
				glMinFilter = context.LINEAR;
				break;
			case 'Trilinear':
				glMinFilter = context.LINEAR_MIPMAP_LINEAR;
				break;
			case 'BilinearNearestMipMap':
				glMinFilter = context.LINEAR_MIPMAP_NEAREST;
				break;
			case 'NearestNeighborNoMipMaps':
				glMinFilter = context.NEAREST;
				break;
			case 'NearestNeighborNearestMipMap':
				glMinFilter = context.NEAREST_MIPMAP_NEAREST;
				break;
			case 'NearestNeighborLinearMipMap':
				glMinFilter = context.NEAREST_MIPMAP_LINEAR;
				break;

			default:
				throw new Error('Invalid MinificationFilter type: ' + filter);
		}

		return glMinFilter;
	};

	RendererUtils.getGLBufferTarget = function (context, target) {
		if (target === 'ElementArrayBuffer') {
			return context.ELEMENT_ARRAY_BUFFER;
		}

		return context.ARRAY_BUFFER;
	};

	RendererUtils.getGLArrayType = function (context, indices) {
		var glArrayType = null;

		if (indices instanceof Uint8Array) {
			glArrayType = context.UNSIGNED_BYTE;
		} else if (indices instanceof Uint16Array) {
			glArrayType = context.UNSIGNED_SHORT;
		} else if (indices instanceof Uint32Array) {
			glArrayType = context.UNSIGNED_INT;
		} else if (indices instanceof Int8Array) {
			glArrayType = context.UNSIGNED_BYTE;
		} else if (indices instanceof Int16Array) {
			glArrayType = context.UNSIGNED_SHORT;
		} else if (indices instanceof Int32Array) {
			glArrayType = context.UNSIGNED_INT;
		}

		return glArrayType;
	};

	RendererUtils.getGLByteSize = function (indices) {
		return indices.BYTES_PER_ELEMENT || 1;
	};

	RendererUtils.getGLCubeMapFace = function (context, face) {
		var glCubeMapFace;

		switch (face) {
			case 'PositiveX':
				glCubeMapFace = context.TEXTURE_CUBE_MAP_POSITIVE_X;
				break;
			case 'NegativeX':
				glCubeMapFace = context.TEXTURE_CUBE_MAP_NEGATIVE_X;
				break;
			case 'PositiveY':
				glCubeMapFace = context.TEXTURE_CUBE_MAP_POSITIVE_Y;
				break;
			case 'NegativeY':
				glCubeMapFace = context.TEXTURE_CUBE_MAP_NEGATIVE_Y;
				break;
			case 'PositiveZ':
				glCubeMapFace = context.TEXTURE_CUBE_MAP_POSITIVE_Z;
				break;
			case 'NegativeZ':
				glCubeMapFace = context.TEXTURE_CUBE_MAP_NEGATIVE_Z;
				break;

			default:
				throw new Error('Invalid cubemap face: ' + face);
		}

		return glCubeMapFace;
	};

	RendererUtils.getGLBufferUsage = function (context, usage) {
		var glMode;

		switch (usage) {
			case 'StaticDraw':
				glMode = context.STATIC_DRAW;
				break;
			case 'DynamicDraw':
				glMode = context.DYNAMIC_DRAW;
				break;
			case 'StreamDraw':
				glMode = context.STREAM_DRAW;
				break;

			default:
				glMode = context.STATIC_DRAW;
				break;
		}

		return glMode;
	};

	RendererUtils.getGLIndexMode = function (context, indexMode) {
		var glMode;

		switch (indexMode) {
			case 'Triangles':
				glMode = context.TRIANGLES;
				break;
			case 'TriangleStrip':
				glMode = context.TRIANGLE_STRIP;
				break;
			case 'TriangleFan':
				glMode = context.TRIANGLE_FAN;
				break;
			case 'Lines':
				glMode = context.LINES;
				break;
			case 'LineStrip':
				glMode = context.LINE_STRIP;
				break;
			case 'LineLoop':
				glMode = context.LINE_LOOP;
				break;
			case 'Points':
				glMode = context.POINTS;
				break;

			default:
				glMode = context.TRIANGLES;
				break;
		}

		return glMode;
	};

	RendererUtils.getGLBlendParam = function (context, param) {
		var glBlendParam;

		switch (param) {
			case 'AddEquation':
				glBlendParam = context.FUNC_ADD;
				break;
			case 'SubtractEquation':
				glBlendParam = context.FUNC_SUBTRACT;
				break;
			case 'ReverseSubtractEquation':
				glBlendParam = context.FUNC_REVERSE_SUBTRACT;
				break;

			case 'ZeroFactor':
				glBlendParam = context.ZERO;
				break;
			case 'OneFactor':
				glBlendParam = context.ONE;
				break;
			case 'SrcColorFactor':
				glBlendParam = context.SRC_COLOR;
				break;
			case 'OneMinusSrcColorFactor':
				glBlendParam = context.ONE_MINUS_SRC_COLOR;
				break;
			case 'SrcAlphaFactor':
				glBlendParam = context.SRC_ALPHA;
				break;
			case 'OneMinusSrcAlphaFactor':
				glBlendParam = context.ONE_MINUS_SRC_ALPHA;
				break;
			case 'DstAlphaFactor':
				glBlendParam = context.DST_ALPHA;
				break;
			case 'OneMinusDstAlphaFactor':
				glBlendParam = context.ONE_MINUS_DST_ALPHA;
				break;

			case 'DstColorFactor':
				glBlendParam = context.DST_COLOR;
				break;
			case 'OneMinusDstColorFactor':
				glBlendParam = context.ONE_MINUS_DST_COLOR;
				break;
			case 'SrcAlphaSaturateFactor':
				glBlendParam = context.SRC_ALPHA_SATURATE;
				break;

			default:
				throw new Error('Unknown blend param: ' + param);
		}

		return glBlendParam;
	};

	return RendererUtils;
})(goo.ObjectUtils,goo.Capabilities,goo.MathUtils);
goo.Vector2 = (function (
	ObjectUtils,
	MathUtils,
	Vector,
	Vector3,
	Vector4
) {
	'use strict';

	/**
	 * Vector with 2 components
	 * @extends Vector
	 * @param {number} x
	 * @param {number} y
	 * @example
	 * var v1 = new Vector2(); // v1 == (0, 0)
	 * var v2 = new Vector2(1, 2); // v2 == (1, 2)
	 */
	function Vector2(x, y) {
		// #ifdef DEBUG
		this._x = 0;
		this._y = 0;
		// #endif

		if (arguments.length === 0) {
			// Nothing given
			this.x = 0;
			this.y = 0;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Vector2) {
				// Vector2
				this.copy(arguments[0]);
			} else {
				// Array
				this.x = arguments[0][0];
				this.y = arguments[0][1];
			}
		} else {
			// Numbers
			this.x = x;
			this.y = y;
		}

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	Vector2.prototype = Object.create(Vector.prototype);
	Vector2.prototype.constructor = Vector2;

	// #ifdef DEBUG
	Vector.setupAliases(Vector2.prototype, [['x'], ['y']]);
	Vector.setupIndices(Vector2.prototype, 2);
	// #endif

	Vector.setupAliases(Vector2.prototype, [['u'], ['v']]);

	/**
	 * Zero-vector (0, 0)
	 * @type {Vector2}
	 */
	Vector2.ZERO = new Vector2(0, 0);

	/**
	 * One-vector (1, 1)
	 * @type {Vector2}
	 */
	Vector2.ONE = new Vector2(1, 1);

	/**
	 * Unit-X (1, 0)
	 * @type {Vector2}
	 */
	Vector2.UNIT_X = new Vector2(1, 0);

	/**
	 * Unit-Y (0, 1)
	 * @type {Vector2}
	 */
	Vector2.UNIT_Y = new Vector2(0, 1);

	/**
	 * Returns the vector component associated with the given index.
	 * Vector components are numbered from 0 to 2 in this order: x, y.
	 * @param {number} index
	 * @returns {number}
	 */
	Vector2.prototype.getComponent = function (index) {
		switch (index) {
			case 0: return this.x;
			case 1: return this.y;
		}
	};

	/**
	 * Sets the vector component associated with the given index to a given value.
	 * Vector components are numbered from 0 to 2 in this order: x, y.
	 * @param {number} index
	 * @param {number} value
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.setComponent = function (index, value) {
		switch (index) {
			case 0: this.x = value; break;
			case 1: this.y = value; break;
		}
		return this;
	};

	/**
	 * Adds a vector to the current vector
	 * @param {Vector2} rhs
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v1 = new Vector2(1, 2);
	 * var v2 = new Vector2(4, 5);
	 * v1.add(v2); // v1 == (5, 7)
	 */
	Vector2.prototype.add = function (rhs) {
		this.x += rhs.x;
		this.y += rhs.y;

		return this;
	};

	/**
	 * Adds numbers 'x', 'y' to the current Vector2 values
	 * @param {number} x
	 * @param {number} y
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(1, 2);
	 * v.addDirect(2, 4); // v == (3, 6)
	 */
	Vector2.prototype.addDirect = function (x, y) {
		this.x += x;
		this.y += y;

		return this;
	};

	/**
	 * Adds a vector from the current vector
	 * @param {Vector2} rhs
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v1 = new Vector2(4, 5);
	 * var v2 = new Vector2(1, 2);
	 * v1.sub(v2); // v1 == (3, 3)
	 */
	Vector2.prototype.sub = function (rhs) {
		this.x -= rhs.x;
		this.y -= rhs.y;

		return this;
	};

	/**
	 * Subtracts numbers 'x', 'y' from the current Vector2
	 * @param {number} x
	 * @param {number} y
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(); // v == (0, 0)
	 * v.subDirect(1, 2); // v == (-1, -2)
	 */
	Vector2.prototype.subDirect = function (x, y) {
		this.x -= x;
		this.y -= y;

		return this;
	};

	/**
	 * Performs component-wise negation of the vector
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.negate = function () {
		this.x = -this.x;
		this.y = -this.y;

		return this;
	};

	/**
	 * Multiplies the current vector by another vector
	 * @param {Vector2} rhs
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v1 = new Vector2(4, 5);
	 * var v2 = new Vector2(1, 2);
	 * v1.mul(v2); // v1 == (4, 10)
	 */
	Vector2.prototype.mul = function (rhs) {
		this.x *= rhs.x;
		this.y *= rhs.y;

		return this;
	};

	/**
	 * Multiplies the current Vector2 by numbers 'x', 'y' as inputs
	 * @param {number} x
	 * @param {number} y
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(1, 2);
	 * v.mulDirect(2, 4); // v == (2, 8)
	 */
	Vector2.prototype.mulDirect = function (x, y) {
		this.x *= x;
		this.y *= y;

		return this;
	};

	/**
	 * Scales the vector by a factor
	 * @param {number} factor
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.scale = function (factor) {
		this.x *= factor;
		this.y *= factor;

		return this;
	};

	/**
	 * Divides the current Vector2 by another vector
	 * @param {Vector2} rhs
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(4, 16);
	 * v.div(2, 4); // v == (2, 16)
	 */
	Vector2.prototype.div = function (rhs) {
		this.x /= rhs.x;
		this.y /= rhs.y;

		return this;
	};

	/**
	 * Divides the current Vector2 by numbers 'x', 'y' as inputs
	 * @param {number} x
	 * @param {number} y
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(4, 9);
	 * v.divDirect(2, 3); // v == (2, 3)
	 */
	Vector2.prototype.divDirect = function (x, y) {
		this.x /= x;
		this.y /= y;

		return this;
	};

	/**
	 * Computes the dot product between the current vector and another vector
	 * @param {Vector2} rhs
	 * @returns {number}
	 */
	Vector2.prototype.dot = function (rhs) {
		return this.x * rhs.x +
			this.y * rhs.y;
	};

	/**
	 * Computes the dot product between the current vector and another vector given as 2 numeric values
	 * @param {number} x
	 * @param {number} y
	 * @returns {number}
	 */
	Vector2.prototype.dotDirect = function (x, y) {
		return this.x * x +
			this.y * y;
	};

	/**
	 * Returns whether this vector is aproximately equal to a given vector
	 * @param rhs
	 * @returns {boolean}
	 */
	Vector2.prototype.equals = function (rhs) {
		return (Math.abs(this.x - rhs.x) <= MathUtils.EPSILON) &&
			(Math.abs(this.y - rhs.y) <= MathUtils.EPSILON);
	};

	/**
	 * Returns whether this vector is approximately equal to a given vector given as 2 numeric values
	 * @param {number} x
	 * @param {number} y
	 * @returns {boolean}
	 */
	Vector2.prototype.equalsDirect = function (x, y) {
		return (Math.abs(this.x - x) <= MathUtils.EPSILON) &&
			(Math.abs(this.y - y) <= MathUtils.EPSILON);
	};

	/**
	 * Linearly interpolates between the current Vector2 and an 'end' Vector2
	 * @param {Vector2} end End Vector2
	 * @param {number} factor Interpolation factor between 0.0 and 1.0
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var from = new Vector2(1, 2);
	 * var to = new Vector2(3, 4);
	 * var midway = from.clone().lerp(to, 0.5); // midway == (2, 3)
	 */
	Vector2.prototype.lerp = function (end, factor) {
		this.x += (end.x - this.x) * factor;
		this.y += (end.y - this.y) * factor;

		return this;
	};

	(function () {
		var tmpVec = new Vector2();

		/**
		 * Reflects a vector relative to the plane obtained from the normal parameter.
		 * @param {Vector2} normal Defines the plane that reflects the vector. Assumed to be of unit length.
		 * @returns {Vector2} Self to allow chaining
		 */
		Vector2.prototype.reflect = function (normal) {
			tmpVec.copy(normal);
			tmpVec.scale(2 * this.dot(normal));
			this.sub(tmpVec);
			return this;
		};
	})();

	/**
	 * Sets the vector's values from another vector's values
	 * @param {Vector2} rhs
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(); // v == (0, 0)
	 * v.set(new Vector2(2, 4)); // v == (2, 4)
	 */
	Vector2.prototype.set = function (rhs) {
		if(rhs instanceof Vector2 || rhs instanceof Vector3 || rhs instanceof Vector4){
			this.x = rhs.x;
			this.y = rhs.y;
		} else {
			this.x = arguments[0];
			this.y = arguments[1];
		}

		return this;
	};

	/**
	 * Sets the vector's values from 2 numeric arguments
	 * @param {number} x
	 * @param {number} y
	 * @returns {Vector2} Self to allow chaining
	 * @example
	 * var v = new Vector2(); // v == (0, 0)
	 * v.setDirect(2, 4); // v == (2, 4)
	 */
	Vector2.prototype.setDirect = function (x, y) {
		this.x = x;
		this.y = y;

		return this;
	};

	/**
	 * Calculates the squared length/magnitude of the current Vector2.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @returns {number} squared length
	 * @example
	 * var v = new Vector2(0, 9);
	 * v.lengthSquared(); // 81
	 */
	Vector2.prototype.lengthSquared = function () {
		return this.x * this.x + this.y * this.y;
	};

	/**
	 * Calculates length squared of vector
	 * @returns {number} length squared
	 */
	Vector2.prototype.length = function () {
		return Math.sqrt(this.lengthSquared());
	};

	/**
	 * Normalizes the current vector
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.normalize = function () {
		var length = this.length();

		if (length < MathUtils.EPSILON) {
			this.x = 0;
			this.y = 0;
		} else {
			this.x /= length;
			this.y /= length;
		}

		return this;
	};

	/**
	 * Normalizes the current vector; this method does not perform special checks for zero length vectors
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.unsafeNormalize = function () {
		var length = this.length();

		this.x /= length;
		this.y /= length;

		return this;
	};

	/**
	 * Computes the squared distance between the current Vector2 and another Vector2.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @param {Vector2} rhs Vector2
	 * @returns {number} distance squared
	 * @example
	 * var v1 = new Vector2(); // v1 == (0, 0)
	 * var v2 = new Vector2(0, 9);
	 * v1.distanceSquared(v2); // 81
	 */
	Vector2.prototype.distanceSquared = function (rhs) {
		var deltaX = this.x - rhs.x;
		var deltaY = this.y - rhs.y;

		return deltaX * deltaX + deltaY * deltaY;
	};

	/**
	 * Computes the distance between the current Vector2 and another Vector2.
	 * Note: When comparing the relative distances between two points it is usually sufficient
	 * to compare the squared distances, thus avoiding an expensive square root operation.
	 * @param {Vector2} rhs Vector2
	 * @returns {number} distance
	 * @example
	 * var v1 = new Vector2(); // v1 == (0, 0)
	 * var v2 = new Vector2(0, 9);
	 * v1.distance(v2); // 9
	 */
	Vector2.prototype.distance = function (rhs) {
		return Math.sqrt(this.distanceSquared(rhs));
	};

	/**
	 * Multiplies this vector with a Matrix2
	 * @param {Matrix2} matrix
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.applyPre = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;

		this.x = source[0] * x + source[1] * y;
		this.y = source[2] * x + source[3] * y;

		return this;
	};

	/**
	 * Multiplies a Matrix2 with this vector
	 * @param {Matrix2} matrix
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.applyPost = function (matrix) {
		var source = matrix.data;

		var x = this.x;
		var y = this.y;

		this.x = source[0] * x + source[2] * y;
		this.y = source[1] * x + source[3] * y;

		return this;
	};

	/**
	 * Clones the vector
	 * @returns {Vector2} Clone of self
	 */
	Vector2.prototype.clone = function () {
		return new Vector2(this.x, this.y);
	};

	/**
	 * Copies the values of another vector to this vector; an alias for .setVector
	 * @param {Vector2} Source vector
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.copy = Vector2.prototype.set;

	/**
	 * Copies this vector over another. Not equivalent to `target.copy(this)` when
	 * the target vector has more components than the source vector
	 * @param {Vector} target
	 * @returns {Vector2} Self to allow chaining
	 */
	Vector2.prototype.copyTo = function (target) {
		target.x = this.x;
		target.y = this.y;

		return this;
	};

	/**
	 * Creates a Vector2 given an array
	 * @param {Array<number>} array
	 * @returns {Vector2}
	 */
	Vector2.fromArray = function (array) {
		return new Vector2(array[0], array[1]);
	};

	/**
	 * Creates a Vector2 given 3 numbers, an array, an {x, y} object or another Vector2
	 * @returns {Vector2}
	 */
	Vector2.fromAny = function () {
		if (arguments.length === 2) {
			return Vector2.fromArray(arguments);
		} else if (arguments[0] instanceof Array) {
			return Vector2.fromArray(arguments[0]);
		} else {
			var vectorLike = arguments[0];
			return new Vector2(vectorLike.x, vectorLike.y);
		}
	};

	/**
	 * Sets the vector content from an array of numbers.
	 * @param {Array<number>} array
	 */
	Vector2.prototype.setArray = function (array) {
		this.x = array[0];
		this.y = array[1];

		return this;
	};

	/**
	 * Returns the components of the vector in array form
	 * @returns {Array<number>}
	 */
	Vector2.prototype.toArray = function () {
		return [this.x, this.y];
	};

	// #ifdef DEBUG
	Vector.addReturnChecks(Vector2.prototype, [
		'dot', 'dotDirect',
		'length', 'lengthSquared',
		'distance', 'distanceSquared'
	]);
	// #endif

	// SHIM START
	Object.defineProperty(Vector2.prototype, 'data', {
		get: ObjectUtils.warnOnce('The .data property of Vector2 was removed. Please use the .x and .y properties instead.', function () {
			var data = [];
			var that = this;
			Object.defineProperties(data, {
				'0': {
					get: function () {
						return that.x;
					},
					set: function (value) {
						that.x = value;
					}
				},
				'1': {
					get: function () {
						return that.y;
					},
					set: function (value) {
						that.y = value;
					}
				}
			});
			return data;
		})
	});

	Vector2.prototype.setVector = ObjectUtils.warnOnce('The setVector method of Vector2 was removed. Please use the set method instead.', function (rhs) {
		return this.set(rhs);
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.add = ObjectUtils.warnOnce('Vector2.add is deprecated.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs];
		}

		if (!target) {
			target = new Vector2();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] + rdata[0];
		target.data[1] = ldata[1] + rdata[1];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.sub = ObjectUtils.warnOnce('Vector2.sub is deprecated.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs];
		}

		if (!target) {
			target = new Vector2();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;


		target.data[0] = ldata[0] - rdata[0];
		target.data[1] = ldata[1] - rdata[1];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.mul = ObjectUtils.warnOnce('Vector2.mul is deprecated.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs];
		}

		if (!target) {
			target = new Vector2();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] * rdata[0];
		target.data[1] = ldata[1] * rdata[1];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.div = ObjectUtils.warnOnce('Vector2.div is deprecated.', function (lhs, rhs, target) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs];
		}

		if (!target) {
			target = new Vector2();
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		target.data[0] = ldata[0] / rdata[0];
		target.data[1] = ldata[1] / rdata[1];

		return target;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.dot = ObjectUtils.warnOnce('Vector2.dot is deprecated.', function (lhs, rhs) {
		if (typeof lhs === 'number') {
			lhs = [lhs, lhs];
		}

		if (typeof rhs === 'number') {
			rhs = [rhs, rhs];
		}

		var ldata = lhs.data || lhs;
		var rdata = rhs.data || rhs;

		return ldata[0] * rdata[0] +
			ldata[1] * rdata[1];
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.prototype.dotVector = ObjectUtils.warnOnce('Vector2.prototype.dotVector is deprecated.', function (rhs) {
		var ldata = this.data;
		var rdata = rhs.data;

		return ldata[0] * rdata[0] +
			ldata[1] * rdata[1];
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.prototype.addVector = ObjectUtils.warnOnce('Vector2.prototype.addVector is deprecated.', function (vector) {
		this.data[0] += vector.data[0];
		this.data[1] += vector.data[1];

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.prototype.mulVector = ObjectUtils.warnOnce('Vector2.prototype.mulVector is deprecated.', function (vector) {
		this.data[0] *= vector.data[0];
		this.data[1] *= vector.data[1];

		return this;
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Vector2.prototype.subVector = ObjectUtils.warnOnce('Vector2.prototype.subVector is deprecated.', function (vector) {
		this.data[0] -= vector.data[0];
		this.data[1] -= vector.data[1];

		return this;
	});

	//!schteppe: not shimming Vector2.prototype.seta, it's been warned about forever
	//!schteppe: not shimming Vector2.prototype.setd, it's been warned about forever
	//!schteppe: not shimming Vector2.prototype.setv, it's been warned about forever

	// SHIM END

	return Vector2;
})(goo.ObjectUtils,goo.MathUtils,goo.Vector,goo.Vector3,goo.Vector4);
goo.MeshData = (function (
	BufferData,
	RendererUtils,
	BufferUtils,
	Vector2,
	Vector3,
	Vector4,
	ObjectUtils
) {
	'use strict';

	//! AT: why this?
	var Uint8ClampedArray = window.Uint8ClampedArray;

	/**
	 * Stores all buffers for geometric data and similar attributes
	 * @param {Object} attributeMap Describes which buffers to use and their format/sizes
	 * @param {number} vertexCount Number of vertices in buffer
	 * @param {number} indexCount Number of indices in buffer
	 */
	function MeshData(attributeMap, vertexCount, indexCount) {
		this.attributeMap = attributeMap;

		/** The total number of vertices in the buffer.
		 * @type {number}
		 */
		this.vertexCount = this._vertexCountStore = vertexCount !== undefined ? vertexCount : 0;
		
		/** The total number of indices in the buffer.
		 * @type {number}
		 */
		this.indexCount = indexCount !== undefined ? indexCount : 0;

		this.primitiveCounts = [0];

		this.vertexData = null;
		this.indexData = null;
		this.dataViews = {};

		/** The number of indices used by each segment, or null to indicate only one segment that uses the whole index buffer.
		 * @type {Array<number>|null}
		 */
		this.indexLengths = null;

		/** The primitive rendering types to use, for each segment. Default value of this property is ['Triangles'], but also TriangleStrip, TriangleFan, Lines, LineStrip, LineLoop and Points are available.
		 * @type {Array<string>}
		 */
		this.indexModes = ['Triangles'];

		this.type = MeshData.MESH;

		this.paletteMap = undefined;
		this.weightsPerVertex = undefined;
		this.boundingBox = undefined;
		this.store = undefined;
		this.wireframeData = undefined;
		this.flatMeshData = undefined;
		this.__boundingTree = undefined;

		this._attributeDataNeedsRefresh = false;
		this._dirtyAttributeNames = new Set();

		this.rebuildData(this.vertexCount, this.indexCount);


		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	MeshData.MESH = 0;
	MeshData.SKINMESH = 1;

	/**
	 * Rebuilds the mesh vertex and index data
	 * @param {number} vertexCount
	 * @param {number} indexCount
	 * @param {boolean} saveOldData
	 */
	MeshData.prototype.rebuildData = function (vertexCount, indexCount, saveOldData) {
		var savedAttributes = {};
		var savedIndices = null;

		if (saveOldData) {
			var keys = Object.keys(this.attributeMap);
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				var view = this.dataViews[key];
				if (view) {
					savedAttributes[key] = view;
				}
			}
			if (this.indexData) {
				savedIndices = this.indexData.data;
			}
		}

		this.rebuildVertexData(vertexCount);

		this.rebuildIndexData(indexCount);

		if (saveOldData) {
			var keys = Object.keys(this.attributeMap);
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				var saved = savedAttributes[key];
				if (saved) {
					this.dataViews[key].set(saved);
				}
			}

			if (savedIndices) {
				this.indexData.data.set(savedIndices);
			}
		}
	};

	/**
	 * Rebuilds the vertex data of a mesh
	 * @private
	 * @param {number} vertexCount
	 */
	MeshData.prototype.rebuildVertexData = function (vertexCount) {
		if (!isNaN(vertexCount)) {
			this.vertexCount = vertexCount;
			this._vertexCountStore = this.vertexCount;
		}
		if (this.vertexCount > 0) {
			var vertexByteSize = 0;
			var keys = Object.keys(this.attributeMap);
			for (var i = 0; i < keys.length; i++) {
				var attribute = this.attributeMap[keys[i]];
				vertexByteSize += RendererUtils.getByteSize(attribute.type) * attribute.count;
			}
			this.vertexData = new BufferData(new ArrayBuffer(vertexByteSize * this.vertexCount), 'ArrayBuffer');

			this.generateAttributeData();
		}
	};

	/**
	 * Rebuilds the index data
	 * @private
	 * @param {number} indexCount
	 */
	MeshData.prototype.rebuildIndexData = function (indexCount) {
		if (indexCount !== undefined) {
			this.indexCount = indexCount;
		}
		if (this.indexCount > 0) {
			var indices = BufferUtils.createIndexBuffer(this.indexCount, this.vertexCount);
			this.indexData = new BufferData(indices, 'ElementArrayBuffer');
		} else {
			this.indexData = null;
			this.indexLengths = null;
			this.indexModes = ['Triangles'];
		}
	};

	/**
	 * Requests a refresh on the vertex data
	 */
	MeshData.prototype.setVertexDataUpdated = function () {
		this.vertexData._dataNeedsRefresh = true;
	};

	MeshData.prototype.setAttributeDataUpdated = function (name) {
		this._dirtyAttributeNames.add(name);
		this._attributeDataNeedsRefresh = true;
	};

	MeshData.prototype.getSectionCount = function () {
		return this.indexLengths ? this.indexLengths.length : 1;
	};

	MeshData.prototype.getPrimitiveCount = function (section) {
		if (section >= 0 && section < this.primitiveCounts.length) {
			return this.primitiveCounts[section];
		}
		return 0;
	};

	MeshData.prototype.getPrimitiveVertices = function (primitiveIndex, section, store) {
		var count = this.getPrimitiveCount(section);
		if (primitiveIndex >= count || primitiveIndex < 0) {
			throw new Error("Invalid primitiveIndex '" + primitiveIndex + "'.  Count is " + count);
		}

		var mode = this.indexModes[section];
		var rSize = MeshData.getVertexCount(mode);
		var result = store || [];
		result.length = rSize;

		var verts = this.getAttributeBuffer(MeshData.POSITION);
		for (var i = 0; i < rSize; i++) {
			if (!result[i]) {
				result[i] = new Vector3();
			}
			if (this.getIndexBuffer()) {
				// indexed geometry
				var vert = this.getIndexBuffer()[this.getVertexIndex(primitiveIndex, i, section)];
				result[i].x = verts[vert * 3 + 0];
				result[i].y = verts[vert * 3 + 1];
				result[i].z = verts[vert * 3 + 2];
			} else {
				// non-indexed geometry
				var vert = this.getVertexIndex(primitiveIndex, i, section);
				result[i].x = verts[vert * 3 + 0];
				result[i].y = verts[vert * 3 + 1];
				result[i].z = verts[vert * 3 + 2];
			}
		}

		return result;
	};

	MeshData.prototype.getVertexIndex = function (primitiveIndex, point, section) {
		var index = 0;
		// move our offset up to the beginning of our section
		for (var i = 0; i < section; i++) {
			index += this.indexLengths[i];
		}

		// Ok, now pull primitive index based on indexmode.
		switch (this.indexModes[section]) {
			case 'Triangles':
				index += primitiveIndex * 3 + point;
				break;
			case 'TriangleStrip':
				// XXX: Do we need to flip point 0 and 1 on odd primitiveIndex values?
				// if (point < 2 && primitiveIndex % 2 == 1) {
				// index += primitiveIndex + (point == 0 ? 1 : 0);
				// } else {
				index += primitiveIndex + point;
				// }
				break;
			case 'TriangleFan':
				if (point === 0) {
					index += 0;
				} else {
					index += primitiveIndex + point;
				}
				break;
			case 'Points':
				index += primitiveIndex;
				break;
			case 'Lines':
				index += primitiveIndex * 2 + point;
				break;
			case 'LineStrip':
			case 'LineLoop':
				index += primitiveIndex + point;
				break;
			default:
				MeshData.logger.warning('unimplemented index mode: ' + this.indexModes[section]);
				return -1;
		}

		return index;
	};

	//! AT: unused
	MeshData.prototype.getTotalPrimitiveCount = function () {
		var count = 0;
		for (var i = 0, max = this.primitiveCounts.length; i < max; i++) {
			count += this.primitiveCounts[i];
		}
		return count;
	};

	MeshData.prototype.updatePrimitiveCounts = function () {
		var maxIndex = this.indexData ? this.indexData.data.length : this.vertexCount;
		var maxSection = this.getSectionCount();
		if (this.primitiveCounts.length !== maxSection) {
			this.primitiveCounts = [];
		}
		for (var i = 0; i < maxSection; i++) {
			var size = this.indexLengths ? this.indexLengths[i] : maxIndex;
			var count = MeshData.getPrimitiveCount(this.indexModes[i], size);
			this.primitiveCounts[i] = count;
		}
	};

	MeshData.getPrimitiveCount = function (indexMode, size) {
		switch (indexMode) {
			case 'Triangles':
				return size / 3;
			case 'TriangleFan':
			case 'TriangleStrip':
				return size - 2;
			case 'Lines':
				return size / 2;
			case 'LineStrip':
				return size - 1;
			case 'LineLoop':
				return size;
			case 'Points':
				return size;
			default:
				throw new Error('unimplemented index mode: ' + indexMode);
		}
	};

	MeshData.getVertexCount = function (indexMode) {
		switch (indexMode) {
			case 'Triangles':
			case 'TriangleFan':
			case 'TriangleStrip':
				return 3;
			case 'Lines':
			case 'LineStrip':
			case 'LineLoop':
				return 2;
			case 'Points':
				return 1;
			default:
				throw new Error('unimplemented index mode: ' + indexMode);
		}
	};

	var ArrayTypes = {
		Byte: Int8Array,
		UnsignedByte: Uint8Array,
		UnsignedByteClamped: Uint8ClampedArray,
		Short: Int16Array,
		UnsignedShort: Uint16Array,
		Int: Int32Array,
		UnsignedInt: Uint32Array,
		Float: Float32Array
		// Double: Float64Array
	};

	MeshData.prototype.generateAttributeData = function () {
		var data = this.vertexData.data;
		var view;
		var offset = 0;
		for (var key in this.attributeMap) {
			var attribute = this.attributeMap[key];
			attribute.offset = offset;
			var length = this.vertexCount * attribute.count;
			offset += length * RendererUtils.getByteSize(attribute.type);

			var ArrayType = ArrayTypes[attribute.type];
			if (ArrayType) {
				view = new ArrayType(data, attribute.offset, length);
			} else {
				throw new Error('Unsupported DataType: ' + attribute.type);
			}

			this.dataViews[key] = view;

			attribute.hashKey = attribute.count + '_' + attribute.type + '_' +
				attribute.stride + '_' + attribute.offset + '_' + attribute.normalized;
		}
	};

	MeshData.prototype.deIndex = function () {
		var origI = this.getIndexBuffer();
		if (!origI) {
			return;
		}

		var data = {};
		var keys = Object.keys(this.attributeMap);
		for (var ii = 0, l = keys.length; ii < l; ii++) {
			var key = keys[ii];
			var map = this.attributeMap[key];
			var view = this.getAttributeBuffer(key);

			var array = data[key] = [];
			for (var i = 0; i < origI.length; i++) {
				var index = origI[i];
				for (var j = 0; j < map.count; j++) {
					array[i * map.count + j] = view[index * map.count + j];
				}
			}
		}

		this.rebuildData(this.indexCount, 0);

		for (var ii = 0, l = keys.length; ii < l; ii++) {
			var key = keys[ii];
			var view = this.getAttributeBuffer(key);
			view.set(data[key]);
		}

		this.setVertexDataUpdated();
	};

	//! AT: unused
	MeshData.prototype.makeInterleavedData = function () {
		var stride = 0;
		var offset = 0; // unused
		for (var key in this.attributeMap) {
			var attribute = this.attributeMap[key];
			attribute.offset = stride;
			stride += attribute.count * RendererUtils.getByteSize(attribute.type);
		}

		var newVertexData = new BufferData(new ArrayBuffer(stride * this.vertexCount), this.vertexData.target);
		newVertexData._dataUsage = this.vertexData._dataUsage;
		newVertexData._dataNeedsRefresh = true;

		var targetView = new DataView(newVertexData.data);
		for (var key in this.attributeMap) {
			var view = this.dataViews[key];
			var attribute = this.attributeMap[key];
			attribute.stride = stride;
			var offset = attribute.offset;
			var count = attribute.count;
			var size = RendererUtils.getByteSize(attribute.type);

			var method = this.getDataMethod(attribute.type);
			var fun = targetView[method];
			for (var i = 0; i < this.vertexCount; i++) {
				for (var j = 0; j < count; j++) {
					fun.apply(targetView, [(offset + stride * i + j * size), view[i * count + j], true]);
				}
			}
		}

		this.vertexData = newVertexData;
	};

	MeshData.prototype.getDataMethod = function (type) {
		switch (type) {
		case 'Byte':
			return 'setInt8';
		case 'UnsignedByte':
			return 'setUInt8';
		case 'Short':
			return 'setInt16';
		case 'UnsignedShort':
			return 'setUInt16';
		case 'Int':
			return 'setInt32';
		case 'HalfFloat':
			return 'setInt16';
		case 'Float':
			return 'setFloat32';
		// case 'Double':
			// return 'setFloat64';
		}
	};

	MeshData.prototype.getAttributeBuffer = function (attributeName) {
		return this.dataViews[attributeName];
	};

	//! schteppe: are simple getters like this really needed? Why not just use the property?
	MeshData.prototype.getIndexData = function () {
		return this.indexData;
	};

	MeshData.prototype.getIndexBuffer = function () {
		if (this.indexData !== null) {
			return this.indexData.data;
		}
		return null;
	};

	MeshData.prototype.getIndexLengths = function () {
		return this.indexLengths;
	};

	MeshData.prototype.getIndexModes = function () {
		return this.indexModes;
	};

	//! AT: unused and undocumented; remove?
	MeshData.prototype.resetVertexCount = function () {
		this.vertexCount = this._vertexCountStore;
	};

	/**
	 * Applies a transformation on a specified attribute buffer
	 * @param {string} attributeName
	 * @param {Transform} transform
	 * @returns {MeshData} Self to allow chaining
	 */
	MeshData.prototype.applyTransform = function (attributeName, transform) {
		var vert = new Vector3();
		var view = this.getAttributeBuffer(attributeName);
		var viewLength = view.length;

		if (attributeName === MeshData.POSITION) {
			for (var i = 0; i < viewLength; i += 3) {
				vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);
				vert.applyPostPoint(transform.matrix);
				view[i + 0] = vert.x;
				view[i + 1] = vert.y;
				view[i + 2] = vert.z;
			}
		} else if (attributeName === MeshData.NORMAL) {
			for (var i = 0; i < viewLength; i += 3) {
				vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);
				vert.applyPost(transform.rotation);
				view[i + 0] = vert.x;
				view[i + 1] = vert.y;
				view[i + 2] = vert.z;
			}
		} else if (attributeName === MeshData.TANGENT) {
			for (var i = 0; i < viewLength; i += 3) {
				vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);
				vert.applyPost(transform.rotation);
				view[i + 0] = vert.x;
				view[i + 1] = vert.y;
				view[i + 2] = vert.z;
			}
		}

		return this;
	};

	/**
	 * Applies a function on the vertices of a specified attribute buffer
	 * @param {string} attributeName
	 * @param {Function} fun
	 * @returns {MeshData} Self to allow chaining
	 */
	MeshData.prototype.applyFunction = function (attributeName, fun) {
		//! AT: fun should return a vector3, not an array
		var vert;
		var outVert;
		var view = this.getAttributeBuffer(attributeName);
		var viewLength = view.length;

		var count = this.attributeMap[attributeName].count;

		switch (count) {
		case 1:
			for (var i = 0; i < viewLength; i++) {
				view[i] = fun(view[i]);
			}
			break;
		case 2:
			vert = new Vector2();
			for (var i = 0; i < viewLength; i += 2) {
				vert.setDirect(view[i + 0], view[i + 1]);

				outVert = fun(vert);

				view[i + 0] = outVert.x;
				view[i + 1] = outVert.y;
			}
			break;
		case 3:
			vert = new Vector3();
			for (var i = 0; i < viewLength; i += 3) {
				vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);

				outVert = fun(vert);

				view[i + 0] = outVert.x;
				view[i + 1] = outVert.y;
				view[i + 2] = outVert.z;
			}
			break;
		case 4:
			vert = new Vector4();
			for (var i = 0; i < viewLength; i += 4) {
				vert.setDirect(view[i + 0], view[i + 1], view[i + 2], view[i + 3]);

				outVert = fun(vert);

				view[i + 0] = outVert.x;
				view[i + 1] = outVert.y;
				view[i + 2] = outVert.z;
				view[i + 3] = outVert.w;
			}
			break;
		}

		return this;
	};

	/**
	 * Creates a new MeshData object representing the normals of the current MeshData object
	 * @param {number} [size=1] The size of the normals
	 * @returns {MeshData}
	 */
	MeshData.prototype.getNormalsMeshData = function (size) {
		if (this.getAttributeBuffer('POSITION') === undefined) {
			return;
		}
		if (this.getAttributeBuffer('NORMAL') === undefined) {
			return;
		}

		size = size !== undefined ? size : 1;

		var verts = [];
		var indices = [];

		var nVertices = this.dataViews.POSITION.length / 3;
		for (var i = 0; i < nVertices; i++) {
			verts.push(
				this.dataViews.POSITION[i * 3 + 0],
				this.dataViews.POSITION[i * 3 + 1],
				this.dataViews.POSITION[i * 3 + 2],
				this.dataViews.POSITION[i * 3 + 0] + this.dataViews.NORMAL[i * 3 + 0] * size,
				this.dataViews.POSITION[i * 3 + 1] + this.dataViews.NORMAL[i * 3 + 1] * size,
				this.dataViews.POSITION[i * 3 + 2] + this.dataViews.NORMAL[i * 3 + 2] * size);
		}

		for (var i = 0; i < nVertices * 2; i += 2) {
			indices.push(i, i + 1);
		}

		var meshData = new MeshData(MeshData.defaultMap([MeshData.POSITION]), verts.length, indices.length);

		meshData.getAttributeBuffer(MeshData.POSITION).set(verts);
		meshData.getIndexBuffer().set(indices);

		meshData.indexModes[0] = 'Lines';

		return meshData;
	};

	/**
	 * Builds the wireframe MeshData from an existing mesh
	 * @returns {MeshData}
	 */
	MeshData.prototype.buildWireframeData = function () {
		var attributeMap = ObjectUtils.deepClone(this.attributeMap);
		var wireframeData = new MeshData(attributeMap, this.vertexCount, 0);
		wireframeData.indexModes[0] = 'Lines';

		var origI = this.getIndexBuffer();

		var that = this;
		var getIndex;
		if (origI) {
			getIndex = function (primitiveIndex, point, section) {
				return origI[that.getVertexIndex(primitiveIndex, point, section)];
			};
		} else {
			getIndex = function (primitiveIndex, point, section) {
				return that.getVertexIndex(primitiveIndex, point, section);
			};
		}

		var targetI = [];
		var indexCount = 0;
		this.updatePrimitiveCounts();
		for (var section = 0; section < this.getSectionCount(); section++) {
			var indexMode = this.indexModes[section];

			var primitiveCount = this.getPrimitiveCount(section);
			for (var primitiveIndex = 0; primitiveIndex < primitiveCount; primitiveIndex++) {
				switch (indexMode) {
				case 'Triangles':
				case 'TriangleFan':
				case 'TriangleStrip':
					var i1 = getIndex(primitiveIndex, 0, section);
					var i2 = getIndex(primitiveIndex, 1, section);
					var i3 = getIndex(primitiveIndex, 2, section);

					targetI[indexCount + 0] = i1;
					targetI[indexCount + 1] = i2;
					targetI[indexCount + 2] = i2;
					targetI[indexCount + 3] = i3;
					targetI[indexCount + 4] = i3;
					targetI[indexCount + 5] = i1;
					indexCount += 6;
					break;
				case 'Lines':
				case 'LineStrip':
					var i1 = getIndex(primitiveIndex, 0, section);
					var i2 = getIndex(primitiveIndex, 1, section);

					targetI[indexCount + 0] = i1;
					targetI[indexCount + 1] = i2;
					indexCount += 2;
					break;
				case 'LineLoop':
					var i1 = getIndex(primitiveIndex, 0, section);
					var i2 = getIndex(primitiveIndex, 1, section);
					if (primitiveIndex === primitiveCount - 1) {
						i2 = getIndex(0, 0, section);
					}

					targetI[indexCount + 0] = i1;
					targetI[indexCount + 1] = i2;
					indexCount += 2;
					break;
				case 'Points':
					// Not supported in wireframe
					break;
				}
			}
		}

		if (indexCount > 0) {
			wireframeData.rebuildIndexData(indexCount);
			for (var attribute in attributeMap) {
				wireframeData.getAttributeBuffer(attribute).set(this.getAttributeBuffer(attribute));
			}
			wireframeData.getIndexBuffer().set(targetI);
		}

		wireframeData.paletteMap = this.paletteMap;
		wireframeData.weightsPerVertex = this.weightsPerVertex;

		return wireframeData;
	};


	// Calculation helpers
	var v1 = new Vector3();
	var v2 = new Vector3();
	var v3 = new Vector3();
	/**
	 * Builds flat meshdata from mesh
	 * @returns {MeshData}
	 */
	MeshData.prototype.buildFlatMeshData = function () {
		var oldIdcs = this.getIndexBuffer();
		if (oldIdcs === null) {
			console.debug('No indices, probably a point mesh');
			return this;
		}

		var attributeMap = ObjectUtils.deepClone(this.attributeMap);
		var attribs = {};
		for (var key in attributeMap) {
			attribs[key] = {
				oldBuffer: this.getAttributeBuffer(key),
				values: []
			};
		}
		var indexCount = 0;
		this.updatePrimitiveCounts();
		for (var section = 0; section < this.getSectionCount(); section++) {
			var indexMode = this.indexModes[section];
			var primitiveCount = this.getPrimitiveCount(section);
			var flip = false;
			for (var primitiveIndex = 0; primitiveIndex < primitiveCount; primitiveIndex++) {
				switch (indexMode) {
				/*jshint -W086 */
				case 'TriangleStrip':
					flip = (primitiveIndex % 2 === 1) ? true : false;
					// fall through intended?
				case 'Triangles':
				case 'TriangleFan':
					var i1 = oldIdcs[this.getVertexIndex(primitiveIndex, 0, section)];
					var i2 = oldIdcs[this.getVertexIndex(primitiveIndex, 1, section)];
					var i3 = oldIdcs[this.getVertexIndex(primitiveIndex, 2, section)];
					if (flip) {
						var f = i3;
						i3 = i2;
						i2 = f;
					}
					for (var key in attribs) {
						if (key === MeshData.NORMAL) {
							continue;
						}
						var count = attributeMap[key].count;
						for (var i = 0; i < count; i++) {
							attribs[key].values[indexCount * count + i] = attribs[key].oldBuffer[i1 * count + i];
							attribs[key].values[(indexCount + 1) * count + i] = attribs[key].oldBuffer[i2 * count + i];
							attribs[key].values[(indexCount + 2) * count + i] = attribs[key].oldBuffer[i3 * count + i];
						}
						if (key === MeshData.POSITION) {
							v1.setDirect(
								attribs[key].values[indexCount * 3],
								attribs[key].values[indexCount * 3 + 1],
								attribs[key].values[indexCount * 3 + 2]
							);
							v2.setDirect(
								attribs[key].values[(indexCount + 1) * 3],
								attribs[key].values[(indexCount + 1) * 3 + 1],
								attribs[key].values[(indexCount + 1) * 3 + 2]
							);
							v3.setDirect(
								attribs[key].values[(indexCount + 2) * 3],
								attribs[key].values[(indexCount + 2) * 3 + 1],
								attribs[key].values[(indexCount + 2) * 3 + 2]
							);
							v2.sub(v1);
							v3.sub(v1);
							v2.cross(v3).normalize();

							if (attribs[MeshData.NORMAL]) {
								attribs[MeshData.NORMAL].values[(indexCount) * 3] = v2.x;
								attribs[MeshData.NORMAL].values[(indexCount) * 3 + 1] = v2.y;
								attribs[MeshData.NORMAL].values[(indexCount) * 3 + 2] = v2.z;

								attribs[MeshData.NORMAL].values[(indexCount + 1) * 3] = v2.x;
								attribs[MeshData.NORMAL].values[(indexCount + 1) * 3 + 1] = v2.y;
								attribs[MeshData.NORMAL].values[(indexCount + 1) * 3 + 2] = v2.z;

								attribs[MeshData.NORMAL].values[(indexCount + 2) * 3] = v2.x;
								attribs[MeshData.NORMAL].values[(indexCount + 2) * 3 + 1] = v2.y;
								attribs[MeshData.NORMAL].values[(indexCount + 2) * 3 + 2] = v2.z;
							}
						}
					}
					indexCount += 3;
				}
			}
		}
		if (indexCount === 0) {
			console.warn('Could not build flat data');
			return this;
		}
		var flatMeshData = new MeshData(attributeMap, indexCount);

		for (var key in attribs) {
			flatMeshData.getAttributeBuffer(key).set(attribs[key].values);
		}

		flatMeshData.paletteMap = this.paletteMap;
		flatMeshData.weightsPerVertex = this.weightsPerVertex;

		return flatMeshData;
	};

	/**
	 * Destroys all attached vertex and index data.
	 * @param {WebGLRenderingContext} context
	 */
	MeshData.prototype.destroy = function (context) {
		if (this.vertexData) {
			this.vertexData.destroy(context);
		}
		if (this.indexData) {
			this.indexData.destroy(context);
		}
	};

	/**
	 * Returns a clone of this mesh data
	 * @returns {MeshData}
	 */
	MeshData.prototype.clone = function () {
		var attributeMapClone = ObjectUtils.deepClone(this.attributeMap);

		var clone = new MeshData(attributeMapClone, this.vertexCount, this.indexCount);

		clone.primitiveCounts = this.primitiveCounts.slice(0); // an array

		clone.vertexData.copy(this.vertexData); // BufferData
		clone.indexData.copy(this.indexData); // BufferData

		clone.indexLengths = Array.isArray(this.indexLengths) ? this.indexLengths.slice(0) : this.indexLengths;
		clone.indexModes = this.indexModes.slice(0);

		clone.type = this.type;

		if (this.paletteMap) {
			clone.paletteMap = this.paletteMap.slice(0); // an array
		}

		clone.weightsPerVertex = this.weightsPerVertex; // a number

		return clone;
	};

	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.POSITION = 'POSITION';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.NORMAL = 'NORMAL';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.COLOR = 'COLOR';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.TANGENT = 'TANGENT';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.TEXCOORD0 = 'TEXCOORD0';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.TEXCOORD1 = 'TEXCOORD1';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.TEXCOORD2 = 'TEXCOORD2';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.TEXCOORD3 = 'TEXCOORD3';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.WEIGHTS = 'WEIGHTS';
	/**
	 * @type {string}
	 * @readonly
	 */
	MeshData.JOINTIDS = 'JOINTIDS';

	/**
	 * Creates a definition for a vertex attribute
	 *
	 * @param {number} count Tuple size of attribute
	 * @param {string} type Data type
	 * @param {boolean} [normalized=false] If data should be normalized (true) or converted direction (false)
	 * @returns {Object} Attribute definition
	 */
	MeshData.createAttribute = function (count, type, normalized) {
		return {
			count: count,
			type: type,
			stride: 0,
			offset: 0,
			normalized: normalized !== undefined ? normalized : false
		};
	};

	var defaults = {
		'POSITION': MeshData.createAttribute(3, 'Float'),
		'NORMAL': MeshData.createAttribute(3, 'Float'),
		'COLOR': MeshData.createAttribute(4, 'Float'),
		'TANGENT': MeshData.createAttribute(4, 'Float'),
		'TEXCOORD0': MeshData.createAttribute(2, 'Float'),
		'TEXCOORD1': MeshData.createAttribute(2, 'Float'),
		'TEXCOORD2': MeshData.createAttribute(2, 'Float'),
		'TEXCOORD3': MeshData.createAttribute(2, 'Float'),
		'WEIGHTS': MeshData.createAttribute(4, 'Float'),
		'JOINTIDS': MeshData.createAttribute(4, 'Float')
	};

	function buildMap(types) {
		var map = {};
		for (var i = 0; i < types.length; i++) {
			var type = types[i];
			if (defaults[type] !== undefined) {
				map[type] = ObjectUtils.deepClone(defaults[type]);
			} else {
				throw new Error('No default attribute named: ' + type);
			}
		}
		return map;
	}

	/**
	 * Creates an attribute given the types
	 * @param {Array<string>} [types] An array of default types. If not provided you get an attributeMap with all default attributes
	 * @returns {Object}
	 * @example var map = MeshData.defaultMap([MeshData.POSITION, MeshData.TEXCOORD0]);
	 */
	MeshData.defaultMap = function (types) {
		if (types === undefined) {
			return buildMap(Object.keys(defaults));
		} else {
			return buildMap(types);
		}
	};

	return MeshData;
})(goo.BufferData,goo.RendererUtils,goo.BufferUtils,goo.Vector2,goo.Vector3,goo.Vector4,goo.ObjectUtils);
goo.BoundingSphere = (function (
	Vector3,
	MathUtils,
	BoundingVolume,
	MeshData
) {
	'use strict';

	/**
	 * <code>BoundingSphere</code> defines a sphere that defines a container for a group of vertices of a particular piece of geometry. This
	 *        sphere defines a radius and a center. <br>
	 *        <br>
	 *        A typical usage is to allow the class define the center and radius by calling either <code>containAABB</code> or
	 *        <code>averagePoints</code>. A call to <code>computeFramePoint</code> in turn calls <code>containAABB</code>.
	 */
	function BoundingSphere(center, radius) {
		BoundingVolume.call(this, center);
		this.radius = radius !== undefined ? radius : 1;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	var tmpVec = new Vector3();

	BoundingSphere.prototype = Object.create(BoundingVolume.prototype);
	BoundingSphere.prototype.constructor = BoundingSphere;

	BoundingSphere.prototype.computeFromPoints = function (verts) {
		var l = verts.length;
		if (l < 3) {
			return;
		}

		var min = this.min;
		var max = this.max;
		var vec = tmpVec;

		min.setDirect(verts[0], verts[1], verts[2]);
		max.setDirect(verts[0], verts[1], verts[2]);
		var x, y, z;
		for (var i = 3; i < l; i += 3) {
			x = verts[i + 0];
			y = verts[i + 1];
			z = verts[i + 2];
			min.x = x < min.x ? x : min.x;
			min.y = y < min.y ? y : min.y;
			min.z = z < min.z ? z : min.z;
			max.x = x > max.x ? x : max.x;
			max.y = y > max.y ? y : max.y;
			max.z = z > max.z ? z : max.z;
		}
		var newCenter = max.add(min).scale(1 / 2.0);
		var size = 0, test;
		for (var i = 0; i < l; i += 3) {
			vec.setDirect(verts[i], verts[i + 1], verts[i + 2]);
			test = vec.sub(newCenter).lengthSquared();
			if (test > size) {
				size = test;
			}
		}

		this.radius = Math.sqrt(size);
		this.center.set(newCenter);
	};

	(function () {
		var relativePoint = new Vector3();

		/**
		 * Method to test whether a point is inside the bounding box or not
		 * @param {Vector3} point
		 * @returns {boolean}
		 */
		BoundingSphere.prototype.containsPoint = function (point) {
			return relativePoint.set(point).sub(this.center).lengthSquared() <= Math.pow(this.radius, 2);
		};
	})();

	BoundingSphere.prototype.computeFromPrimitives = function (data, section, indices, start, end) {
		if (end - start <= 0) {
			return;
		}

		var vertList = [];
		var store = [];
		var vertsPerPrimitive = MeshData.getVertexCount(data.indexModes[section]);

		var count = 0;
		for (var i = start; i < end; i++) {
			store = data.getPrimitiveVertices(indices[i], section, store);
			for (var j = 0; j < vertsPerPrimitive; j++) {
				vertList[count++] = new Vector3().set(store[j]);
			}
		}

		this.averagePoints(vertList);
	};

	BoundingSphere.prototype.averagePoints = function (points) {
		this.center.set(points[0]);

		for (var i = 1; i < points.length; i++) {
			this.center.add(points[i]);
		}

		var quantity = 1.0 / points.length;
		this.center.scale(quantity);

		var maxRadiusSqr = 0.0;
		for (var i = 0; i < points.length; i++) {
			var diff = tmpVec.copy(points[i]).sub(this.center);
			var radiusSqr = diff.lengthSquared();
			if (radiusSqr > maxRadiusSqr) {
				maxRadiusSqr = radiusSqr;
			}
		}

		this.radius = Math.sqrt(maxRadiusSqr) + 0.00001;
	};

	BoundingSphere.prototype.transform = function (transform, bound) {
		if (bound === null) {
			bound = new BoundingSphere();
		}

		transform.applyForward(this.center, bound.center);

		var scale = transform.scale;
		bound.radius = Math.abs(this._maxAxis(scale) * this.radius);

		return bound;
	};

	BoundingSphere.prototype.whichSide = function (plane) {
		var planeData = plane.normal;
		var pointData = this.center;
		var distance = planeData.x * pointData.x + planeData.y * pointData.y + planeData.z * pointData.z - plane.constant;

		if (distance < -this.radius) {
			return BoundingVolume.Inside;
		} else if (distance > this.radius) {
			return BoundingVolume.Outside;
		} else {
			return BoundingVolume.Intersects;
		}
	};

	BoundingSphere.prototype._pseudoDistance = function (plane, point) {
		return plane.normal.x * point.x + plane.normal.y * point.y + plane.normal.z * point.z - plane.constant;
	};

	BoundingSphere.prototype._maxAxis = function (scale) {
		return Math.max(Math.abs(scale.x), Math.max(Math.abs(scale.y), Math.abs(scale.z)));
	};

	BoundingSphere.prototype.toString = function () {
		var x = Math.round(this.center.x * 10) / 10;
		var y = Math.round(this.center.y * 10) / 10;
		var z = Math.round(this.center.z * 10) / 10;
		var radius = Math.round(this.radius * 10) / 10;

		return '[' + x + ',' + y + ',' + z + ']' + ' - ' + radius;
	};

	BoundingSphere.prototype.intersects = function (bv) {
		return bv.intersectsSphere(this);
	};

	BoundingSphere.prototype.intersectsBoundingBox = function (bb) {
		// bb.min/max aren't updated properly; have to do it here for now
		bb.min.x = bb.center.x - bb.xExtent;
		bb.min.y = bb.center.y - bb.yExtent;
		bb.min.z = bb.center.z - bb.zExtent;

		bb.max.x = bb.center.x + bb.xExtent;
		bb.max.y = bb.center.y + bb.yExtent;
		bb.max.z = bb.center.z + bb.zExtent;

		var rs = Math.pow(this.radius, 2);
		var dmin = 0;

		if (this.center.x < bb.min.x) {
			dmin += Math.pow(this.center.x - bb.min.x, 2);
		} else if (this.center.x > bb.max.x) {
			dmin += Math.pow(this.center.x - bb.max.x, 2);
		}

		if (this.center.y < bb.min.y) {
			dmin += Math.pow(this.center.y - bb.min.y, 2);
		} else if (this.center.y > bb.max.y) {
			dmin += Math.pow(this.center.y - bb.max.y, 2);
		}

		if (this.center.z < bb.min.z) {
			dmin += Math.pow(this.center.z - bb.min.z, 2);
		} else if (this.center.z > bb.max.z) {
			dmin += Math.pow(this.center.z - bb.max.z, 2);
		}

		return dmin <= rs;
	};

	BoundingSphere.prototype.intersectsSphere = function (bs) {
		var diff = tmpVec.set(this.center).sub(bs.center);
		var rsum = this.radius + bs.radius;
		return diff.dot(diff) <= rsum * rsum;
		//return this.center.distanceSquared(bs.center) <= rsum * rsum;
	};

	BoundingSphere.prototype.intersectsRay = function (ray) {
		if (!this.center) {
			return false;
		}

		var diff = ray.origin.clone().sub(this.center);
		var a = diff.dot(diff) - this.radius * this.radius;
		if (a <= 0.0) {
			// in sphere
			return true;
		}

		// outside sphere
		var b = ray.direction.dot(diff);
		if (b >= 0.0) {
			return false;
		}
		return b * b >= a;
	};

	BoundingSphere.prototype.intersectsRayWhere = function (ray) {
		var diff = new Vector3().copy(ray.origin).sub(this.center);
		var a = diff.dot(diff) - this.radius * this.radius;
		var a1, discr, root;
		if (a <= 0.0) {
			// inside sphere
			a1 = ray.direction.dot(diff);
			discr = a1 * a1 - a;
			root = Math.sqrt(discr);
			var distances = [root - a1];
			var points = [new Vector3().copy(ray.direction).scale(distances[0]).add(ray.origin)];
			return {
				distances: distances,
				points: points
			};
		}

		a1 = ray.direction.dot(diff);
		if (a1 >= 0.0) {
			// No intersection
			return null;
		}

		discr = a1 * a1 - a;
		if (discr < 0.0) {
			return null;
		} else if (discr >= 0.00001) {
			root = Math.sqrt(discr);
			var distances = [-a1 - root, -a1 + root];
			var points = [new Vector3().copy(ray.direction).scale(distances[0]).add(ray.origin),
				new Vector3().copy(ray.direction).scale(distances[1]).add(ray.origin)];
			return {
				distances: distances,
				points: points
			};
		}

		var distances = [-a1];
		var points = [new Vector3().copy(ray.direction).scale(distances[0]).add(ray.origin)];
		return {
			distances: distances,
			points: points
		};
	};

	BoundingSphere.prototype.merge = function (bv) {
		if (bv instanceof BoundingSphere) {
			return this.mergeSphere(bv.center, bv.radius, this);
		} else {
			var boxRadius = tmpVec.setDirect(bv.xExtent, bv.yExtent, bv.zExtent).length();
			return this.mergeSphere(bv.center, boxRadius, this);
		}
	};

	BoundingSphere.prototype.mergeSphere = function (center, radius, store) {
		if (!store) {
			store = new BoundingSphere();
		}

		var diff = tmpVec.set(center).sub(this.center);
		var lengthSquared = diff.lengthSquared();
		var radiusDiff = radius - this.radius;
		var radiusDiffSqr = radiusDiff * radiusDiff;

		// if one sphere wholly contains the other
		if (radiusDiffSqr >= lengthSquared) {
			// if we contain the other
			if (radiusDiff <= 0.0) {
				store.center.set(this.center);
				store.radius = this.radius;
				return store;
			}
			// else the other contains us
			else {
				store.center.set(center);
				store.radius = radius;
				return store;
			}
		}

		// distance between sphere centers
		var length = Math.sqrt(lengthSquared);

		// init a center var using our center
		var rCenter = store.center;

		// if our centers are at least a tiny amount apart from each other...
		if (length > MathUtils.EPSILON) {
			// place us between the two centers, weighted by radii
			var coeff = (length + radiusDiff) / (2.0 * length);
			rCenter.add(diff.scale(coeff));
		}

		// Set radius
		store.radius = 0.5 * (length + this.radius + radius);

		return store;
	};

	/**
	 * Copies data from another bounding sphere
	 * @param {BoundingSphere} source bounding sphere to copy from
	 * @returns {BoundingSphere} Returns self to allow chaining
	 */
	BoundingSphere.prototype.copy = function (source) {
		BoundingVolume.prototype.copy.call(this, source);
		this.radius = source.radius;
		return this;
	};

	// ---
	var warned = false;

	/**
	 * Returns a clone of this bounding sphere
	 * @returns {BoundingSphere}
	 */
	BoundingSphere.prototype.clone = function () {
		if (arguments.length > 0 && !warned) {
			warned = true;
			console.warn(
				'BoundingSphere::clone no longer takes an optional "store" parameter; ' +
				'please use BoundingSphere::copy instead'
			);
		}
		// center appears to be shared but it really isn't since the BoundingVolume constructor clones it
		// when/if that ever changes this needs adapted accordingly
		return new BoundingSphere(this.center, this.radius);
	};

	return BoundingSphere;
})(goo.Vector3,goo.MathUtils,goo.BoundingVolume,goo.MeshData);
goo.BoundingBox = (function (
	Vector3,
	BoundingVolume,
	BoundingSphere,
	MathUtils
) {
	'use strict';

	/**
	 * <code>BoundingBox</code> defines an axis-aligned cube that defines a container for a group of vertices of a
	 * particular piece of geometry. This box defines a center and extents from that center along the x, y and z axis. <br>
	 *        <br>
	 *        A typical usage is to allow the class define the center and radius by calling either <code>containAABB</code> or
	 *        <code>averagePoints</code>. A call to <code>computeFramePoint</code> in turn calls <code>containAABB</code>.
	 */
	function BoundingBox(center, xExtent, yExtent, zExtent) {
		BoundingVolume.call(this, center);

		// x/y/z Extent is actually width/height/depth * 0.5
		this.xExtent = xExtent !== undefined ? xExtent : 1;
		this.yExtent = yExtent !== undefined ? yExtent : 1;
		this.zExtent = zExtent !== undefined ? zExtent : 1;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	var tmpVec1 = new Vector3();
	var tmpVec2 = new Vector3();
	var tmpVec3 = new Vector3();

	var tmpCorners = [];
	for (var i = 0; i < 8; i++) {
		tmpCorners.push(new Vector3());
	}

	BoundingBox.prototype = Object.create(BoundingVolume.prototype);
	BoundingBox.prototype.constructor = BoundingBox;

	BoundingBox.prototype.computeFromPoints = function (verts) {
		var l = verts.length;
		if (l < 3) {
			return;
		}

		var min = this.min;
		var max = this.max;
		var vec = tmpVec3;

		min.setDirect(verts[0], verts[1], verts[2]);
		max.setDirect(verts[0], verts[1], verts[2]);
		var x, y, z;
		for (var i = 3; i < l; i += 3) {
			x = verts[i + 0];
			y = verts[i + 1];
			z = verts[i + 2];
			min.x = x < min.x ? x : min.x;
			min.y = y < min.y ? y : min.y;
			min.z = z < min.z ? z : min.z;
			max.x = x > max.x ? x : max.x;
			max.y = y > max.y ? y : max.y;
			max.z = z > max.z ? z : max.z;
		}

		vec.set(max).sub(min).scale(0.5);
		this.xExtent = vec.x;
		this.yExtent = vec.y;
		this.zExtent = vec.z;

		this.center.set(max).add(min).scale(0.5);
	};

	/**
	 * Method to test whether a point is inside the bounding box or not
	 * @param {Vector3} point
	 * @returns {boolean}
	 */
	BoundingBox.prototype.containsPoint = function (point) {
		var center = this.center;
		var x = point.x - center.x;
		var y = point.y - center.y;
		var z = point.z - center.z;

		return x >= -this.xExtent && x <= this.xExtent &&
			y >= -this.yExtent && y <= this.yExtent &&
			z >= -this.zExtent && z <= this.zExtent;
	};

	var tmpArray = [];

	BoundingBox.prototype.computeFromPrimitives = function (data, section, indices, start, end) {
		if (end - start <= 0) {
			return;
		}

		var min = tmpVec1.setDirect(Infinity, Infinity, Infinity);
		var max = tmpVec2.setDirect(-Infinity, -Infinity, -Infinity);

		var store = tmpArray;
		store.length = 0;

		for (var i = start; i < end; i++) {
			store = data.getPrimitiveVertices(indices[i], section, store);
			for (var j = 0; j < store.length; j++) {
				BoundingBox.checkMinMax(min, max, store[j]);
			}
		}

		this.center.copy(min.add(max));
		this.center.scale(0.5);

		this.xExtent = max.x - this.center.x;
		this.yExtent = max.y - this.center.y;
		this.zExtent = max.z - this.center.z;
	};

	BoundingBox.checkMinMax = function (min, max, point) {
		if (point.x < min.x) {
			min.x = point.x;
		}
		if (point.x > max.x) {
			max.x = point.x;
		}

		if (point.y < min.y) {
			min.y = point.y;
		}
		if (point.y > max.y) {
			max.y = point.y;
		}

		if (point.z < min.z) {
			min.z = point.z;
		}
		if (point.z > max.z) {
			max.z = point.z;
		}
	};

	BoundingBox.prototype.transform = function (transform, box) {
		if (box === null) {
			box = new BoundingBox();
		}

		var corners = tmpCorners;
		this.getCorners(corners);

		// Transform all of these points by the transform
		for (var i = 0; i < 8; i++) {
			corners[i].applyPostPoint(transform.matrix);
		}
		// Now compute based on these transformed points
		var minX = corners[0].x;
		var minY = corners[0].y;
		var minZ = corners[0].z;
		var maxX = minX;
		var maxY = minY;
		var maxZ = minZ;
		for (var i = 1; i < 8; i++) {
			var curX = corners[i].x;
			var curY = corners[i].y;
			var curZ = corners[i].z;
			minX = Math.min(minX, curX);
			minY = Math.min(minY, curY);
			minZ = Math.min(minZ, curZ);
			maxX = Math.max(maxX, curX);
			maxY = Math.max(maxY, curY);
			maxZ = Math.max(maxZ, curZ);
		}

		var ctrX = (maxX + minX) * 0.5;
		var ctrY = (maxY + minY) * 0.5;
		var ctrZ = (maxZ + minZ) * 0.5;

		box.center.setDirect(ctrX, ctrY, ctrZ);
		box.xExtent = maxX - ctrX;
		box.yExtent = maxY - ctrY;
		box.zExtent = maxZ - ctrZ;

		return box;
	};

	BoundingBox.prototype.getCorners = function (store) {
		var xExtent = this.xExtent;
		var yExtent = this.yExtent;
		var zExtent = this.zExtent;
		var centerData = this.center;
		store[0].setDirect(centerData.x + xExtent, centerData.y + yExtent, centerData.z + zExtent);
		store[1].setDirect(centerData.x + xExtent, centerData.y + yExtent, centerData.z - zExtent);
		store[2].setDirect(centerData.x + xExtent, centerData.y - yExtent, centerData.z + zExtent);
		store[3].setDirect(centerData.x + xExtent, centerData.y - yExtent, centerData.z - zExtent);
		store[4].setDirect(centerData.x - xExtent, centerData.y + yExtent, centerData.z + zExtent);
		store[5].setDirect(centerData.x - xExtent, centerData.y + yExtent, centerData.z - zExtent);
		store[6].setDirect(centerData.x - xExtent, centerData.y - yExtent, centerData.z + zExtent);
		store[7].setDirect(centerData.x - xExtent, centerData.y - yExtent, centerData.z - zExtent);
		return store;
	};

	BoundingBox.prototype.whichSide = function (plane) {
		var planeData = plane.normal;
		var pointData = this.center;

		var radius = Math.abs(this.xExtent * planeData.x) +
			Math.abs(this.yExtent * planeData.y) +
			Math.abs(this.zExtent * planeData.z);

		var distance = planeData.x * pointData.x +
			planeData.y * pointData.y +
			planeData.z * pointData.z -
			plane.constant;

		if (distance < -radius) {
			return BoundingVolume.Inside;
		} else if (distance > radius) {
			return BoundingVolume.Outside;
		} else {
			return BoundingVolume.Intersects;
		}
	};

	BoundingBox.prototype._pseudoDistance = function (plane, point) {
		var planeData = plane.normal;
		var pointData = point;

		return planeData.x * pointData.x + planeData.y * pointData.y + planeData.z * pointData.z - plane.constant;
	};

	BoundingBox.prototype._maxAxis = function (scale) {
		return Math.max(Math.abs(scale.x), Math.max(Math.abs(scale.y), Math.abs(scale.z)));
	};

	BoundingBox.prototype.toString = function () {
		var x = Math.round(this.center.x * 10) / 10;
		var y = Math.round(this.center.y * 10) / 10;
		var z = Math.round(this.center.z * 10) / 10;

		return '[' + x + ',' + y + ',' + z + ']' + ' - ' + '[' + this.xExtent + ',' + this.yExtent + ',' + this.zExtent + ']';
	};

	BoundingBox.prototype.intersects = function (bv) {
		return bv.intersectsBoundingBox(this);
	};

	BoundingBox.prototype.intersectsBoundingBox = function (bb) {
		// TODO: use this.min/max instead of center-extent diffs
		if (this.center.x + this.xExtent < bb.center.x - bb.xExtent || this.center.x - this.xExtent > bb.center.x + bb.xExtent) {
			return false;
		} else if (this.center.y + this.yExtent < bb.center.y - bb.yExtent || this.center.y - this.yExtent > bb.center.y + bb.yExtent) {
			return false;
		} else if (this.center.z + this.zExtent < bb.center.z - bb.zExtent || this.center.z - this.zExtent > bb.center.z + bb.zExtent) {
			return false;
		} else {
			return true;
		}
	};

	BoundingBox.prototype.intersectsSphere = function (bs) {
		// this.min/max aren't updated properly; have to do it here for now
		this.min.x = this.center.x - this.xExtent;
		this.min.y = this.center.y - this.yExtent;
		this.min.z = this.center.z - this.zExtent;

		this.max.x = this.center.x + this.xExtent;
		this.max.y = this.center.y + this.yExtent;
		this.max.z = this.center.z + this.zExtent;

		var rs = Math.pow(bs.radius, 2);
		var dmin = 0;

		if (bs.center.x < this.min.x) {
			dmin += Math.pow(bs.center.x - this.min.x, 2);
		} else if (bs.center.x > this.max.x) {
			dmin += Math.pow(bs.center.x - this.max.x, 2);
		}

		if (bs.center.y < this.min.y) {
			dmin += Math.pow(bs.center.y - this.min.y, 2);
		} else if (bs.center.y > this.max.y) {
			dmin += Math.pow(bs.center.y - this.max.y, 2);
		}

		if (bs.center.z < this.min.z) {
			dmin += Math.pow(bs.center.z - this.min.z, 2);
		} else if (bs.center.z > this.max.z) {
			dmin += Math.pow(bs.center.z - this.max.z, 2);
		}

		return dmin <= rs;
	};

	BoundingBox.prototype.testStaticAABBAABB = function (bb, contact) {
		var a = this;
		var b = bb;

		// [Minimum Translation Vector]
		var mtvInfo = {
			mtvDistance: 10000000000, // Set current minimum distance (max float value so next value is always less)
			mtvAxis: new Vector3()
			// Axis along which to travel with the minimum distance
		};

		// [Axes of potential separation]
		// * Each shape must be projected on these axes to test for intersection:
		//
		// (1, 0, 0) A0 (= B0) [X Axis]
		// (0, 1, 0) A1 (= B1) [Y Axis]
		// (0, 0, 1) A1 (= B2) [Z Axis]

		// [X Axis]
		if (!this.testAxisStatic(Vector3.UNIT_X, a.center.x - a.xExtent, a.center.x + a.xExtent, b.center.x - b.xExtent, b.center.x + b.xExtent,
			mtvInfo)) {
			return false;
		}

		// [Y Axis]
		if (!this.testAxisStatic(Vector3.UNIT_Y, a.center.y - a.yExtent, a.center.y + a.yExtent, b.center.y - b.yExtent, b.center.y + b.yExtent,
			mtvInfo)) {
			return false;
		}

		// [Z Axis]
		if (!this.testAxisStatic(Vector3.UNIT_Z, a.center.z - a.zExtent, a.center.z + a.zExtent, b.center.z - b.zExtent, b.center.z + b.zExtent,
			mtvInfo)) {
			return false;
		}

		if (contact) {
			contact.isIntersecting = true;

			// Calculate Minimum Translation Vector (MTV) [normal * penetration]
			// contact.normal = mtvInfo.mtvAxis.normalize();
			contact.normal = mtvInfo.mtvAxis;

			// Multiply the penetration depth by itself plus a small increment
			// When the penetration is resolved using the MTV, it will no longer intersect
			contact.penetration = Math.sqrt(mtvInfo.mtvDistance) * 1.001;
			// contact.penetration = mtvInfo.mtvDistance * 1.001;
		}

		return true;
	};

	BoundingBox.prototype.testAxisStatic = function (axis, minA, maxA, minB, maxB, mtvInfo) {
		// [Separating Axis Theorem]
		// * Two convex shapes only overlap if they overlap on all axes of separation
		// * In order to create accurate responses we need to find the collision vector (Minimum Translation Vector)
		// * Find if the two boxes intersect along a single axis
		// * Compute the intersection interval for that axis
		// * Keep the smallest intersection/penetration value
		var axisLengthSquared = axis.dot(axis);

		// If the axis is degenerate then ignore
		if (axisLengthSquared < 0.000001) {
			return true;
		}

		// Calculate the two possible overlap ranges
		// Either we overlap on the left or the right sides
		var d0 = maxB - minA; // 'Left' side
		var d1 = maxA - minB; // 'Right' side

		// Intervals do not overlap, so no intersection
		if (d0 <= 0.0 || d1 <= 0.0) {
			return false;
		}

		// Find out if we overlap on the 'right' or 'left' of the object.
		var overlap = d0 < d1 ? d0 : -d1;

		// The mtd vector for that axis
		// var sep = axis * (overlap / axisLengthSquared);
		var sep = new Vector3().copy(axis).scale(overlap / axisLengthSquared);

		// The mtd vector length squared
		var sepLengthSquared = sep.dot(sep);

		// If that vector is smaller than our computed Minimum Translation Distance use that vector as our current MTV distance
		if (sepLengthSquared < mtvInfo.mtvDistance) {
			mtvInfo.mtvDistance = sepLengthSquared;
			// mtvInfo.mtvAxis = sep;
			mtvInfo.mtvAxis = axis;
		}

		return true;
	};

	BoundingBox.prototype.intersectsRay = function (ray) {
		if (isNaN(this.center.x) || isNaN(this.center.y) || isNaN(this.center.z)) {
			return false;
		}

		// var diff = Vector3.sub(ray.origin, this.center, tmpVec1);
		var diff = tmpVec1.set(ray.origin).sub(this.center);
		var direction = ray.direction;

		var t = [0.0, Infinity];

		// Check for degenerate cases and pad using zero tolerance. Should give close enough result.
		var x = this.xExtent;
		if (x < MathUtils.ZERO_TOLERANCE && x >= 0) {
			x = MathUtils.ZERO_TOLERANCE;
		}
		var y = this.yExtent;
		if (y < MathUtils.ZERO_TOLERANCE && y >= 0) {
			y = MathUtils.ZERO_TOLERANCE;
		}
		var z = this.zExtent;
		if (z < MathUtils.ZERO_TOLERANCE && z >= 0) {
			z = MathUtils.ZERO_TOLERANCE;
		}

		var notEntirelyClipped = //
			BoundingBox.clip(direction.x, -diff.x - x, t) && //
				BoundingBox.clip(-direction.x, diff.x - x, t) && //
				BoundingBox.clip(direction.y, -diff.y - y, t) && //
				BoundingBox.clip(-direction.y, diff.y - y, t) && //
				BoundingBox.clip(direction.z, -diff.z - z, t) && //
				BoundingBox.clip(-direction.z, diff.z - z, t);

		if (notEntirelyClipped && (t[0] !== 0.0 || t[1] !== Infinity)) {
			return true;
		}

		return false;
	};

	BoundingBox.prototype.intersectsRayWhere = function (ray) {
		if (isNaN(this.center.x) || isNaN(this.center.y) || isNaN(this.center.z)) {
			return null;
		}

		var diff = tmpVec1.copy(ray.origin).sub(this.center);
		var direction = ray.direction;

		var t = [0.0, Infinity];

		// Check for degenerate cases and pad using zero tolerance. Should give close enough result.
		var x = this.xExtent;
		if (x < MathUtils.ZERO_TOLERANCE && x >= 0) {
			x = MathUtils.ZERO_TOLERANCE;
		}
		var y = this.yExtent;
		if (y < MathUtils.ZERO_TOLERANCE && y >= 0) {
			y = MathUtils.ZERO_TOLERANCE;
		}
		var z = this.zExtent;
		if (z < MathUtils.ZERO_TOLERANCE && z >= 0) {
			z = MathUtils.ZERO_TOLERANCE;
		}

		var notEntirelyClipped = //
			BoundingBox.clip(direction.x, -diff.x - x, t) && //
				BoundingBox.clip(-direction.x, diff.x - x, t) && //
				BoundingBox.clip(direction.y, -diff.y - y, t) && //
				BoundingBox.clip(-direction.y, diff.y - y, t) && //
				BoundingBox.clip(direction.z, -diff.z - z, t) && //
				BoundingBox.clip(-direction.z, diff.z - z, t);

		if (notEntirelyClipped && (t[0] !== 0.0 || t[1] !== Infinity)) {
			if (t[1] > t[0]) {
				var distances = t;
				var points = [new Vector3(ray.direction).scale(distances[0]).add(ray.origin),
					new Vector3(ray.direction).scale(distances[1]).add(ray.origin)];
				return {
					distances: distances,
					points: points
				};
			}

			var distances = [t[0]];
			var points = [new Vector3(ray.direction).scale(distances[0]).add(ray.origin)];
			return {
				distances: distances,
				points: points
			};
		}

		return null;
	};

	BoundingBox.clip = function (denom, numer, t) {
		// Return value is 'true' if line segment intersects the current test
		// plane. Otherwise 'false' is returned in which case the line segment
		// is entirely clipped.
		if (denom > 0.0) {
			if (numer > denom * t[1]) {
				return false;
			}
			if (numer > denom * t[0]) {
				t[0] = numer / denom;
			}
			return true;
		} else if (denom < 0.0) {
			if (numer > denom * t[0]) {
				return false;
			}
			if (numer > denom * t[1]) {
				t[1] = numer / denom;
			}
			return true;
		} else {
			return numer <= 0.0;
		}
	};

	BoundingBox.prototype.merge = function (bv) {
		if (bv instanceof BoundingBox) {
			return this.mergeBox(bv.center, bv.xExtent, bv.yExtent, bv.zExtent, this);
		} else if (bv instanceof BoundingSphere) {
			return this.mergeBox(bv.center, bv.radius, bv.radius, bv.radius, this);
		} else {
			return this;
		}
	};

	BoundingBox.prototype.mergeBox = function (center, xExtent, yExtent, zExtent, store) {
		if (!store) {
			store = new BoundingBox();
		}

		var calcVec1 = tmpVec1;
		var calcVec2 = tmpVec2;

		calcVec1.x = this.center.x - this.xExtent;
		if (calcVec1.x > center.x - xExtent) {
			calcVec1.x = center.x - xExtent;
		}
		calcVec1.y = this.center.y - this.yExtent;
		if (calcVec1.y > center.y - yExtent) {
			calcVec1.y = center.y - yExtent;
		}
		calcVec1.z = this.center.z - this.zExtent;
		if (calcVec1.z > center.z - zExtent) {
			calcVec1.z = center.z - zExtent;
		}

		calcVec2.x = this.center.x + this.xExtent;
		if (calcVec2.x < center.x + xExtent) {
			calcVec2.x = center.x + xExtent;
		}
		calcVec2.y = this.center.y + this.yExtent;
		if (calcVec2.y < center.y + yExtent) {
			calcVec2.y = center.y + yExtent;
		}
		calcVec2.z = this.center.z + this.zExtent;
		if (calcVec2.z < center.z + zExtent) {
			calcVec2.z = center.z + zExtent;
		}

		store.center.set(calcVec2).add(calcVec1).scale(0.5);

		store.xExtent = calcVec2.x - store.center.x;
		store.yExtent = calcVec2.y - store.center.y;
		store.zExtent = calcVec2.z - store.center.z;

		return store;
	};

	/**
	 * Copies data from another bounding box
	 * @param {BoundingBox} source bounding box to copy from
	 * @returns {BoundingBox} Returns self to allow chaining
	 */
	BoundingBox.prototype.copy = function (source) {
		BoundingVolume.prototype.copy.call(this, source);
		this.xExtent = source.xExtent;
		this.yExtent = source.yExtent;
		this.zExtent = source.zExtent;
		return this;
	};

	// ---
	var warned = false;

	/**
	 * Returns a clone of this bounding box
	 * @returns {BoundingBox}
	 */
	BoundingBox.prototype.clone = function () {
		if (arguments.length > 0 && !warned) {
			warned = true;
			console.warn(
				'BoundingBox::clone no longer takes an optional "store" parameter; ' +
				'please use BoundingBox::copy instead'
			);
		}
		// center appears to be shared but it really isn't since the BoundingVolume constructor clones it
		// when/if that ever changes this needs adapted accordingly
		return new BoundingBox(this.center, this.xExtent, this.yExtent, this.zExtent);
	};

	return BoundingBox;
})(goo.Vector3,goo.BoundingVolume,goo.BoundingSphere,goo.MathUtils);
goo.EntityUtils = (function (
	Scripts,
	BoundingBox,
	_
) {
	'use strict';

	/**
	 * Utilities for entity creation etc
	 * Only used to define the class. Should never be instantiated.
	 */
	function EntityUtils() {}

	/**
	 * Returns a clone of the given SkeletonPose. Also stores the cloned poses into settings, in order not to
	 * clone multiple instances of the same SkeletonPose.
	 * @param {SkeletonPose} skeletonPose
	 * @param {Object} settings
	 */
	function cloneSkeletonPose(skeletonPose, settings) {
		settings.skeletonMap = settings.skeletonMap || {
			originals: [],
			clones: []
		};
		var idx = settings.skeletonMap.originals.indexOf(skeletonPose);
		var clonedSkeletonPose;
		if (idx === -1) {
			clonedSkeletonPose = skeletonPose.clone();
			settings.skeletonMap.originals.push(skeletonPose);
			settings.skeletonMap.clones.push(clonedSkeletonPose);
		} else {
			clonedSkeletonPose = settings.skeletonMap.clones[idx];
		}

		return clonedSkeletonPose;
	}

	//! AT: this is a huge mess
	// cloneEntity will only work for very few cases anyways, for very specific components
	function cloneEntity(world, entity, settings) {
		// settings is also used to store stuff on it, like animation skeletons
		var newEntity = world.createEntity(entity.name);

		newEntity._tags = _.cloneSet(entity._tags);
		newEntity._attributes = _.cloneMap(entity._attributes);
		newEntity._hidden = entity._hidden;
		newEntity.static = entity.static;

		for (var i = 0; i < entity._components.length; i++) {
			var component = entity._components[i];
			if (component.type === 'TransformComponent') {
				newEntity.transformComponent.transform.copy(component.transform);
			} else if (component.type === 'MeshDataComponent') {
				var clonedMeshDataComponent = component.clone(settings);
				if (component.currentPose) {
					clonedMeshDataComponent.currentPose = cloneSkeletonPose(component.currentPose, settings);
				}
				newEntity.setComponent(clonedMeshDataComponent);
			} else if (component.type === 'AnimationComponent') {
				var clonedAnimationComponent = component.clone();
				clonedAnimationComponent._skeletonPose = cloneSkeletonPose(component._skeletonPose, settings);
				newEntity.setComponent(clonedAnimationComponent);
			} else if (component.type === 'ScriptComponent') {
				var scriptComponent = new component.constructor();
				for (var j = 0; j < component.scripts.length; j++) {
					var newScript;
					var script = component.scripts[j];
					var key = script.externals ? script.externals.key || script.externals.name : null;
					if (key && Scripts.getScript(key)) { // Engine script
						newScript = Scripts.create(key, script.parameters);
					} else { // Custom script
						newScript = {
							externals: script.externals,
							name: (script.name || '') + '_clone',
							enabled: !!script.enabled
						};
						if (script.parameters) { newScript.parameters = _.deepClone(script.parameters); }

						if (script.setup) { newScript.setup = script.setup; }
						if (script.update) { newScript.update = script.update; }
						if (script.cleanup) { newScript.cleanup = script.cleanup; }
						scriptComponent.scripts.push(newScript);
					}
				}
				newEntity.setComponent(scriptComponent);
				if (world.getSystem('ScriptSystem').manualSetup && component.scripts[0].context) {
					scriptComponent.setup(newEntity);
				}
			} else if (component.clone) {
				newEntity.setComponent(component.clone(settings));
			} else {
				newEntity.setComponent(component);
			}
		}
		for (var j = 0; j < entity.transformComponent.children.length; j++) {
			var child = entity.transformComponent.children[j];
			var clonedChild = cloneEntity(world, child.entity, settings);
			newEntity.transformComponent.attachChild(clonedChild.transformComponent);
		}

		if (settings.callback) {
			settings.callback(newEntity);
		}

		return newEntity;
	}

	/**
	 * Clone entity hierarchy with optional settings for sharing data and callbacks.
	 * @param {World} world
	 * @param {Entity} entity The entity to clone
	 * @param {Object} [settings]
	 * @param {boolean} [settings.shareMeshData=false] Cloning entities clones their mesh data by default
	 * @param {boolean} [settings.shareMaterials=false] Cloning entities clones their materials by default
	 * @param {boolean} [settings.shareUniforms=false] Cloning entities clones their materials' uniforms by default
	 * @param {boolean} [settings.shareTextures=false] Cloning entities clones their materials' textures by default
	 * @param {function (entity: Entity)} [settings.callback] Callback to be run on every new entity. Takes entity as argument. Runs bottom to top in the cloned hierarchy.
	 * @returns {Entity} The cloned entity.
	 */
	EntityUtils.clone = function (world, entity, settings) {
		settings = settings || {};
		// REVIEW: It's bad style to modify the settings object provided by the caller.
		// I.e. if the caller does:
		//   var s = {};
		//   EntityUtils.clone(w, e, s);
		// ...he wouldn't expect s to have changed.
		// REVIEW: `settings.shareData || true` will evaluate to true if shareData is false,
		// which means that the setting will always be true.
		//settings.shareData = settings.shareData || true;
		//settings.shareMaterial = settings.shareMaterial || true;  // REVIEW: these are not used nor documented but would be great if they were
		//settings.cloneHierarchy = settings.cloneHierarchy || true;

		//! AT: why is everything here overridden anyways?
		// Why is this function just defaulting some parameters and then calling cloneEntity to do the rest?

		return cloneEntity(world, entity, settings);
	};

	/**
	 * Traverse the entity hierarchy upwards, returning the root entity
	 * @param {Entity} entity The entity to begin traversing from
	 * @returns {Entity} The root entity
	 */
	EntityUtils.getRoot = function (entity) {
		while (entity.transformComponent.parent) {
			entity = entity.transformComponent.parent.entity;
		}
		return entity;
	};

	//! AT: undocumented and used only once, in MeshBuilder
	EntityUtils.updateWorldTransform = function (transformComponent) {
		transformComponent.updateWorldTransform();

		for (var i = 0; i < transformComponent.children.length; i++) {
			EntityUtils.updateWorldTransform(transformComponent.children[i]);
		}
	};

	/**
	 * Returns the merged bounding box of the entity and its children
	 * @param entity
	 */
	EntityUtils.getTotalBoundingBox = function (entity) {
		var mergedWorldBound = new BoundingBox();
		var first = true;
		entity.traverse(function (entity) {
			if (entity.meshRendererComponent) {
				if (first) {
					var boundingVolume = entity.meshRendererComponent.worldBound;
					if (boundingVolume instanceof BoundingBox) {
						mergedWorldBound.copy(boundingVolume);
					} else {
						mergedWorldBound.center.set(boundingVolume.center);
						mergedWorldBound.xExtent = mergedWorldBound.yExtent = mergedWorldBound.zExtent = boundingVolume.radius;
					}
					first = false;
				} else {
					mergedWorldBound.merge(entity.meshRendererComponent.worldBound);
				}
			}
		});

		// if the whole hierarchy lacked mesh renderer components return
		// a tiny bounding box centered around the coordinates of the parent
		if (first) {
			var translation = entity.transformComponent.worldTransform.translation;
			mergedWorldBound = new BoundingBox(translation.clone(), 0.001, 0.001, 0.001);
		}

		return mergedWorldBound;
	};

	return EntityUtils;
})(goo.Scripts,goo.BoundingBox,goo.ObjectUtils);
goo.Manager = (function () {
	'use strict';

	/**
	 * Base class for managers.
	 */
	function Manager() {
		this.installedAPI = {};
	}

	Manager.prototype.applyAPI = function (worldBy) {
		var api = this.api;
		for (var key in api) {
			if (typeof worldBy[key] === 'undefined') {
				worldBy[key] = api[key];
				this.installedAPI[key] = true;
			} else {
				console.warn('Could not install method ' + key + ' of ' + this.type + ' as it is already taken');
			}
		}
	};

	return Manager;
})();
goo.EntityManager = (function (
	Manager,
	EntitySelection
) {
	'use strict';

	/**
	 * Main handler of all entities in the world.
	 * @extends Manager
	 */
	function EntityManager() {
		Manager.call(this);

		this.type = 'EntityManager';

		this._entitiesById = new Map();
		this._entitiesByIndex = new Map();
		this._entityCount = 0;

		/** Entity selector. Its methods return an {@link EntitySelection}. Can select by id or name, see examples for usage.
		 * <br><i>Injected into {@link World}.</i>
		 * @member by
		 * @memberOf EntityManager.prototype
		 * @example
		 * var byId = gooRunner.world.by.id("2b88941938444da8afab8205b1c80616.entity").first();
		 * var byName = gooRunner.world.by.name("Box").first();
		 */
		this.api = {
			id: function () {
				var ret = EntityManager.prototype.getEntityById.apply(this, arguments);
				return new EntitySelection(ret);
			}.bind(this),
			name: function (name) {
				var entities = this.getEntities();
				return new EntitySelection(entities.filter(function (entity) {
					return entity.name === name;
				}));
			}.bind(this)
		};
	}

	EntityManager.prototype = Object.create(Manager.prototype);

	EntityManager.prototype.added = function (entity) {
		if (!this.containsEntity(entity)) {
			this._entitiesById.set(entity.id, entity); //! AT: more entities can share the same id!
			// happens if you're loading the same entity more than once with the dynamic loader
			this._entitiesByIndex.set(entity._index, entity);
			this._entityCount++;
		}
	};

	EntityManager.prototype.removed = function (entity) {
		if (this.containsEntity(entity)) {
			this._entitiesById.delete(entity.id); //! AT: more entities can share the same id!
			// happens if you're loading the same entity more than once with the dynamic loader
			this._entitiesByIndex.delete(entity._index);
			this._entityCount--;
		}
	};

	/**
	 * Checks if an entity exists
	 *
	 * @param entity Entity to check for
	 * @returns {boolean} true if the entity exists
	 */
	EntityManager.prototype.containsEntity = function (entity) {
		return this._entitiesByIndex.has(entity._index);
	};

	/**
	 * Retrieve an entity based on an id
	 *
	 * @param id Id to retrieve entity for
	 * @returns Entity or undefined if not existing
	 */
	EntityManager.prototype.getEntityById = function (id) {
		return this._entitiesById.get(id); //! AT: more entities can share the same id!
		// happens if you're loading the same entity more than once with the dynamic loader
	};

	/**
	 * Retrieve an entity based on an index
	 *
	 * @param index Index to retrieve entity for
	 * @returns Entity or undefined if not existing
	 */
	EntityManager.prototype.getEntityByIndex = function (index) {
		return this._entitiesByIndex.get(index);
	};

	/**
	 * Retrieve an entity based on its name
	 *
	 * @param name Name to retrieve entity for
	 * @returns Entity or undefined if not existing
	 */
	EntityManager.prototype.getEntityByName = function (name) {
		if (this._entityCount <= 0) { return; }

		var foundEntity;
		this._entitiesByIndex.forEach(function (entity) {
			if (entity.name === name) {
				foundEntity = entity;
			}
		});

		return foundEntity;
	};

	/**
	 * Get the number of entities currently indexed by the Entity Manager
	 *
	 * @returns {number}
	 */
	EntityManager.prototype.size = function () {
		return this._entityCount;
	};

	/**
	 * Get all entities in the world
	 *
	 * @returns {Array} Array containing all entities in the world
	 */
	//! AT: this need to return an EntitySelection object
	EntityManager.prototype.getEntities = function () {
		var entities = [];

		this._entitiesByIndex.forEach(function (entity) {
			entities.push(entity);
		});

		return entities;
	};

	/**
	 * Get all entities on top level based on the transform scenegraph
	 *
	 * @returns {Array} Array containing all top entities
	 */
	EntityManager.prototype.getTopEntities = function () {
		var entities = [];

		this._entitiesByIndex.forEach(function (entity) {
			if (!entity.transformComponent || !entity.transformComponent.parent) {
				entities.push(entity);
			}
		});

		return entities;
	};

	/**
	 * Removes all entities
	 */
	EntityManager.prototype.clear = function () {
		this._entitiesById.clear();
		this._entitiesByIndex.clear();
		this._entityCount = 0;
	};

	return EntityManager;
})(goo.Manager,goo.EntitySelection);
goo.Matrix = (function (
	MathUtils,
	ObjectUtils
) {
	'use strict';

	/**
	 * Matrix with RxC components.
	 * @param {number} rows Number of rows.
	 * @param {number} cols Number of columns.
	 */
	function Matrix(rows, cols) {
		this.rows = rows || 0;
		this.cols = cols || 0;
		/** Column-major storage for the matrix components.
		 * @type {Float32Array}
		 */
		this.data = new Float32Array(this.rows * this.cols);
	}

	/**
	 * Binds aliases to the different matrix components.
	 * @hidden
	 * @param {Object} prototype The prototype to bind to.
	 * @param {Array<Array<string>>} aliases Array of component aliases for each component index.
	 */
	Matrix.setupAliases = function (prototype, aliases) {
		aliases.forEach(function (aliasesPerComponent, index) {
			aliasesPerComponent.forEach(function (alias) {
				Object.defineProperty(prototype, alias, {
					get: function () {
						return this.data[index];
					},
					set: function (value) {
						this.data[index] = value;
						// #ifdef DEBUG
						if (isNaN(this.data[index])) {
							throw new Error('Tried setting NaN to matrix component ' + alias);
						}
						// #endif
					}
				});
			});

			Object.defineProperty(prototype, index, {
				get: function () {
					return this.data[index];
				},
				set: function (value) {
					this.data[index] = value;
					// #ifdef DEBUG
					if (isNaN(this.data[index])) {
						throw new Error('Tried setting NaN to matrix component ' + index);
					}
					// #endif
				}
			});
		});
	};

	// #ifdef DEBUG
	/**
	 * Throws an error if any of the matrix's components are NaN
	 * @hidden
	 */
	Matrix.prototype.checkIntegrity = function () {
		for (var i = 0; i < this.data.length; i++) {
			if (isNaN(this.data[i])) {
				throw new Error('Matrix contains NaN at index ' + i);
			}
		}
	};

	/**
	 * Replaces the supplied method of object and wraps it in a integrity check
	 * @hidden
	 * @param {Object} object The object to attach the post-check to
	 * @param {string} methodName The name of the original method the check is attached to
	 */
	Matrix.addPostCheck = function (object, methodName) {
		var originalMethod = object[methodName];
		object[methodName] = function () {
			var ret = originalMethod.apply(this, arguments);
			if (typeof ret === 'number') {
				if (isNaN(ret)) {
					throw new Error('Matrix method ' + methodName + ' returned NaN');
				}
			}

			this.checkIntegrity();
			return ret;
		};
	};

	/**
	 * Adds more validators at once
	 * @hidden
	 * @param object
	 * @param {Array<string>} methodNames
	 */
	Matrix.addPostChecks = function (object, methodNames) {
		methodNames.forEach(Matrix.addPostCheck.bind(null, object));
	};
	// #endif

	// SHIM START
	/**
	 * Performs a component-wise addition.
	 * @param {Matrix} lhs Matrix on the left-hand side.
	 * @param {Matrix|number} rhs Matrix or scalar on the right-hand side.
	 * @param {Matrix} [target] Target matrix for storage.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */

	Matrix.add = ObjectUtils.warnOnce(
		'Matrix.add is deprecated. Use Matrix3.prototype.add, Matrix2.prototype.add or Matrix4.prototype.add instead.',
		function (lhs, rhs, target) {
			var rows = lhs.rows;
			var cols = lhs.cols;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			if (rhs instanceof Matrix) {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] + rhs.data[i];
				}
			} else {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] + rhs;
				}
			}

			return target;
		}
	);

	/**
	 * Performs a component-wise addition.
	 * @param {Matrix|number} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */
	Matrix.prototype.add = ObjectUtils.warnOnce(
		'Matrix.prototype.add is deprecated. Use Matrix3.prototype.add, Matrix2.prototype.add or Matrix4.prototype.add instead.',
		function (rhs) {
			return Matrix.add(this, rhs, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Performs a component-wise subtraction.
	 * @param {Matrix} lhs Matrix on the left-hand side.
	 * @param {Matrix|number} rhs Matrix or scalar on the right-hand side.
	 * @param {Matrix} [target] Target matrix for storage.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */

	Matrix.sub = ObjectUtils.warnOnce(
		'Matrix.sub is deprecated. Use Matrix3.prototype.sub, Matrix2.prototype.sub or Matrix4.prototype.sub instead.',
		function (lhs, rhs, target) {
			var rows = lhs.rows;
			var cols = lhs.cols;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			if (rhs instanceof Matrix) {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] - rhs.data[i];
				}
			} else {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] - rhs;
				}
			}

			return target;
		}
	);

	/**
	 * Performs a component-wise subtraction.
	 * @param {Matrix|number} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */
	Matrix.prototype.sub = ObjectUtils.warnOnce(
		'Matrix.prototype.sub is deprecated. Use Matrix3.prototype.sub, Matrix2.prototype.sub or Matrix4.prototype.sub instead.',
		function (rhs) {
			return Matrix.sub(this, rhs, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Performs a component-wise multiplication.
	 * @param {Matrix} lhs Matrix on the left-hand side.
	 * @param {Matrix|number} rhs Matrix or scalar on the right-hand side.
	 * @param {Matrix} [target] Target matrix for storage.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */

	Matrix.mul = ObjectUtils.warnOnce(
		'Matrix.mul is deprecated. Use Matrix3.prototype.mul, Matrix2.prototype.mul or Matrix4.prototype.mul instead.',
		function (lhs, rhs, target) {
			var rows = lhs.rows;
			var cols = lhs.cols;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			if (rhs instanceof Matrix) {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] * rhs.data[i];
				}
			} else {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] * rhs;
				}
			}

			return target;
		}
	);

	/**
	 * Performs a component-wise multiplication.
	 * @param {Matrix|number} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */

	Matrix.prototype.mul = ObjectUtils.warnOnce(
		'Matrix.prototype.mul is deprecated. Use Matrix3.prototype.mul, Matrix2.prototype.mul or Matrix4.prototype.mul instead.',
		function (rhs) {
			return Matrix.mul(this, rhs, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Performs a component-wise division.
	 * @param {Matrix} lhs Matrix on the left-hand side.
	 * @param {Matrix|number} rhs Matrix or scalar on the right-hand side.
	 * @param {Matrix} [target] Target matrix for storage.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */

	Matrix.div = ObjectUtils.warnOnce(
		'Matrix.div is deprecated. Use Matrix3.prototype.div, Matrix2.prototype.div or Matrix4.prototype.div instead.',
		function (lhs, rhs, target) {
			var rows = lhs.rows;
			var cols = lhs.cols;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			if (rhs instanceof Matrix) {
				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] / rhs.data[i];
				}
			} else {
				rhs = 1.0 / rhs;

				for (var i = 0; i < lhs.data.length; i++) {
					target.data[i] = lhs.data[i] * rhs;
				}
			}

			return target;
		}
	);

	/**
	 * Performs a component-wise division.
	 * @param {Matrix|number} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */

	Matrix.prototype.div = ObjectUtils.warnOnce(
		'Matrix.prototype.div is deprecated. Use Matrix3.prototype.div, Matrix2.prototype.div or Matrix4.prototype.div instead.',
		function (rhs) {
			return Matrix.div(this, rhs, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Combines two matrices (matrix multiplication) and stores the result in a separate matrix.
	 * @param {Matrix} lhs Matrix on the left-hand side.
	 * @param {Matrix} rhs Matrix on the right-hand side.
	 * @param {Matrix} [target] Target matrix for storage.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */
	Matrix.combine = ObjectUtils.warnOnce(
		'Matrix.combine is deprecated. Use Matrix2/3/4.prototype.mul or Matrix2/3/4.prototype.mul2 instead.',
		function (lhs, rhs, target) {
			var rows = lhs.rows;
			var cols = rhs.cols;
			var size = lhs.cols = rhs.rows;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			if (target === lhs || target === rhs) {
				return Matrix.copy(Matrix.combine(lhs, rhs), target);
			}

			for (var c = 0; c < cols; c++) {
				var o = c * rows;

				for (var r = 0; r < rows; r++) {
					var sum = 0.0;

					for (var i = 0; i < size; i++) {
						sum += lhs.data[i * lhs.rows + r] * rhs.data[c * rhs.rows + i];
					}

					target.data[o + r] = sum;
				}
			}

			return target;
		}
	);

	/**
	 * Combines two matrices (matrix multiplication) and stores the result locally.
	 * @param {Matrix} rhs Matrix on the right-hand side.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */

	Matrix.prototype.combine = ObjectUtils.warnOnce(
		'Matrix.prototype.combine is deprecated. Use Matrix2/3/4.prototype.mul or Matrix2/3/4.prototype.mul2 instead.',
		function (rhs) {
			return Matrix.combine(this, rhs, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Transposes a matrix (exchanges rows and columns) and stores the result in a separate matrix.
	 * @param {Matrix} source Source matrix.
	 * @param {Matrix} [target] Target matrix.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */

	Matrix.transpose = ObjectUtils.warnOnce(
		'Matrix.transpose is deprecated. Use Matrix2/3/4.prototype.transpose instead.',
		function (source, target) {
			var rows = source.cols;
			var cols = source.rows;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			if (target === source) {
				return Matrix.copy(Matrix.transpose(source), target);
			}

			for (var c = 0; c < cols; c++) {
				var o = c * rows;

				for (var r = 0; r < rows; r++) {
					target.data[o + r] = source.data[r * cols + c];
				}
			}

			return target;
		}
	);

	/**
	 * Transposes the matrix (exchanges rows and columns) and stores the result locally.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */

	Matrix.prototype.transpose = ObjectUtils.warnOnce(
		'Matrix.prototype.transpose is deprecated. Use Matrix2/3/4.prototype.transpose instead.',
		function () {
			return Matrix.transpose(this, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Copies component values and stores them in a separate matrix.
	 * @param {Matrix} source Source matrix.
	 * @param {Matrix} [target] Target matrix.
	 * @returns {Matrix} A new matrix if the target matrix is omitted, else the target matrix.
	 * @deprecated
	 */

	Matrix.copy = ObjectUtils.warnOnce(
		'Matrix.copy is deprecated. Use Matrix2/3/4.prototype.copy instead.',
		function (source, target) {
			var rows = source.rows;
			var cols = source.cols;

			if (!target) {
				target = new Matrix(rows, cols);
			}

			target.data.set(source.data);

			return target;
		}
	);

	/**
	 * Copies component values and stores them locally.
	 * @param {Matrix} source Source matrix.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */

	Matrix.prototype.copy = ObjectUtils.warnOnce(
		'Matrix.prototype.copy is deprecated. Use Matrix2/3/4.prototype.copy instead.',
		function (source) {
			return Matrix.copy(source, this);
		}
	);

	/* ====================================================================== */

	/**
	 * Compares two matrices for approximate equality.
	 * @param {Matrix} lhs Matrix on the left-hand side.
	 * @param {Matrix} rhs Matrix on the right-hand side.
	 * @returns {boolean} True if equal.
	 * @deprecated
	 */

	Matrix.equals = ObjectUtils.warnOnce(
		'Matrix.equals is deprecated. Use Matrix2/3/4.prototype.equals instead.',
		function (lhs, rhs) {
			if (lhs.rows !== rhs.rows || lhs.cols !== rhs.cols) {
				return false;
			}

			for (var i = 0; i < lhs.data.length; i++) {
				// why the backwards check? because otherwise if NaN is present in either lhs or rhs
				// then Math.abs(NaN) is NaN which is neither bigger or smaller than EPSILON
				// which never satisfies the condition
				// NaN is not close to NaN and we want to preserve that for matrices as well
				if (!(Math.abs(lhs.data[i] - rhs.data[i]) <= MathUtils.EPSILON)) {
					return false;
				}
			}

			return true;
		}
	);

	/**
	 * Compares two matrices for approximate equality.
	 * @param {Matrix} rhs Matrix on the right-hand side.
	 * @returns {boolean} True if equal.
	 * @deprecated
	 */

	Matrix.prototype.equals = ObjectUtils.warnOnce(
		'Matrix.prototype.equals is deprecated. Use Matrix2/3/4.prototype.equals instead.',
		function (rhs) {
			return Matrix.equals(this, rhs);
		}
	);

	/* ====================================================================== */

	/**
	 * Tests if the matrix is orthogonal.
	 * @returns {boolean} True if orthogonal.
	 * @deprecated
	 */

	Matrix.prototype.isOrthogonal = ObjectUtils.warnOnce(
		'Matrix.prototype.isOrthogonal is deprecated. Use Matrix2/3/4.prototype.isOrthogonal instead.',
		function () {
			for (var ca = 0; ca < this.cols; ca++) {
				for (var cb = ca + 1; cb < this.cols; cb++) {
					var oa = ca * this.rows;
					var ob = cb * this.rows;
					var sum = 0.0;

					for (var r = 0; r < this.rows; r++) {
						sum += this.data[oa + r] * this.data[ob + r];
					}

					if (Math.abs(sum) > MathUtils.EPSILON) {
						return false;
					}
				}
			}

			return true;
		}
	);

	/* ====================================================================== */

	/**
	 * Tests if the matrix is normal.
	 * @returns {boolean} True if normal.
	 * @deprecated
	 */

	Matrix.prototype.isNormal = ObjectUtils.warnOnce(
		'Matrix.prototype.isNormal is deprecated. Use Matrix2/3/4.prototype.isNormal instead.',
		function () {
			for (var c = 0; c < this.cols; c++) {
				var o = c * this.rows;
				var sum = 0.0;

				for (var r = 0; r < this.rows; r++) {
					sum += this.data[o + r] * this.data[o + r];
				}

				if (Math.abs(sum - 1.0) > MathUtils.EPSILON) {
					return false;
				}
			}

			return true;
		}
	);

	/* ====================================================================== */

	/**
	 * Tests if the matrix is orthonormal.
	 * @returns {boolean} True if orthonormal.
	 * @deprecated
	 */

	Matrix.prototype.isOrthonormal = ObjectUtils.warnOnce(
		'Matrix.prototype.isOrthonormal is deprecated. Use Matrix2/3/4.prototype.isOrthonormal instead.',
		function () {
			return this.isOrthogonal() && this.isNormal();
		}
	);

	/* ====================================================================== */

	/**
	 * Clones the matrix.
	 * @returns {Matrix} Clone of self.
	 * @deprecated
	 */

	Matrix.prototype.clone = ObjectUtils.warnOnce(
		'Matrix.prorotype.clone is deprecated. Use Matrix2/3/4.prototype.clone instead.',
		function () {
			return Matrix.copy(this);
		}
	);

	/* ====================================================================== */

	/**
	 * Sets the components of the matrix.
	 * @param {Matrix|number[]|...number} arguments Component values.
	 * @returns {Matrix} Self for chaining.
	 * @deprecated
	 */

	Matrix.prototype.set = ObjectUtils.warnOnce(
		'Matrix.prototype.set is deprecated. Use Matrix2/3/4.prototype.set instead.',
		function () {
			if (arguments.length === 1 && typeof arguments[0] === 'object') {
				if (arguments[0] instanceof Matrix) {
					this.copy(arguments[0]);
				} else {
					for (var i = 0; i < arguments[0].length; i++) {
						this.data[i] = arguments[0][i];
					}
				}
			} else {
				for (var i = 0; i < arguments.length; i++) {
					this.data[i] = arguments[i];
				}
			}

			return this;
		}
	);

	/**
	 * Converts the matrix into a string.
	 * @returns {string} String of component values.
	 * @deprecated
	 */

	Matrix.prototype.toString = ObjectUtils.warnOnce(
		'Matrix.prorotype.toString is deprecated.',
		function () {
			var string = '';

			for (var c = 0; c < this.cols; c++) {
				var offset = c * this.rows;

				string += '[';

				for (var r = 0; r < this.rows; r++) {
					string += this.data[offset + r];
					string += r !== this.rows - 1 ? ', ' : '';
				}

				string += c !== this.cols - 1 ? '], ' : ']';
			}

			return string;
		}
	);
	// SHIM END

	return Matrix;
})(goo.MathUtils,goo.ObjectUtils);
goo.Matrix3 = (function (
	MathUtils,
	Matrix,
	Vector3,
	ObjectUtils
) {
	'use strict';

	/**
	 * Matrix with 3x3 components. Used to store 3D rotations. It also contains common 3D Rotation operations.
	 * Creates a new Matrix3 by passing in either a current Matrix3, number Array, or a set of 9 numbers.
	 * @extends Matrix
	 * @param {(Matrix3|Array<number>|...number)} arguments Initial values for the components.
	 * @example
	 * // Passing in no arguments
	 * var m1 = new Matrix3(); // m1 == (1, 0, 0, 0, 1, 0, 0, 0, 1)
	 *
	 * // Passing in a number Array
	 * var m2 = new Matrix3([1, 0, 0, 0, 1, 0, 0, 0, 1]);
	 *
	 * // Passing in numbers
	 * var m3 = new Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1);
	 *
	 * // Passing in an existing Matrix3
	 * var m4 = new Matrix3(m1); // m4 == (1, 0, 0, 0, 1, 0, 0, 0, 1)
	 */
	function Matrix3() {
		Matrix.call(this, 3, 3);

		if (arguments.length === 0) {
			this.data[0] = 1;
			this.data[4] = 1;
			this.data[8] = 1;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Matrix3) {
				this.copy(arguments[0]);
			} else {
				this.setArray(arguments[0]);
			}
		} else {
			for (var i = 0; i < arguments.length; i++) {
				this.data[i] = arguments[i];
			}
		}

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	Matrix3._tempX = new Vector3();
	Matrix3._tempY = new Vector3();
	Matrix3._tempZ = new Vector3();

	Matrix3.prototype = Object.create(Matrix.prototype);
	Matrix3.prototype.constructor = Matrix3;

	Matrix.setupAliases(Matrix3.prototype, [['e00'], ['e10'], ['e20'], ['e01'], ['e11'], ['e21'], ['e02'], ['e12'], ['e22']]);

	/** @type {Matrix3} */
	Matrix3.IDENTITY = new Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1);

	/**
	 * Performs a component-wise addition.
	 * @param {Matrix3} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix3} Self to allow chaining
	 */
	Matrix3.prototype.add = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] += rhsData[0];
		thisData[1] += rhsData[1];
		thisData[2] += rhsData[2];
		thisData[3] += rhsData[3];
		thisData[4] += rhsData[4];
		thisData[5] += rhsData[5];
		thisData[6] += rhsData[6];
		thisData[7] += rhsData[7];
		thisData[8] += rhsData[8];

		return this;
	};

	/**
	 * Performs a component-wise subtraction.
	 * @param {Matrix3} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix3} Self to allow chaining
	 */
	Matrix3.prototype.sub = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] -= rhsData[0];
		thisData[1] -= rhsData[1];
		thisData[2] -= rhsData[2];
		thisData[3] -= rhsData[3];
		thisData[4] -= rhsData[4];
		thisData[5] -= rhsData[5];
		thisData[6] -= rhsData[6];
		thisData[7] -= rhsData[7];
		thisData[8] -= rhsData[8];

		return this;
	};

	/**
	 * Multiplies this matrix with a scalar
	 * @param {number} scalar
	 * @returns {Matrix3} Self to allow chaining
	 */
	Matrix3.prototype.scale = function (scalar) {
		var data = this.data;

		data[0] *= scalar;
		data[1] *= scalar;
		data[2] *= scalar;
		data[3] *= scalar;
		data[4] *= scalar;
		data[5] *= scalar;
		data[6] *= scalar;
		data[7] *= scalar;
		data[8] *= scalar;

		return this;
	};

	/**
	 * Multiplies this matrix with another matrix
	 * @param {Matrix3} rhs Matrix on the left-hand side
	 * @returns {Matrix3} Self to allow chaining
	 */
	Matrix3.prototype.mul = function (rhs) {
		var s1d = rhs.data;
		var m00 = s1d[0], m01 = s1d[3], m02 = s1d[6],
			m10 = s1d[1], m11 = s1d[4], m12 = s1d[7],
			m20 = s1d[2], m21 = s1d[5], m22 = s1d[8];

		var s2d = this.data;
		var n00 = s2d[0], n01 = s2d[3], n02 = s2d[6],
			n10 = s2d[1], n11 = s2d[4], n12 = s2d[7],
			n20 = s2d[2], n21 = s2d[5], n22 = s2d[8];

		var rd = this.data;
		rd[0] = m00 * n00 + m01 * n10 + m02 * n20;
		rd[3] = m00 * n01 + m01 * n11 + m02 * n21;
		rd[6] = m00 * n02 + m01 * n12 + m02 * n22;

		rd[1] = m10 * n00 + m11 * n10 + m12 * n20;
		rd[4] = m10 * n01 + m11 * n11 + m12 * n21;
		rd[7] = m10 * n02 + m11 * n12 + m12 * n22;

		rd[2] = m20 * n00 + m21 * n10 + m22 * n20;
		rd[5] = m20 * n01 + m21 * n11 + m22 * n21;
		rd[8] = m20 * n02 + m21 * n12 + m22 * n22;

		return this;
	};

	/**
	 * Multiplies two matrices and stores the result in this matrix
	 * @param {Matrix3} lhs Matrix on the left-hand side
	 * @param {Matrix3} rhs Matrix on the right-hand side
	 * @returns {Matrix3} Self to allow chaining
	 */
	Matrix3.prototype.mul2 = function (lhs, rhs) {
		var s1d = lhs.data;
		var m00 = s1d[0], m01 = s1d[3], m02 = s1d[6],
			m10 = s1d[1], m11 = s1d[4], m12 = s1d[7],
			m20 = s1d[2], m21 = s1d[5], m22 = s1d[8];
		var s2d = rhs.data;
		var n00 = s2d[0], n01 = s2d[3], n02 = s2d[6],
			n10 = s2d[1], n11 = s2d[4], n12 = s2d[7],
			n20 = s2d[2], n21 = s2d[5], n22 = s2d[8];

		var rd = this.data;
		rd[0] = m00 * n00 + m01 * n10 + m02 * n20;
		rd[3] = m00 * n01 + m01 * n11 + m02 * n21;
		rd[6] = m00 * n02 + m01 * n12 + m02 * n22;

		rd[1] = m10 * n00 + m11 * n10 + m12 * n20;
		rd[4] = m10 * n01 + m11 * n11 + m12 * n21;
		rd[7] = m10 * n02 + m11 * n12 + m12 * n22;

		rd[2] = m20 * n00 + m21 * n10 + m22 * n20;
		rd[5] = m20 * n01 + m21 * n11 + m22 * n21;
		rd[8] = m20 * n02 + m21 * n12 + m22 * n22;

		return this;
	};

	/**
	 * Transposes a matrix (exchanges rows and columns) and stores the result in a separate matrix.
	 * @returns {Matrix3} A new matrix if the target matrix is omitted, else the target matrix.
	 */
	Matrix3.prototype.transpose = function () {
		var data = this.data;

		var e01 = data[3];
		var e02 = data[6];
		var e12 = data[7];

		data[3] = data[1];
		data[6] = data[2];
		data[7] = data[5];

		data[1] = e01;
		data[2] = e02;
		data[5] = e12;

		return this;
	};

	/**
	 * Computes the analytical inverse and stores the result in a separate matrix.
	 * @param {Matrix3} source Source matrix.
	 * @param {Matrix3} [target] Target matrix.
	 * @returns {Matrix3} A new matrix if the target matrix is omitted, else the target matrix.
	 */
	Matrix3.invert = function (source, target) {
		if (!target) {
			target = new Matrix3();
		}

		if (target === source) {
			return target.copy(Matrix3.invert(source));
		}

		var det = source.determinant();

		if (Math.abs(det) < MathUtils.EPSILON) {
			return target;
		}

		det = 1.0 / det;
		var td = target.data, sd = source.data;

		td[0] = (sd[4] * sd[8] - sd[7] * sd[5]) * det;
		td[1] = (sd[7] * sd[2] - sd[1] * sd[8]) * det;
		td[2] = (sd[1] * sd[5] - sd[4] * sd[2]) * det;

		td[3] = (sd[6] * sd[5] - sd[3] * sd[8]) * det;
		td[4] = (sd[0] * sd[8] - sd[6] * sd[2]) * det;
		td[5] = (sd[3] * sd[2] - sd[0] * sd[5]) * det;

		td[6] = (sd[3] * sd[7] - sd[6] * sd[4]) * det;
		td[7] = (sd[6] * sd[1] - sd[0] * sd[7]) * det;
		td[8] = (sd[0] * sd[4] - sd[3] * sd[1]) * det;

		return target;
	};

	/**
	 * Computes the analytical inverse and stores the result locally.
	 * @returns {Matrix3} Self for chaining.
	 */
	Matrix3.prototype.invert = function () {
		return Matrix3.invert(this, this);
	};

	/**
	 * Tests if the matrix is orthogonal.
	 * @returns {Boolean} True if orthogonal.
	 */
	Matrix3.prototype.isOrthogonal = function () {
		var d = this.data;

		var dot = d[0] * d[3] + d[1] * d[4] + d[2] * d[5];

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = d[0] * d[6] + d[1] * d[7] + d[2] * d[8];

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = d[3] * d[6] + d[4] * d[7] + d[5] * d[8];

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		return true;
	};

	/**
	 * Tests if the matrix is normal.
	 * @returns {boolean} True if normal.
	 */
	Matrix3.prototype.isNormal = function () {
		var d = this.data;

		var l = d[0] * d[0] + d[1] * d[1] + d[2] * d[2];

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		l = d[3] * d[3] + d[4] * d[4] + d[5] * d[5];

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		l = d[6] * d[6] + d[7] * d[7] + d[8] * d[8];

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		return true;
	};

	/**
	 * Tests if the matrix is orthonormal.
	 * @returns {boolean} True if orthonormal.
	 */
	Matrix3.prototype.isOrthonormal = function () {
		return this.isOrthogonal() && this.isNormal();
	};

	/**
	 * Computes the determinant of the matrix.
	 * @returns {number} Determinant of matrix.
	 */
	Matrix3.prototype.determinant = function () {
		var d = this.data;
		return d[0] * (d[4] * d[8] - d[7] * d[5]) -
			d[3] * (d[1] * d[8] - d[7] * d[2]) +
			d[6] * (d[1] * d[5] - d[4] * d[2]);
	};

	/**
	 * Sets the matrix to identity: (1, 0, 0, 0, 1, 0, 0, 0, 1).
	 * @returns {Matrix3} Self for chaining.
	 */
	Matrix3.prototype.setIdentity = function () {
		var d = this.data;

		d[0] = 1;
		d[1] = 0;
		d[2] = 0;

		d[3] = 0;
		d[4] = 1;
		d[5] = 0;

		d[6] = 0;
		d[7] = 0;
		d[8] = 1;

		return this;
	};

	// unused
	/**
	 * Post-multiplies the matrix ("before") with a scaling vector.
	 * @param {Vector3} vec Vector on the right-hand side.
	 * @param {Matrix3} result Storage matrix.
	 * @returns {Matrix3} Storage matrix.
	 */
	Matrix3.prototype.multiplyDiagonalPost = function (vec, result) {
		var x = vec.x;
		var y = vec.y;
		var z = vec.z;

		var d = this.data;
		var r = result.data;
		r[0] = x * d[0];
		r[1] = x * d[1];
		r[2] = x * d[2];
		r[3] = y * d[3];
		r[4] = y * d[4];
		r[5] = y * d[5];
		r[6] = z * d[6];
		r[7] = z * d[7];
		r[8] = z * d[8];

		return result;
	};

	/**
	 * Sets the Matrix3 from rotational angles in radians.
	 * @param {number} pitch Pitch (X axis) angle in radians.
	 * @param {number} yaw Yaw (Y axis) angle in radians.
	 * @param {number} roll Roll (Z axis) angle in radians.
	 * @returns {Matrix3} Self for chaining.
	 * @example
	 * // sets the rotation to Math.PI (180 degrees) on the Y axis
	 * entity.transformComponent.transform.rotation.fromAngles(0, Math.PI, 0);
	 */
	Matrix3.prototype.fromAngles = function (pitch, yaw, roll) {
		var cy = Math.cos(pitch);
		var sy = Math.sin(pitch);
		var ch = Math.cos(yaw);
		var sh = Math.sin(yaw);
		var cp = Math.cos(roll);
		var sp = Math.sin(roll);

		var d = this.data;
		d[0] = ch * cp;
		d[3] = sh * sy - ch * sp * cy;
		d[6] = ch * sp * sy + sh * cy;
		d[1] = sp;
		d[4] = cp * cy;
		d[7] = -cp * sy;
		d[2] = -sh * cp;
		d[5] = sh * sp * cy + ch * sy;
		d[8] = -sh * sp * sy + ch * cy;

		return this;
	};

	/**
	 * Rotates a Matrix3 by the given angle in radians, around the X axis.
	 *
	 * @param {number} rad the angle in radians to rotate the Matrix3 by.
	 * @param {Matrix3} [store] the target Matrix3 to store the result or 'this', if undefined.
	 * @returns {Matrix3} store
	 * @example
	 * // rotates the entity on the X axis, by the amount of time per frame (tpf)
	 * entity.transformComponent.transform.rotation.rotateX(goo.world.tpf);
	 */
	Matrix3.prototype.rotateX = function (rad, store) {
		store = store || this;
		var a = this.data;
		var out = store.data;

		var s = Math.sin(rad),
			c = Math.cos(rad),
			a10 = a[3],
			a11 = a[4],
			a12 = a[5],
			a20 = a[6],
			a21 = a[7],
			a22 = a[8];

		if (a !== out) { // If the source and destination differ, copy the unchanged rows
			out[0] = a[0];
			out[1] = a[1];
			out[2] = a[2];
		}

		// Perform axis-specific matrix multiplication
		out[3] = a10 * c + a20 * s;
		out[4] = a11 * c + a21 * s;
		out[5] = a12 * c + a22 * s;
		out[6] = a20 * c - a10 * s;
		out[7] = a21 * c - a11 * s;
		out[8] = a22 * c - a12 * s;

		return store;
	};

	/**
	 * Rotates a Matrix3 by the given angle in radians, around the Y axis.
	 *
	 * @param {number} rad the angle in radians to rotate the Matrix3 by.
	 * @param {Matrix3} [store] the target Matrix3 to store the result or 'this', if undefined.
	 * @returns {Matrix3} store
	 * @example
	 * // rotates the entity on the Y axis, by Math.PI * 0.5 (90 degrees)
	 * entity.transformComponent.transform.rotation.rotateY(Math.PI * 0.5);
	 */
	Matrix3.prototype.rotateY = function (rad, store) {
		store = store || this;
		var a = this.data;
		var out = store.data;

		var s = Math.sin(rad),
			c = Math.cos(rad),
			a00 = a[0],
			a01 = a[1],
			a02 = a[2],
			a20 = a[6],
			a21 = a[7],
			a22 = a[8];

		if (a !== out) { // If the source and destination differ, copy the unchanged rows
			out[3] = a[3];
			out[4] = a[4];
			out[5] = a[5];
		}

		// Perform axis-specific matrix multiplication
		out[0] = a00 * c - a20 * s;
		out[1] = a01 * c - a21 * s;
		out[2] = a02 * c - a22 * s;
		out[6] = a00 * s + a20 * c;
		out[7] = a01 * s + a21 * c;
		out[8] = a02 * s + a22 * c;

		return store;
	};

	/**
	 * Rotates a Matrix3 by the given angle in radians, around the Z axis.
	 *
	 * @param {number} rad the angle in radians to rotate the Matrix3 by.
	 * @param {Matrix3} [store] the target Matrix3 to store the result or 'this', if undefined.
	 * @returns {Matrix3} store
	 * @example
	 * // rotates the entity on the Z axis, by 3.14 (180 degrees)
	 * entity.transformComponent.transform.rotation.rotateZ(3.14);
	 */
	Matrix3.prototype.rotateZ = function (rad, store) {
		store = store || this;
		var a = this.data;
		var out = store.data;

		var s = Math.sin(rad),
			c = Math.cos(rad),
			a00 = a[0],
			a01 = a[1],
			a02 = a[2],
			a10 = a[3],
			a11 = a[4],
			a12 = a[5];

		if (a !== out) { // If the source and destination differ, copy the unchanged last row
			out[6] = a[6];
			out[7] = a[7];
			out[8] = a[8];
		}

		// Perform axis-specific matrix multiplication
		out[0] = a00 * c + a10 * s;
		out[1] = a01 * c + a11 * s;
		out[2] = a02 * c + a12 * s;
		out[3] = a10 * c - a00 * s;
		out[4] = a11 * c - a01 * s;
		out[5] = a12 * c - a02 * s;

		return store;
	};

	/**
	 * Converts the current Matrix3 to Euler rotation angles in radians: (X axis, Y axis, Z axis)
	 * @param {Vector3} Vector3 to store the computed angles in (or undefined to create a new one).
	 * @returns {Vector3} Result
	 * @example
	 * // Not passing in a Vector3 to store the result, one is created and returned
	 * var rot = entity.transformComponent.transform.rotation.toAngles();
	 *
	 * // Passing in an existing Vector3 to store the result
	 * var angles = new Vector3();
	 * entity.transformComponent.transform.rotation.toAngles(angles);
	 */
	Matrix3.prototype.toAngles = function (store) {
		var result = store;
		if (!result) {
			result = new Vector3();
		}

		var d = this.data;
		if (d[3] > 1 - MathUtils.EPSILON) { // singularity at north pole
			result.y = Math.atan2(d[2], d[8]);
			result.z = Math.PI / 2;
			result.x = 0;
		} else if (d[3] < -1 + MathUtils.EPSILON) { // singularity at south pole
			result.y = Math.atan2(d[2], d[8]);
			result.z = -Math.PI / 2;
			result.x = 0;
		} else {
			result.y = Math.atan2(-d[2], d[0]);
			result.x = Math.atan2(-d[7], d[4]);
			result.z = Math.asin(d[1]);
		}

		return result;
	};

	/**
	 * Sets this matrix to the rotation indicated by the given angle and a unit-length axis of rotation.
	 * @param {number} angle the angle to rotate (in radians).
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Matrix3} this for chaining
	 */
	Matrix3.prototype.fromAngleNormalAxis = function (angle, x, y, z) {
		var fCos = Math.cos(angle);
		var fSin = Math.sin(angle);
		var fOneMinusCos = 1.0 - fCos;
		var fX2 = x * x;
		var fY2 = y * y;
		var fZ2 = z * z;
		var fXYM = x * y * fOneMinusCos;
		var fXZM = x * z * fOneMinusCos;
		var fYZM = y * z * fOneMinusCos;
		var fXSin = x * fSin;
		var fYSin = y * fSin;
		var fZSin = z * fSin;

		var d = this.data;
		d[0] = fX2 * fOneMinusCos + fCos;
		d[3] = fXYM - fZSin;
		d[6] = fXZM + fYSin;
		d[1] = fXYM + fZSin;
		d[4] = fY2 * fOneMinusCos + fCos;
		d[7] = fYZM - fXSin;
		d[2] = fXZM - fYSin;
		d[5] = fYZM + fXSin;
		d[8] = fZ2 * fOneMinusCos + fCos;

		return this;
	};

	/**
	 * Sets the Matrix3 to look in a specific direction.
	 * @param {Vector3} direction Direction vector.
	 * @param {Vector3} up Up vector.
	 * @returns {Matrix3} Self for chaining.
	 * @example
	 * // get the direction from the current entity to the 'other' entity
	 * var direction = Vector3.sub(other.transformComponent.transform.translation, entity.transformComponent.transform.translation);
	 * // pass in the direction, and use Vector3.UNIT_Y as 'up'
	 * entity.lookAt(direction, Vector3.UNIT_Y);
	 * // update the transform component with the new rotation
	 * entity.transformComponent.setUpdated();
	 */
	Matrix3.prototype.lookAt = function (direction, up) {
		var x = Matrix3._tempX, y = Matrix3._tempY, z = Matrix3._tempZ;

		z.set(direction).normalize().scale(-1);

		x.set(up).cross(z).normalize();

		if (x.equals(Vector3.ZERO)) {
			if (z.x !== 0.0) {
				x.setDirect(z.y, -z.x, 0);
			} else {
				x.setDirect(0, z.z, -z.y);
			}
		}

		y.set(z).cross(x);

		var d = this.data;
		d[0] = x.x;
		d[1] = x.y;
		d[2] = x.z;
		d[3] = y.x;
		d[4] = y.y;
		d[5] = y.z;
		d[6] = z.x;
		d[7] = z.y;
		d[8] = z.z;

		return this;
	};

	/**
	 * Sets the matrix from a quaternion.
	 * @param {Quaternion} quaternion Rotational quaternion.
	 * @returns {Matrix3} Self for chaining.
	 */
	Matrix3.prototype.copyQuaternion = function (quaternion) {
		return quaternion.toRotationMatrix(this);
	};

	/**
	 * Compares two matrices for approximate equality
	 * @param {Matrix3} rhs The matrix to compare against
	 * @returns {boolean}
	 */
	Matrix3.prototype.equals = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		return (Math.abs(thisData[0] - rhsData[0]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[1] - rhsData[1]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[2] - rhsData[2]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[3] - rhsData[3]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[4] - rhsData[4]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[5] - rhsData[5]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[6] - rhsData[6]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[7] - rhsData[7]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[8] - rhsData[8]) <= MathUtils.EPSILON);
	};

	/**
	 * Copies component values and stores them locally.
	 * @param {Matrix3} rhs Source matrix.
	 * @returns {Matrix3} Self for chaining.
	 */
	Matrix3.prototype.copy = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[3];
		thisData[4] = rhsData[4];
		thisData[5] = rhsData[5];
		thisData[6] = rhsData[6];
		thisData[7] = rhsData[7];
		thisData[8] = rhsData[8];

		return this;
	};

	/**
	 * Copies component values from the upper-left submatrix of a Matrix4.
	 * @param {Matrix4} rhs Source matrix.
	 * @returns {Matrix3} Self for chaining.
	 */
	Matrix3.prototype.copyMatrix4 = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[4];
		thisData[4] = rhsData[5];
		thisData[5] = rhsData[6];
		thisData[6] = rhsData[8];
		thisData[7] = rhsData[9];
		thisData[8] = rhsData[10];

		return this;
	};

	/**
	 * Sets matrix values from an array.
	 * @param {Array<number>} rhsData Array source
	 * @returns {Matrix3} Self for chaining.
	 */
	Matrix3.prototype.setArray = function (rhsData) {
		var thisData = this.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[3];
		thisData[4] = rhsData[4];
		thisData[5] = rhsData[5];
		thisData[6] = rhsData[6];
		thisData[7] = rhsData[7];
		thisData[8] = rhsData[8];

		return this;
	};

	/**
	 * Sets the matrix's values from another matrix's values; an alias for .copy
	 * @param {Matrix3} source Source matrix
	 * @returns {Matrix3} Self to allow chaining
	 */
	Matrix3.prototype.set = Matrix3.prototype.copy;

	/**
	 * Returns a new matrix with the same values as the existing one.
	 * @returns {Matrix3} The new matrix.
	 */
	Matrix3.prototype.clone = function () {
		return new Matrix3().copy(this);
	};


	// SHIM START

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.add = ObjectUtils.warnOnce(
		'Matrix3.add is deprecated - use Matrix3.prototype.add instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix3();
			}

			var td = target.data, ld = lhs.data;
			if (rhs instanceof Matrix3) {
				var rd = rhs.data;
				td[0] = ld[0] + rd[0];
				td[1] = ld[1] + rd[1];
				td[2] = ld[2] + rd[2];
				td[3] = ld[3] + rd[3];
				td[4] = ld[4] + rd[4];
				td[5] = ld[5] + rd[5];
				td[6] = ld[6] + rd[6];
				td[7] = ld[7] + rd[7];
				td[8] = ld[8] + rd[8];
			} else {
				td[0] = ld[0] + rhs;
				td[1] = ld[1] + rhs;
				td[2] = ld[2] + rhs;
				td[3] = ld[3] + rhs;
				td[4] = ld[4] + rhs;
				td[5] = ld[5] + rhs;
				td[6] = ld[6] + rhs;
				td[7] = ld[7] + rhs;
				td[8] = ld[8] + rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.sub = ObjectUtils.warnOnce(
		'Matrix3.sub is deprecated - use Matrix3.prototype.sub instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix3();
			}

			var td = target.data, ld = lhs.data;
			if (rhs instanceof Matrix3) {
				var rd = rhs.data;
				td[0] = ld[0] - rd[0];
				td[1] = ld[1] - rd[1];
				td[2] = ld[2] - rd[2];
				td[3] = ld[3] - rd[3];
				td[4] = ld[4] - rd[4];
				td[5] = ld[5] - rd[5];
				td[6] = ld[6] - rd[6];
				td[7] = ld[7] - rd[7];
				td[8] = ld[8] - rd[8];
			} else {
				td[0] = ld[0] - rhs;
				td[1] = ld[1] - rhs;
				td[2] = ld[2] - rhs;
				td[3] = ld[3] - rhs;
				td[4] = ld[4] - rhs;
				td[5] = ld[5] - rhs;
				td[6] = ld[6] - rhs;
				td[7] = ld[7] - rhs;
				td[8] = ld[8] - rhs;
			}

			return target;
		}
	);
	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.mul = ObjectUtils.warnOnce(
		'Matrix3.mul is deprecated - use Matrix3.prototype.mul instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix3();
			}

			var td = target.data, ld = lhs.data;
			if (rhs instanceof Matrix3) {
				var rd = rhs.data;
				td[0] = ld[0] * rd[0];
				td[1] = ld[1] * rd[1];
				td[2] = ld[2] * rd[2];
				td[3] = ld[3] * rd[3];
				td[4] = ld[4] * rd[4];
				td[5] = ld[5] * rd[5];
				td[6] = ld[6] * rd[6];
				td[7] = ld[7] * rd[7];
				td[8] = ld[8] * rd[8];
			} else {
				td[0] = ld[0] * rhs;
				td[1] = ld[1] * rhs;
				td[2] = ld[2] * rhs;
				td[3] = ld[3] * rhs;
				td[4] = ld[4] * rhs;
				td[5] = ld[5] * rhs;
				td[6] = ld[6] * rhs;
				td[7] = ld[7] * rhs;
				td[8] = ld[8] * rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.div = ObjectUtils.warnOnce(
		'Matrix3.div is deprecated - use Matrix3.prototype.div instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix3();
			}

			var td = target.data, ld = lhs.data;
			if (rhs instanceof Matrix3) {
				var rd = rhs.data;
				td[0] = ld[0] / rd[0];
				td[1] = ld[1] / rd[1];
				td[2] = ld[2] / rd[2];
				td[3] = ld[3] / rd[3];
				td[4] = ld[4] / rd[4];
				td[5] = ld[5] / rd[5];
				td[6] = ld[6] / rd[6];
				td[7] = ld[7] / rd[7];
				td[8] = ld[8] / rd[8];
			} else {
				td[0] = ld[0] / rhs;
				td[1] = ld[1] / rhs;
				td[2] = ld[2] / rhs;
				td[3] = ld[3] / rhs;
				td[4] = ld[4] / rhs;
				td[5] = ld[5] / rhs;
				td[6] = ld[6] / rhs;
				td[7] = ld[7] / rhs;
				td[8] = ld[8] / rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.prototype.div = ObjectUtils.warnOnce(
		'Matrix3.prototype.div is deprecated.',
		function (rhs) {
			return Matrix3.div(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.combine = ObjectUtils.warnOnce(
		'Matrix3.combine is deprecated - use Matrix3.prototype.mul or .mul2 instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix3();
			}

			var s1d = lhs.data;
			var m00 = s1d[0], m01 = s1d[3], m02 = s1d[6],
				m10 = s1d[1], m11 = s1d[4], m12 = s1d[7],
				m20 = s1d[2], m21 = s1d[5], m22 = s1d[8];
			var s2d = rhs.data;
			var n00 = s2d[0], n01 = s2d[3], n02 = s2d[6],
				n10 = s2d[1], n11 = s2d[4], n12 = s2d[7],
				n20 = s2d[2], n21 = s2d[5], n22 = s2d[8];

			var rd = target.data;
			rd[0] = m00 * n00 + m01 * n10 + m02 * n20;
			rd[3] = m00 * n01 + m01 * n11 + m02 * n21;
			rd[6] = m00 * n02 + m01 * n12 + m02 * n22;

			rd[1] = m10 * n00 + m11 * n10 + m12 * n20;
			rd[4] = m10 * n01 + m11 * n11 + m12 * n21;
			rd[7] = m10 * n02 + m11 * n12 + m12 * n22;

			rd[2] = m20 * n00 + m21 * n10 + m22 * n20;
			rd[5] = m20 * n01 + m21 * n11 + m22 * n21;
			rd[8] = m20 * n02 + m21 * n12 + m22 * n22;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.prototype.combine = ObjectUtils.warnOnce(
		'Matrix3.prototype.combine is deprecated - use Matrix3.prototype.mul or .mul2 instead.',
		function (rhs) {
			return Matrix3.combine(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.transpose = ObjectUtils.warnOnce(
		'Matrix3.transpose is deprecated - use Matrix3.prototype.transpose instead.',
		function (source, target) {
			if (!target) {
				target = new Matrix3();
			}

			var s = source.data;
			var t = target.data;

			if (target === source) {
				var e01 = s[3];
				var e02 = s[6];
				var e12 = s[7];

				t[3] = s[1];
				t[6] = s[2];
				t[7] = s[5];

				t[1] = e01;
				t[2] = e02;
				t[5] = e12;

				return target;
			}

			t[0] = s[0];
			t[1] = s[3];
			t[2] = s[6];
			t[3] = s[1];
			t[4] = s[4];
			t[5] = s[7];
			t[6] = s[2];
			t[7] = s[5];
			t[8] = s[8];

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.prototype.applyPost = ObjectUtils.warnOnce(
		'Matrix3.prototype.applyPost is deprecated - use Vector3.prototype.applyPost instead.',
		function (rhs) {
			var source = this.data;

			var x = rhs.x;
			var y = rhs.y;
			var z = rhs.z;

			rhs.x = source[0] * x + source[3] * y + source[6] * z;
			rhs.y = source[1] * x + source[4] * y + source[7] * z;
			rhs.z = source[2] * x + source[5] * y + source[8] * z;

			return rhs;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix3.prototype.applyPre = ObjectUtils.warnOnce(
		'Matrix3.prototype.applyPre is deprecated - use Vector3.prototype.applyPre instead.',
		function (rhs) {
			var source = this.data;

			var x = rhs.x;
			var y = rhs.y;
			var z = rhs.z;

			rhs.x = source[0] * x + source[1] * y + source[2] * z;
			rhs.y = source[3] * x + source[4] * y + source[5] * z;
			rhs.z = source[6] * x + source[7] * y + source[8] * z;

			return rhs;
		}
	);
	// SHIM END

	// #ifdef DEBUG
	Matrix.addPostChecks(Matrix3.prototype, [
		'add', 'sub', 'scale', 'transpose', 'invert',
		'isOrthogonal', 'determinant',
		'fromAngles', 'rotateX', 'rotateY', 'rotateZ', 'fromAngleNormalAxis', 'lookAt',
		'copyQuaternion', 'copy'
	]);
	// #endif

	return Matrix3;
})(goo.MathUtils,goo.Matrix,goo.Vector3,goo.ObjectUtils);
goo.Matrix4 = (function (
	MathUtils,
	Matrix,
	ObjectUtils
) {
	'use strict';

	/**
	 * Matrix with 4x4 components.
	 * @extends Matrix
	 * @param {(Matrix4|Array<number>)} arguments Initial values for the components.
	 */
	function Matrix4() {
		Matrix.call(this, 4, 4);

		if (arguments.length === 0) {
			this.data[0] = 1;
			this.data[5] = 1;
			this.data[10] = 1;
			this.data[15] = 1;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Matrix4) {
				this.copy(arguments[0]);
			} else {
				this.setArray(arguments[0]);
			}
		} else {
			for (var i = 0; i < arguments.length; i++) {
				this.data[i] = arguments[i];
			}
		}

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	Matrix4.prototype = Object.create(Matrix.prototype);
	Matrix4.prototype.constructor = Matrix4;

	Matrix.setupAliases(Matrix4.prototype, [['e00'], ['e10'], ['e20'], ['e30'], ['e01'], ['e11'], ['e21'], ['e31'], ['e02'], ['e12'], ['e22'], ['e32'], ['e03'], ['e13'], ['e23'], ['e33']]);

	Matrix4.IDENTITY = new Matrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

	/**
	 * Performs a component-wise addition.
	 * @param {Matrix4} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix4} Self to allow chaining.
	 */
	Matrix4.prototype.add = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] += rhsData[0];
		thisData[1] += rhsData[1];
		thisData[2] += rhsData[2];
		thisData[3] += rhsData[3];
		thisData[4] += rhsData[4];
		thisData[5] += rhsData[5];
		thisData[6] += rhsData[6];
		thisData[7] += rhsData[7];
		thisData[8] += rhsData[8];
		thisData[9] += rhsData[9];
		thisData[10] += rhsData[10];
		thisData[11] += rhsData[11];
		thisData[12] += rhsData[12];
		thisData[13] += rhsData[13];
		thisData[14] += rhsData[14];
		thisData[15] += rhsData[15];

		return this;
	};

	/**
	 * Performs a component-wise subtraction.
	 * @param {Matrix4} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix4} Self to allow chaining
	 */
	Matrix4.prototype.sub = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] -= rhsData[0];
		thisData[1] -= rhsData[1];
		thisData[2] -= rhsData[2];
		thisData[3] -= rhsData[3];
		thisData[4] -= rhsData[4];
		thisData[5] -= rhsData[5];
		thisData[6] -= rhsData[6];
		thisData[7] -= rhsData[7];
		thisData[8] -= rhsData[8];
		thisData[9] -= rhsData[9];
		thisData[10] -= rhsData[10];
		thisData[11] -= rhsData[11];
		thisData[12] -= rhsData[12];
		thisData[13] -= rhsData[13];
		thisData[14] -= rhsData[14];
		thisData[15] -= rhsData[15];

		return this;
	};

	/**
	 * Multiplies this matrix with a scalar
	 * @param {number} scalar
	 * @returns {Matrix4} Self to allow chaining
	 */
	Matrix4.prototype.scale = function (scalar) {
		var data = this.data;

		data[0] *= scalar;
		data[1] *= scalar;
		data[2] *= scalar;
		data[3] *= scalar;
		data[4] *= scalar;
		data[5] *= scalar;
		data[6] *= scalar;
		data[7] *= scalar;
		data[8] *= scalar;
		data[9] *= scalar;
		data[10] *= scalar;
		data[11] *= scalar;
		data[12] *= scalar;
		data[13] *= scalar;
		data[14] *= scalar;
		data[15] *= scalar;

		return this;
	};

	/**
	 * Multiplies this matrix with another matrix
	 * @param {Matrix4} rhs Matrix on the left-hand side
	 * @returns {Matrix4} Self to allow chaining
	 */
	Matrix4.prototype.mul = function (rhs) {
		var s1d = this.data;
		var m00 = s1d[0], m01 = s1d[4], m02 = s1d[8], m03 = s1d[12],
			m10 = s1d[1], m11 = s1d[5], m12 = s1d[9], m13 = s1d[13],
			m20 = s1d[2], m21 = s1d[6], m22 = s1d[10], m23 = s1d[14],
			m30 = s1d[3], m31 = s1d[7], m32 = s1d[11], m33 = s1d[15];
		var s2d = rhs.data;
		var n00 = s2d[0], n01 = s2d[4], n02 = s2d[8], n03 = s2d[12],
			n10 = s2d[1], n11 = s2d[5], n12 = s2d[9], n13 = s2d[13],
			n20 = s2d[2], n21 = s2d[6], n22 = s2d[10], n23 = s2d[14],
			n30 = s2d[3], n31 = s2d[7], n32 = s2d[11], n33 = s2d[15];

		var rd = this.data;
		rd[0] = m00 * n00 + m01 * n10 + m02 * n20 + m03 * n30;
		rd[4] = m00 * n01 + m01 * n11 + m02 * n21 + m03 * n31;
		rd[8] = m00 * n02 + m01 * n12 + m02 * n22 + m03 * n32;
		rd[12] = m00 * n03 + m01 * n13 + m02 * n23 + m03 * n33;

		rd[1] = m10 * n00 + m11 * n10 + m12 * n20 + m13 * n30;
		rd[5] = m10 * n01 + m11 * n11 + m12 * n21 + m13 * n31;
		rd[9] = m10 * n02 + m11 * n12 + m12 * n22 + m13 * n32;
		rd[13] = m10 * n03 + m11 * n13 + m12 * n23 + m13 * n33;

		rd[2] = m20 * n00 + m21 * n10 + m22 * n20 + m23 * n30;
		rd[6] = m20 * n01 + m21 * n11 + m22 * n21 + m23 * n31;
		rd[10] = m20 * n02 + m21 * n12 + m22 * n22 + m23 * n32;
		rd[14] = m20 * n03 + m21 * n13 + m22 * n23 + m23 * n33;

		rd[3] = m30 * n00 + m31 * n10 + m32 * n20 + m33 * n30;
		rd[7] = m30 * n01 + m31 * n11 + m32 * n21 + m33 * n31;
		rd[11] = m30 * n02 + m31 * n12 + m32 * n22 + m33 * n32;
		rd[15] = m30 * n03 + m31 * n13 + m32 * n23 + m33 * n33;

		return this;
	};

	/**
	 * Multiplies two matrices and stores the result in this matrix
	 * @param {Matrix4} lhs Matrix on the left-hand side
	 * @param {Matrix4} rhs Matrix on the right-hand side
	 * @returns {Matrix4} Self to allow chaining
	 */
	Matrix4.prototype.mul2 = function (lhs, rhs) {
		var s1d = lhs.data;
		var m00 = s1d[0], m01 = s1d[4], m02 = s1d[8], m03 = s1d[12],
			m10 = s1d[1], m11 = s1d[5], m12 = s1d[9], m13 = s1d[13],
			m20 = s1d[2], m21 = s1d[6], m22 = s1d[10], m23 = s1d[14],
			m30 = s1d[3], m31 = s1d[7], m32 = s1d[11], m33 = s1d[15];
		var s2d = rhs.data;
		var n00 = s2d[0], n01 = s2d[4], n02 = s2d[8], n03 = s2d[12],
			n10 = s2d[1], n11 = s2d[5], n12 = s2d[9], n13 = s2d[13],
			n20 = s2d[2], n21 = s2d[6], n22 = s2d[10], n23 = s2d[14],
			n30 = s2d[3], n31 = s2d[7], n32 = s2d[11], n33 = s2d[15];

		var rd = this.data;
		rd[0] = m00 * n00 + m01 * n10 + m02 * n20 + m03 * n30;
		rd[4] = m00 * n01 + m01 * n11 + m02 * n21 + m03 * n31;
		rd[8] = m00 * n02 + m01 * n12 + m02 * n22 + m03 * n32;
		rd[12] = m00 * n03 + m01 * n13 + m02 * n23 + m03 * n33;

		rd[1] = m10 * n00 + m11 * n10 + m12 * n20 + m13 * n30;
		rd[5] = m10 * n01 + m11 * n11 + m12 * n21 + m13 * n31;
		rd[9] = m10 * n02 + m11 * n12 + m12 * n22 + m13 * n32;
		rd[13] = m10 * n03 + m11 * n13 + m12 * n23 + m13 * n33;

		rd[2] = m20 * n00 + m21 * n10 + m22 * n20 + m23 * n30;
		rd[6] = m20 * n01 + m21 * n11 + m22 * n21 + m23 * n31;
		rd[10] = m20 * n02 + m21 * n12 + m22 * n22 + m23 * n32;
		rd[14] = m20 * n03 + m21 * n13 + m22 * n23 + m23 * n33;

		rd[3] = m30 * n00 + m31 * n10 + m32 * n20 + m33 * n30;
		rd[7] = m30 * n01 + m31 * n11 + m32 * n21 + m33 * n31;
		rd[11] = m30 * n02 + m31 * n12 + m32 * n22 + m33 * n32;
		rd[15] = m30 * n03 + m31 * n13 + m32 * n23 + m33 * n33;

		return this;
	};

	/**
	 * Transposes a matrix (exchanges rows and columns)
	 * @returns {Matrix4} Self to allow chaining
	 */
	Matrix4.prototype.transpose = function () {
		var data = this.data;

		var e01 = data[4];
		var e02 = data[8];
		var e03 = data[12];
		var e12 = data[9];
		var e13 = data[13];
		var e23 = data[14];

		data[4] = data[1];
		data[8] = data[2];
		data[12] = data[3];
		data[9] = data[6];
		data[13] = data[7];
		data[14] = data[11];

		data[1] = e01;
		data[2] = e02;
		data[3] = e03;
		data[6] = e12;
		data[7] = e13;
		data[11] = e23;

		return this;
	};

	/**
	 * Computes the analytical inverse and stores the result in a separate matrix.
	 * @param {Matrix4} source Source matrix.
	 * @param {Matrix4} [target] Target matrix.
	 * @returns {Matrix4} A new matrix if the target matrix is omitted, else the target matrix.
	 */
	Matrix4.invert = function (source, target) {
		if (!target) {
			target = new Matrix4();
		}

		if (target === source) {
			return target.copy(Matrix4.invert(source));
		}

		var det = source.determinant();

		if (!det) { //! AT: why not Math.abs(det) < MathUtils.EPSILON ? (I don't dare change it)
			return target;
		}

		var s = source.data;
		var t = target.data;

		det = 1.0 / det;

		t[0] = (s[5] * (s[10] * s[15] - s[14] * s[11]) - s[9] * (s[6] * s[15] - s[14] * s[7]) + s[13] * (s[6] * s[11] - s[10] * s[7])) * det;
		t[1] = (s[1] * (s[14] * s[11] - s[10] * s[15]) - s[9] * (s[14] * s[3] - s[2] * s[15]) + s[13] * (s[10] * s[3] - s[2] * s[11])) * det;
		t[2] = (s[1] * (s[6] * s[15] - s[14] * s[7]) - s[5] * (s[2] * s[15] - s[14] * s[3]) + s[13] * (s[2] * s[7] - s[6] * s[3])) * det;
		t[3] = (s[1] * (s[10] * s[7] - s[6] * s[11]) - s[5] * (s[10] * s[3] - s[2] * s[11]) + s[9] * (s[6] * s[3] - s[2] * s[7])) * det;
		t[4] = (s[4] * (s[14] * s[11] - s[10] * s[15]) - s[8] * (s[14] * s[7] - s[6] * s[15]) + s[12] * (s[10] * s[7] - s[6] * s[11])) * det;
		t[5] = (s[0] * (s[10] * s[15] - s[14] * s[11]) - s[8] * (s[2] * s[15] - s[14] * s[3]) + s[12] * (s[2] * s[11] - s[10] * s[3])) * det;
		t[6] = (s[0] * (s[14] * s[7] - s[6] * s[15]) - s[4] * (s[14] * s[3] - s[2] * s[15]) + s[12] * (s[6] * s[3] - s[2] * s[7])) * det;
		t[7] = (s[0] * (s[6] * s[11] - s[10] * s[7]) - s[4] * (s[2] * s[11] - s[10] * s[3]) + s[8] * (s[2] * s[7] - s[6] * s[3])) * det;
		t[8] = (s[4] * (s[9] * s[15] - s[13] * s[11]) - s[8] * (s[5] * s[15] - s[13] * s[7]) + s[12] * (s[5] * s[11] - s[9] * s[7])) * det;
		t[9] = (s[0] * (s[13] * s[11] - s[9] * s[15]) - s[8] * (s[13] * s[3] - s[1] * s[15]) + s[12] * (s[9] * s[3] - s[1] * s[11])) * det;
		t[10] = (s[0] * (s[5] * s[15] - s[13] * s[7]) - s[4] * (s[1] * s[15] - s[13] * s[3]) + s[12] * (s[1] * s[7] - s[5] * s[3])) * det;
		t[11] = (s[0] * (s[9] * s[7] - s[5] * s[11]) - s[4] * (s[9] * s[3] - s[1] * s[11]) + s[8] * (s[5] * s[3] - s[1] * s[7])) * det;
		t[12] = (s[4] * (s[13] * s[10] - s[9] * s[14]) - s[8] * (s[13] * s[6] - s[5] * s[14]) + s[12] * (s[9] * s[6] - s[5] * s[10])) * det;
		t[13] = (s[0] * (s[9] * s[14] - s[13] * s[10]) - s[8] * (s[1] * s[14] - s[13] * s[2]) + s[12] * (s[1] * s[10] - s[9] * s[2])) * det;
		t[14] = (s[0] * (s[13] * s[6] - s[5] * s[14]) - s[4] * (s[13] * s[2] - s[1] * s[14]) + s[12] * (s[5] * s[2] - s[1] * s[6])) * det;
		t[15] = (s[0] * (s[5] * s[10] - s[9] * s[6]) - s[4] * (s[1] * s[10] - s[9] * s[2]) + s[8] * (s[1] * s[6] - s[5] * s[2])) * det;

		return target;
	};

	/**
	 * Computes the analytical inverse and stores the result locally.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.invert = function () {
		return Matrix4.invert(this, this);
	};

	/**
	 * Tests if the matrix is orthogonal.
	 * @returns {Boolean} True if orthogonal.
	 */
	Matrix4.prototype.isOrthogonal = function () {
		var dot;

		dot = this.e00 * this.e01 + this.e10 * this.e11 + this.e20 * this.e21 + this.e30 * this.e31;

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = this.e00 * this.e02 + this.e10 * this.e12 + this.e20 * this.e22 + this.e30 * this.e32;

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = this.e00 * this.e03 + this.e10 * this.e13 + this.e20 * this.e23 + this.e30 * this.e33;

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = this.e01 * this.e02 + this.e11 * this.e12 + this.e21 * this.e22 + this.e31 * this.e32;

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = this.e01 * this.e03 + this.e11 * this.e13 + this.e21 * this.e23 + this.e31 * this.e33;

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		dot = this.e02 * this.e03 + this.e12 * this.e13 + this.e22 * this.e23 + this.e32 * this.e33;

		//! AT: why wrap in an if?!?!
		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		return true;
	};

	/**
	 * Tests if the matrix is normal.
	 * @returns {Boolean} True if normal.
	 */
	Matrix4.prototype.isNormal = function () {
		var l;

		l = this.e00 * this.e00 + this.e10 * this.e10 + this.e20 * this.e20 + this.e30 * this.e30;

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		l = this.e01 * this.e01 + this.e11 * this.e11 + this.e21 * this.e21 + this.e31 * this.e31;

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		l = this.e02 * this.e02 + this.e12 * this.e12 + this.e22 * this.e22 + this.e32 * this.e32;

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		l = this.e03 * this.e03 + this.e13 * this.e13 + this.e23 * this.e23 + this.e33 * this.e33;

		//! AT: why wrap in an if?!?!
		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		return true;
	};

	/**
	 * Tests if the matrix is orthonormal.
	 * @returns {Boolean} True if orthonormal.
	 */
	Matrix4.prototype.isOrthonormal = function () {
		return this.isOrthogonal() && this.isNormal();
	};

	/**
	 * Computes the determinant of the matrix.
	 * @returns {Float} Determinant of matrix.
	 */
	Matrix4.prototype.determinant = function () {
		var d = this.data;

		var val1 = d[5] * d[10] * d[15] +
			d[9] * d[14] * d[7] +
			d[13] * d[6] * d[11] -
			d[13] * d[10] * d[7] -
			d[9] * d[6] * d[15] -
			d[5] * d[14] * d[11];
		var val2 = d[1] * d[10] * d[15] +
			d[9] * d[14] * d[3] +
			d[13] * d[2] * d[11] -
			d[13] * d[10] * d[3] -
			d[9] * d[2] * d[15] -
			d[1] * d[14] * d[11];
		var val3 = d[1] * d[6] * d[15] +
			d[5] * d[14] * d[3] +
			d[13] * d[2] * d[7] -
			d[13] * d[6] * d[3] -
			d[5] * d[2] * d[15] -
			d[1] * d[14] * d[7];
		var val4 = d[1] * d[6] * d[11] +
			d[5] * d[10] * d[3] +
			d[9] * d[2] * d[7] -
			d[9] * d[6] * d[3] -
			d[5] * d[2] * d[11] -
			d[1] * d[10] * d[7];

		return d[0] * val1 -
			d[4] * val2 +
			d[8] * val3 -
			d[12] * val4;
	};

	//! AT: matrix.set(Matrix3.IDENTITY);
	/**
	 * Sets the matrix to identity.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.setIdentity = function () {
		var d = this.data;

		d[0] = 1;
		d[1] = 0;
		d[2] = 0;
		d[3] = 0;
		d[4] = 0;
		d[5] = 1;
		d[6] = 0;
		d[7] = 0;
		d[8] = 0;
		d[9] = 0;
		d[10] = 1;
		d[11] = 0;
		d[12] = 0;
		d[13] = 0;
		d[14] = 0;
		d[15] = 1;

		return this;
	};

	/**
	 * Sets the rotational part of the matrix from a vector of angles. Order convention is x followed by y followed by z.
	 * @param {Vector3} angles Rotational angles in radians.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.setRotationFromVector = function (angles) {
		var sx = Math.sin(angles.x);
		var cx = Math.cos(angles.x);
		var sy = Math.sin(angles.y);
		var cy = Math.cos(angles.y);
		var sz = Math.sin(angles.z);
		var cz = Math.cos(angles.z);

		this.e00 = cz * cy;
		this.e10 = sz * cy;
		this.e20 = 0.0 - sy;
		this.e01 = cz * sy * sx - sz * cx;
		this.e11 = sz * sy * sx + cz * cx;
		this.e21 = cy * sx;
		this.e02 = cz * sy * cx + sz * sx;
		this.e12 = sz * sy * cx - cz * sx;
		this.e22 = cy * cx;

		return this;
	};

	/**
	 * Sets the rotational part of the matrix from a quaternion.
	 * @param {Vector4} quaternion Rotational quaternion.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.setRotationFromQuaternion = function (quaternion) {
		var l = quaternion.lengthSquared();

		l = (l > 0.0) ? 2.0 / l : 0.0; //! AT: epsilon?

		var a = quaternion.x * l;
		var b = quaternion.y * l;
		var c = quaternion.z * l;

		var wa = quaternion.w * a;
		var wb = quaternion.w * b;
		var wc = quaternion.w * c;
		var xa = quaternion.x * a;
		var xb = quaternion.x * b;
		var xc = quaternion.x * c;
		var yb = quaternion.y * b;
		var yc = quaternion.y * c;
		var zc = quaternion.z * c;

		this.e00 = 1.0 - yb - zc;
		this.e10 = xb + wc;
		this.e20 = xc - wb;
		this.e01 = xb - wc;
		this.e11 = 1.0 - xa - zc;
		this.e21 = yc + wa;
		this.e02 = xc + wb;
		this.e12 = yc - wa;
		this.e22 = 1.0 - xa - yb;

		return this;
	};

	/**
	 * Sets the translational part of the matrix.
	 * @param {Vector3} translation Translation vector.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.setTranslation = function (translation) {
		this.e03 = translation.x;
		this.e13 = translation.y;
		this.e23 = translation.z;

		return this;
	};

	/**
	 * Gets the translational part of the matrix.
	 * @param {Vector3} store Translation vector to store result in.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.getTranslation = function (store) {
		store.x = this.data[12];
		store.y = this.data[13];
		store.z = this.data[14];

		return this;
	};

	/**
	 * Gets the rotational part of the matrix (the upper left 3x3 matrix).
	 * @param {Matrix3} store Rotation matrix to store in.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.getRotation = function (store) {
		var d = this.data;
		var sd = store.data;

		sd[0] = d[0];
		sd[1] = d[1];
		sd[2] = d[2];
		sd[3] = d[4];
		sd[4] = d[5];
		sd[5] = d[6];
		sd[6] = d[8];
		sd[7] = d[9];
		sd[8] = d[10];

		return this;
	};

	/**
	 * Gets the scaling part of the matrix.
	 * @param {Vector3} store Scaling vector to store result in.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.getScale = function (store) {
		//! AT: length?
		var sx = Math.sqrt(store.setDirect(this.data[0], this.data[4], this.data[8]).lengthSquared());
		var sy = Math.sqrt(store.setDirect(this.data[1], this.data[5], this.data[9]).lengthSquared());
		var sz = Math.sqrt(store.setDirect(this.data[2], this.data[6], this.data[10]).lengthSquared());

		store.x = sx;
		store.y = sy;
		store.z = sz;

		return this;
	};

	/**
	 * Sets the scale of the matrix.
	 * @param {Vector3} scale Scale vector.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.setScale = function (scale) {
		this.e00 *= scale.x;
		this.e10 *= scale.y;
		this.e20 *= scale.z;
		this.e01 *= scale.x;
		this.e11 *= scale.y;
		this.e21 *= scale.z;
		this.e02 *= scale.x;
		this.e12 *= scale.y;
		this.e22 *= scale.z;

		return this;
	};

	/**
	 * Compares two matrices for approximate equality
	 * @param {Matrix4} rhs The matrix to compare against
	 * @returns {boolean}
	 */
	Matrix4.prototype.equals = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		return (Math.abs(thisData[0] - rhsData[0]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[1] - rhsData[1]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[2] - rhsData[2]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[3] - rhsData[3]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[4] - rhsData[4]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[5] - rhsData[5]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[6] - rhsData[6]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[7] - rhsData[7]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[8] - rhsData[8]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[9] - rhsData[9]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[10] - rhsData[10]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[11] - rhsData[11]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[12] - rhsData[12]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[13] - rhsData[13]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[14] - rhsData[14]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[15] - rhsData[15]) <= MathUtils.EPSILON);
	};

	/**
	 * Copies component values and stores them locally.
	 * @param {Matrix4} rhs Source matrix.
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.copy = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[3];
		thisData[4] = rhsData[4];
		thisData[5] = rhsData[5];
		thisData[6] = rhsData[6];
		thisData[7] = rhsData[7];
		thisData[8] = rhsData[8];
		thisData[9] = rhsData[9];
		thisData[10] = rhsData[10];
		thisData[11] = rhsData[11];
		thisData[12] = rhsData[12];
		thisData[13] = rhsData[13];
		thisData[14] = rhsData[14];
		thisData[15] = rhsData[15];

		return this;
	};

	/**
	 * Sets matrix values from an array.
	 * @param {Array<number>} rhsData Array source
	 * @returns {Matrix4} Self for chaining.
	 */
	Matrix4.prototype.setArray = function (rhsData) {
		var thisData = this.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[3];
		thisData[4] = rhsData[4];
		thisData[5] = rhsData[5];
		thisData[6] = rhsData[6];
		thisData[7] = rhsData[7];
		thisData[8] = rhsData[8];
		thisData[9] = rhsData[9];
		thisData[10] = rhsData[10];
		thisData[11] = rhsData[11];
		thisData[12] = rhsData[12];
		thisData[13] = rhsData[13];
		thisData[14] = rhsData[14];
		thisData[15] = rhsData[15];

		return this;
	};

	/**
	 * Sets the matrix's values from another matrix's values; an alias for .copy
	 * @param {Matrix4} source Source matrix
	 * @returns {Matrix4} Self to allow chaining
	 */
	Matrix4.prototype.set = Matrix4.prototype.copy;

	/**
	 * Returns a new matrix with the same values as the existing one.
	 * @returns {Matrix4} The new matrix.
	 */
	Matrix4.prototype.clone = function () {
		return new Matrix4().copy(this);
	};

	// SHIMS START

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.add = ObjectUtils.warnOnce(
		'Matrix4.add is deprecated, use Matrix4.prototype.add instead',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix4();
			}

			if (rhs instanceof Matrix4) {
				target.e00 = lhs.e00 + rhs.e00;
				target.e10 = lhs.e10 + rhs.e10;
				target.e20 = lhs.e20 + rhs.e20;
				target.e30 = lhs.e30 + rhs.e30;
				target.e01 = lhs.e01 + rhs.e01;
				target.e11 = lhs.e11 + rhs.e11;
				target.e21 = lhs.e21 + rhs.e21;
				target.e31 = lhs.e31 + rhs.e31;
				target.e02 = lhs.e02 + rhs.e02;
				target.e12 = lhs.e12 + rhs.e12;
				target.e22 = lhs.e22 + rhs.e22;
				target.e32 = lhs.e32 + rhs.e32;
				target.e03 = lhs.e03 + rhs.e03;
				target.e13 = lhs.e13 + rhs.e13;
				target.e23 = lhs.e23 + rhs.e23;
				target.e33 = lhs.e33 + rhs.e33;
			} else {
				target.e00 = lhs.e00 + rhs;
				target.e10 = lhs.e10 + rhs;
				target.e20 = lhs.e20 + rhs;
				target.e30 = lhs.e30 + rhs;
				target.e01 = lhs.e01 + rhs;
				target.e11 = lhs.e11 + rhs;
				target.e21 = lhs.e21 + rhs;
				target.e31 = lhs.e31 + rhs;
				target.e02 = lhs.e02 + rhs;
				target.e12 = lhs.e12 + rhs;
				target.e22 = lhs.e22 + rhs;
				target.e32 = lhs.e32 + rhs;
				target.e03 = lhs.e03 + rhs;
				target.e13 = lhs.e13 + rhs;
				target.e23 = lhs.e23 + rhs;
				target.e33 = lhs.e33 + rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.sub = ObjectUtils.warnOnce(
		'Matrix4.sub is deprecated',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix4();
			}

			if (rhs instanceof Matrix4) {
				target.e00 = lhs.e00 - rhs.e00;
				target.e10 = lhs.e10 - rhs.e10;
				target.e20 = lhs.e20 - rhs.e20;
				target.e30 = lhs.e30 - rhs.e30;
				target.e01 = lhs.e01 - rhs.e01;
				target.e11 = lhs.e11 - rhs.e11;
				target.e21 = lhs.e21 - rhs.e21;
				target.e31 = lhs.e31 - rhs.e31;
				target.e02 = lhs.e02 - rhs.e02;
				target.e12 = lhs.e12 - rhs.e12;
				target.e22 = lhs.e22 - rhs.e22;
				target.e32 = lhs.e32 - rhs.e32;
				target.e03 = lhs.e03 - rhs.e03;
				target.e13 = lhs.e13 - rhs.e13;
				target.e23 = lhs.e23 - rhs.e23;
				target.e33 = lhs.e33 - rhs.e33;
			} else {
				target.e00 = lhs.e00 - rhs;
				target.e10 = lhs.e10 - rhs;
				target.e20 = lhs.e20 - rhs;
				target.e30 = lhs.e30 - rhs;
				target.e01 = lhs.e01 - rhs;
				target.e11 = lhs.e11 - rhs;
				target.e21 = lhs.e21 - rhs;
				target.e31 = lhs.e31 - rhs;
				target.e02 = lhs.e02 - rhs;
				target.e12 = lhs.e12 - rhs;
				target.e22 = lhs.e22 - rhs;
				target.e32 = lhs.e32 - rhs;
				target.e03 = lhs.e03 - rhs;
				target.e13 = lhs.e13 - rhs;
				target.e23 = lhs.e23 - rhs;
				target.e33 = lhs.e33 - rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.mul = ObjectUtils.warnOnce(
		'Matrix4.mul is deprecated, use Matrix4.prototype.mul instead',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix4();
			}

			if (rhs instanceof Matrix4) {
				target.e00 = lhs.e00 * rhs.e00;
				target.e10 = lhs.e10 * rhs.e10;
				target.e20 = lhs.e20 * rhs.e20;
				target.e30 = lhs.e30 * rhs.e30;
				target.e01 = lhs.e01 * rhs.e01;
				target.e11 = lhs.e11 * rhs.e11;
				target.e21 = lhs.e21 * rhs.e21;
				target.e31 = lhs.e31 * rhs.e31;
				target.e02 = lhs.e02 * rhs.e02;
				target.e12 = lhs.e12 * rhs.e12;
				target.e22 = lhs.e22 * rhs.e22;
				target.e32 = lhs.e32 * rhs.e32;
				target.e03 = lhs.e03 * rhs.e03;
				target.e13 = lhs.e13 * rhs.e13;
				target.e23 = lhs.e23 * rhs.e23;
				target.e33 = lhs.e33 * rhs.e33;
			} else {
				target.e00 = lhs.e00 * rhs;
				target.e10 = lhs.e10 * rhs;
				target.e20 = lhs.e20 * rhs;
				target.e30 = lhs.e30 * rhs;
				target.e01 = lhs.e01 * rhs;
				target.e11 = lhs.e11 * rhs;
				target.e21 = lhs.e21 * rhs;
				target.e31 = lhs.e31 * rhs;
				target.e02 = lhs.e02 * rhs;
				target.e12 = lhs.e12 * rhs;
				target.e22 = lhs.e22 * rhs;
				target.e32 = lhs.e32 * rhs;
				target.e03 = lhs.e03 * rhs;
				target.e13 = lhs.e13 * rhs;
				target.e23 = lhs.e23 * rhs;
				target.e33 = lhs.e33 * rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.div = ObjectUtils.warnOnce(
		'Matrix4.div is deprecated',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix4();
			}

			if (rhs instanceof Matrix4) {
				target.e00 = lhs.e00 / rhs.e00;
				target.e10 = lhs.e10 / rhs.e10;
				target.e20 = lhs.e20 / rhs.e20;
				target.e30 = lhs.e30 / rhs.e30;
				target.e01 = lhs.e01 / rhs.e01;
				target.e11 = lhs.e11 / rhs.e11;
				target.e21 = lhs.e21 / rhs.e21;
				target.e31 = lhs.e31 / rhs.e31;
				target.e02 = lhs.e02 / rhs.e02;
				target.e12 = lhs.e12 / rhs.e12;
				target.e22 = lhs.e22 / rhs.e22;
				target.e32 = lhs.e32 / rhs.e32;
				target.e03 = lhs.e03 / rhs.e03;
				target.e13 = lhs.e13 / rhs.e13;
				target.e23 = lhs.e23 / rhs.e23;
				target.e33 = lhs.e33 / rhs.e33;
			} else {
				rhs = 1.0 / rhs;

				target.e00 = lhs.e00 * rhs;
				target.e10 = lhs.e10 * rhs;
				target.e20 = lhs.e20 * rhs;
				target.e30 = lhs.e30 * rhs;
				target.e01 = lhs.e01 * rhs;
				target.e11 = lhs.e11 * rhs;
				target.e21 = lhs.e21 * rhs;
				target.e31 = lhs.e31 * rhs;
				target.e02 = lhs.e02 * rhs;
				target.e12 = lhs.e12 * rhs;
				target.e22 = lhs.e22 * rhs;
				target.e32 = lhs.e32 * rhs;
				target.e03 = lhs.e03 * rhs;
				target.e13 = lhs.e13 * rhs;
				target.e23 = lhs.e23 * rhs;
				target.e33 = lhs.e33 * rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.prototype.div = ObjectUtils.warnOnce(
		'Matrix4.prototype.div is deprecated',
		function (rhs) {
			return Matrix4.div(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.combine = ObjectUtils.warnOnce(
		'Matrix4.combine is deprecated, use Matrix4.prototype.mul instead',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix4();
			}

			var s1d = lhs.data;
			var m00 = s1d[0], m01 = s1d[4], m02 = s1d[8], m03 = s1d[12],
				m10 = s1d[1], m11 = s1d[5], m12 = s1d[9], m13 = s1d[13],
				m20 = s1d[2], m21 = s1d[6], m22 = s1d[10], m23 = s1d[14],
				m30 = s1d[3], m31 = s1d[7], m32 = s1d[11], m33 = s1d[15];
			var s2d = rhs.data;
			var n00 = s2d[0], n01 = s2d[4], n02 = s2d[8], n03 = s2d[12],
				n10 = s2d[1], n11 = s2d[5], n12 = s2d[9], n13 = s2d[13],
				n20 = s2d[2], n21 = s2d[6], n22 = s2d[10], n23 = s2d[14],
				n30 = s2d[3], n31 = s2d[7], n32 = s2d[11], n33 = s2d[15];

			var rd = target.data;
			rd[0] = m00 * n00 + m01 * n10 + m02 * n20 + m03 * n30;
			rd[4] = m00 * n01 + m01 * n11 + m02 * n21 + m03 * n31;
			rd[8] = m00 * n02 + m01 * n12 + m02 * n22 + m03 * n32;
			rd[12] = m00 * n03 + m01 * n13 + m02 * n23 + m03 * n33;

			rd[1] = m10 * n00 + m11 * n10 + m12 * n20 + m13 * n30;
			rd[5] = m10 * n01 + m11 * n11 + m12 * n21 + m13 * n31;
			rd[9] = m10 * n02 + m11 * n12 + m12 * n22 + m13 * n32;
			rd[13] = m10 * n03 + m11 * n13 + m12 * n23 + m13 * n33;

			rd[2] = m20 * n00 + m21 * n10 + m22 * n20 + m23 * n30;
			rd[6] = m20 * n01 + m21 * n11 + m22 * n21 + m23 * n31;
			rd[10] = m20 * n02 + m21 * n12 + m22 * n22 + m23 * n32;
			rd[14] = m20 * n03 + m21 * n13 + m22 * n23 + m23 * n33;

			rd[3] = m30 * n00 + m31 * n10 + m32 * n20 + m33 * n30;
			rd[7] = m30 * n01 + m31 * n11 + m32 * n21 + m33 * n31;
			rd[11] = m30 * n02 + m31 * n12 + m32 * n22 + m33 * n32;
			rd[15] = m30 * n03 + m31 * n13 + m32 * n23 + m33 * n33;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.prototype.combine = ObjectUtils.warnOnce(
		'Matrix4.prototype.combine is deprecated, use Matrix4.prototype.mul instead',
		function (rhs) {
			return Matrix4.combine(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.transpose = ObjectUtils.warnOnce(
		'Matrix4.transpose is deprecated, use Matrix4.prototype.transpose instead',
		function (source, target) {
			if (!target) {
				target = new Matrix4();
			}

			var s = source.data;
			var t = target.data;

			if (target === source) {
				var e01 = s[4];
				var e02 = s[8];
				var e03 = s[12];
				var e12 = s[9];
				var e13 = s[13];
				var e23 = s[14];

				t[4] = s[1];
				t[8] = s[2];
				t[12] = s[3];
				t[9] = s[6];
				t[13] = s[7];
				t[14] = s[11];

				t[1] = e01;
				t[2] = e02;
				t[3] = e03;
				t[6] = e12;
				t[7] = e13;
				t[11] = e23;

				return target;
			}

			t[0] = s[0];
			t[1] = s[4];
			t[2] = s[8];
			t[3] = s[12];
			t[4] = s[1];
			t[5] = s[5];
			t[6] = s[9];
			t[7] = s[13];
			t[8] = s[2];
			t[9] = s[6];
			t[10] = s[10];
			t[11] = s[14];
			t[12] = s[3];
			t[13] = s[7];
			t[14] = s[11];
			t[15] = s[15];

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.prototype.applyPre = ObjectUtils.warnOnce(
		'Matrix4.prototype.applyPre is deprecated, use Vector4.prototype.applyPre instead',
		function (rhs) {
			var x = rhs.x;
			var y = rhs.y;
			var z = rhs.z;
			var w = rhs.w;

			var s = this.data;
			rhs.x = s[0] * x + s[1] * y + s[2] * z + s[3] * w;
			rhs.y = s[4] * x + s[5] * y + s[6] * z + s[7] * w;
			rhs.z = s[8] * x + s[9] * y + s[10] * z + s[11] * w;
			rhs.w = s[12] * x + s[13] * y + s[14] * z + s[15] * w;

			return rhs;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.prototype.applyPost = ObjectUtils.warnOnce(
		'Matrix4.prototype.applyPost is deprecated, use Vector4.prototype.applyPost instead',
		function (rhs) {
			var x = rhs.x;
			var y = rhs.y;
			var z = rhs.z;
			var w = rhs.w;

			var s = this.data;
			rhs.x = s[0] * x + s[4] * y + s[8] * z + s[12] * w;
			rhs.y = s[1] * x + s[5] * y + s[9] * z + s[13] * w;
			rhs.z = s[2] * x + s[6] * y + s[10] * z + s[14] * w;
			rhs.w = s[3] * x + s[7] * y + s[11] * z + s[15] * w;

			return rhs;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.prototype.applyPostPoint = ObjectUtils.warnOnce(
		'Matrix4.prototype.applyPostPoint is deprecated, use Vector4.prototype.applyPostPoint instead',
		function (rhs) {
			return rhs.applyPostPoint(this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix4.prototype.applyPostVector = ObjectUtils.warnOnce(
		'Matrix4.prototype.applyPostVector is deprecated, use Vector4.prototype.applyPostVector instead',
		function (rhs) {
			var x = rhs.x;
			var y = rhs.y;
			var z = rhs.z;

			var d = this.data;
			rhs.x = d[0] * x + d[4] * y + d[8] * z;
			rhs.y = d[1] * x + d[5] * y + d[9] * z;
			rhs.z = d[2] * x + d[6] * y + d[10] * z;

			return rhs;
		}
	);

	// SHIMS END

	// #ifdef DEBUG
	Matrix.addPostChecks(Matrix4.prototype, [
		'add', 'sub', 'scale', 'transpose', 'invert',
		'isOrthogonal', 'determinant',
		'copy'
	]);
	// #endif

	return Matrix4;
})(goo.MathUtils,goo.Matrix,goo.ObjectUtils);
goo.Transform = (function (
	Vector3,
	Matrix3,
	Matrix4,
	MathUtils
) {
	'use strict';

	/**
	 * Transform models a transformation in 3d space as: Y = M*X+T, with M being a Matrix3 and T is a Vector3. Generally M will be a rotation
	 *        only matrix in which case it is represented by the matrix and scale fields as R*S, where S is a positive scale vector. For non-uniform
	 *        scales and reflections, use setMatrix, which will consider M as being a general 3x3 matrix and disregard anything set in scale.
	 */
	function Transform() {
		/** Read only, will be updated automatically by {@link Transform.update}
		 * @type {Matrix4}
		 */
		this.matrix = new Matrix4();
		this.normalMatrix = new Matrix3();

		/** @type {Vector3} */
		this.translation = new Vector3();
		/** @type {Matrix3} */
		this.rotation = new Matrix3();
		/** @type {Vector3} */
		this.scale = new Vector3(1, 1, 1);

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	var tmpVec = new Vector3();
	var tmpVec2 = new Vector3();
	var tmpMat1 = new Matrix3();

	/**
	 * Combines two transforms into one. This will only work if scaling in the left hand transform is uniform
	 * @param {Transform} lhs left hand side transform
	 * @param {Transform} rhs right hand side transform
	 * @param {Transform} target
	 * @returns {Transform} target
	 */
	Transform.combine = function (lhs, rhs, target) {
		target = target || new Transform();

		// Translation
		tmpVec.set(rhs.translation);
		// Rotate translation
		tmpVec.applyPost(lhs.rotation);
		// Scale translation
		tmpVec.mul(lhs.scale);
		// Translate translation
		tmpVec.add(lhs.translation);

		// Scale
		tmpVec2.set(rhs.scale);
		// Scale scale
		tmpVec2.mul(lhs.scale);

		// Rotation
		// Rotate rotation
		tmpMat1.mul2(lhs.rotation, rhs.rotation);

		target.rotation.copy(tmpMat1);
		target.scale.set(tmpVec2);
		target.translation.set(tmpVec);

		target.update();

		return target;
	};

	/**
	 * Combines new transform into this one. This will only work if scaling in the left hand transform is uniform
	 * @param {Transform} rhs right hand side transform
	 * @returns {Transform} this for chaining
	 */
	Transform.prototype.combine = function (rhs) {
		return Transform.combine(this, rhs, this);
	};

	// TODO: sort this crap out!
	Transform.prototype.multiply = function (a, b) {
		this.matrix.mul2(a.matrix, b.matrix);

		tmpMat1.data.set(a.rotation.data);
		//tmpMat1.multiplyDiagonalPost(a.scale, tmpMat1);
		this.rotation.data.set(b.rotation.data);
		//this.rotation.multiplyDiagonalPost(b.scale, this.rotation);
		this.rotation.mul2(tmpMat1, this.rotation);
		this.translation.set(b.translation);
		this.translation.mul(a.scale);
		this.translation.applyPost(tmpMat1).add(a.translation);

		tmpVec.set(a.scale).mul(b.scale);
		this.scale.set(tmpVec);

		return this;
	};

	/**
	 * Set Transform to identity
	 * @returns {Transform} Self to allow chaining
	 */
	Transform.prototype.setIdentity = function () {
		this.matrix.setIdentity();

		this.translation.set(Vector3.ZERO);
		this.rotation.setIdentity();
		this.scale.set(Vector3.ONE);

		return this;
	};

	/**
	 * Applies this transform to supplied vector as a point
	 * @param {Vector3} point
	 * @param {Vector3} store
	 * @returns {Vector3} store
	 * @example
	 * // Vector3 object, one unit right, two units up, two units back
	 * var v1 = new Vector3(1, 2, 2);
	 * // Vector3 to store the local position
	 * var localPos = new Vector3();
	 * // converts v1 to be in 'world space' based on the entities postion / rotation
	 * entity.transformComponent.transform.applyForward(v1, localPos);
	 */
	Transform.prototype.applyForward = function (point, store) {
		store.set(point);

		// store.set(store.x * this.scale.x, store.y * this.scale.y, store.z * this.scale.z);
		// this.rotation.applyPost(store);
		// store.add(this.translation);

		store.applyPostPoint(this.matrix);

		return store;
	};

	/**
	 * Applies this transform to supplied vector as a direction-vector (translation will not affect it)
	 * @param {Vector3} vector
	 * @param {Vector3} store
	 * @returns {Vector3} store
	 * @example
	 * // Vector3 pointing in the direction we want
	 * var back = new Vector3(0, 0, 1);
	 * // Vector3 to store the local 'back'
	 * var localBack = new Vector3();
	 * // converts 'back' to a localized direction based on the entities rotation
	 * entity.transformComponent.transform.applyForwardVector(back, localBack);
	 */
	Transform.prototype.applyForwardVector = function (vector, store) {
		store.copy(vector);

		store.setDirect(store.x * this.scale.x, store.y * this.scale.y, store.z * this.scale.z);
		store.applyPost(this.rotation);

		return store;
	};

	/**
	 * Updates the transform according to set scaling, rotation and translation. This is done automatically by the engine
	 * @returns {Transform} Self to allow chaining
	 */
	Transform.prototype.update = function () {
		var target = this.matrix.data;
		var rotation = this.rotation.data;
		var scale = this.scale;
		var translation = this.translation;

		target[0] = scale.x * rotation[0];
		target[1] = scale.x * rotation[1];
		target[2] = scale.x * rotation[2];
		target[3] = 0.0;
		target[4] = scale.y * rotation[3];
		target[5] = scale.y * rotation[4];
		target[6] = scale.y * rotation[5];
		target[7] = 0.0;
		target[8] = scale.z * rotation[6];
		target[9] = scale.z * rotation[7];
		target[10] = scale.z * rotation[8];
		target[11] = 0.0;
		target[12] = translation.x;
		target[13] = translation.y;
		target[14] = translation.z;
		target[15] = 1.0;

		return this;
	};

	/**
	 * Updates the normal matrix. This is done automatically by the engine.
	 * @returns {Transform} Self to allow chaining
	 */
	Transform.prototype.updateNormalMatrix = function () {
		// Copy upper left of 4x4 to 3x3
		var t = this.normalMatrix.data;
		var s = this.matrix.data;
		t[0] = s[0];
		t[1] = s[1];
		t[2] = s[2];
		t[3] = s[4];
		t[4] = s[5];
		t[5] = s[6];
		t[6] = s[8];
		t[7] = s[9];
		t[8] = s[10];

		// invert + transpose if non-uniform scaling
		// RH: Should we check against epsilon here?
		var scale = this.scale;
		if (scale.x !== scale.y || scale.x !== scale.z) {
			this.normalMatrix.invert().transpose();
		}

		return this;
	};

	/**
	 * Copy supplied transform into this transform
	 * @param {Transform} transform
	 * @returns {Transform} Self to allow chaining
	 */
	Transform.prototype.copy = function (transform) {
		this.matrix.copy(transform.matrix);

		this.translation.set(transform.translation);
		this.rotation.copy(transform.rotation);
		this.scale.set(transform.scale);

		return this;
	};

	/**
	 * Set this transform's rotation to rotation around X, Y and Z axis. Euler order is YZX.
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {Transform} Self to allow chaining
	 */
	Transform.prototype.setRotationXYZ = function (x, y, z) {
		this.rotation.fromAngles(x, y, z);

		return this;
	};

	/**
	 * Sets the transform to look in a specific direction.
	 * @param {Vector3} position Target position.
	 * @param {Vector3} [up=(0, 1, 0)] Up vector.
	 * @returns {Transform} Self to allow chaining
	 */
	Transform.prototype.lookAt = function (position, up) {
		if (!up) {
			up = Vector3.UNIT_Y;
		}

		tmpVec.set(position).sub(this.translation);
		if (tmpVec.lengthSquared() > MathUtils.EPSILON) { // should be epsilon^2 but it hopefully doesn't matter
			tmpVec.normalize();
			this.rotation.lookAt(tmpVec, up);
		}

		return this;
	};

	/**
	 * Invert this transform and store it in supplied transform
	 * @param {Transform} store
	 * @returns {Transform} store
	 */
	Transform.prototype.invert = function (store) {
		var result = store;
		if (!result) {
			result = new Transform();
		}

		// if (_identity) {
		// result.setIdentity();
		// return result;
		// }

		result.matrix.copy(this.matrix);
		result.matrix.invert();

		var newRotation = result.rotation.copy(this.rotation);
		newRotation.transpose();
		// if (_uniformScale) {
		// var sx = this.scale.x;
		// newRotation.transposeLocal();
		// if (sx !== 1.0) {
		// newRotation.multiplyLocal(1.0 / sx);
		// }
		// } else {
		//newRotation.multiplyDiagonalPost(this.scale, newRotation).invert();
		// }

		result.scale.set(Vector3.ONE).div(this.scale);
		result.translation.copy(this.translation).negate().mul(result.scale);
		result.translation.applyPost(result.rotation);

		// result.update();

		return result;
	};

	/**
	 * Returns a clone of this transform
	 * @returns {Transform}
	 */
	Transform.prototype.clone = function () {
		var clone = new Transform();

		clone.matrix.copy(this.matrix);
		clone.normalMatrix.copy(this.normalMatrix);

		clone.translation.copy(this.translation);
		clone.rotation.copy(this.rotation);
		clone.scale.copy(this.scale);

		return clone;
	};

	return Transform;
})(goo.Vector3,goo.Matrix3,goo.Matrix4,goo.MathUtils);
goo.TransformComponent = (function (
	Transform,
	Vector3,
	Component,
	EntitySelection
) {
	'use strict';

	/**
	 * Holds the transform of an entity. It also allows for a scene graph to be created,
	 * in which transforms are inherited down the tree.
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/TransformComponent/TransformComponent-vtest.html Working example
	 * @extends Component
	 */
	function TransformComponent() {
		Component.apply(this, arguments);

		this.type = 'TransformComponent';

		this.entity = null;
		/**
		 * Parent TransformComponent in the "scene graph".
		 * @type {TransformComponent}
		 */
		this.parent = null;
		/**
		 * Child TransformComponents in the "scene graph".
		 * @type {Array<TransformComponent>}
		 */
		this.children = [];

		/**
		 * The entity's transform in local space.
		 * @type {Transform}
		 */
		this.transform = new Transform();

		/**
		 * The entity's transform in world space.
		 * @readonly
		 * @type {Transform}
		 */
		this.worldTransform = new Transform();

		this._dirty = true;
		this._updated = false;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	TransformComponent.type = 'TransformComponent';

	TransformComponent.prototype = Object.create(Component.prototype);
	TransformComponent.prototype.constructor = TransformComponent;

	//! AT: can this stay not on the prototype, but on the constructor?
	// it would require Transform.prototype.constructor = TransformComponent; (for all components)
	TransformComponent.prototype.api = {
		// these @target-class comments can sit anywhere in the source (as far as modoc is concerned)
		// I'm placing it here however since it's near the code it documents
		/**
		 * Sets the translation of this entity. Injected on entities with a transformComponent
		 * @target-class Entity setTranslation method
		 * @param {(Vector3|Array<number>)} translation
		 * @returns {Entity} Self to allow chaining
		 */
		setTranslation: function () {
			TransformComponent.prototype.setTranslation.apply(this.transformComponent, arguments);
			return this;
		},

		/**
		 * Sets the rotation of this entity. Injected on entities with a transformComponent
		 * @target-class Entity setRotation method
		 * @param {(Vector3|Array<number>)} angle
		 * @returns {Entity} Self to allow chaining
		 */
		setRotation: function () {
			TransformComponent.prototype.setRotation.apply(this.transformComponent, arguments);
			return this;
		},

		/**
		 * Sets the scale of this entity. Injected on entities with a transformComponent
		 * @target-class Entity setScale method
		 * @param {(Vector3|Array<number>)} scale
		 * @returns {Entity} Self to allow chaining
		 */
		setScale: function () {
			TransformComponent.prototype.setScale.apply(this.transformComponent, arguments);
			return this;
		},

		/**
		 * Orients the entity so it faces the supplied look at point. Injected on entities with a transformComponent
		 * @target-class Entity lookAt method
		 * @param {(Vector3|Array<number>)} lookAtPoint
		 * @returns {Entity} Self to allow chaining
		 */
		lookAt: function () {
			TransformComponent.prototype.lookAt.apply(this.transformComponent, arguments);
			return this;
		},

		/**
		 * Translates the entity with the supplied amount multipled by the entity's orientation. Injected on entities with a transformComponent
		 * @target-class Entity move method
		 * @param {(Vector3|Array<number>)} translation
		 * @returns {Entity} Self to allow chaining
		 */
		move: function () {
			TransformComponent.prototype.move.apply(this.transformComponent, arguments);
			return this;
		},

		/**
		 * Returns the local translation of the entity. Injected on entities with a transformComponent
		 * @target-class Entity getTranslation method
		 * @returns {Vector3} Translation
		 */
		getTranslation: function () {
			return TransformComponent.prototype.getTranslation.apply(this.transformComponent, arguments);
		},

		/**
		 * Returns the local rotation of the entity. Injected on entities with a transformComponent
		 * @target-class Entity getRotation method
		 * @returns {Vector3} Rotation
		 */
		getRotation: function () {
			return TransformComponent.prototype.getRotation.apply(this.transformComponent, arguments);
		},

		/**
		 * Returns the local scale of the entity. Injected on entities with a transformComponent
		 * @target-class Entity getScale method
		 * @returns {Vector3} Scale
		 */
		getScale: function () {
			return TransformComponent.prototype.getScale.apply(this.transformComponent, arguments);
		},

		/**
		 * Translates the entity with the given amount. Injected on entities with a transformComponent
		 * @target-class Entity addTranslation method
		 * @param {(Vector3|Array<number>)} translation
		 * @returns {Entity} Self to allow chaining
		 */
		addTranslation: function () {
			TransformComponent.prototype.addTranslation.apply(this.transformComponent, arguments);
			return this;
		},

		/**
		 * Rotates the entity with the given amount. Injected on entities with a transformComponent
		 * @target-class Entity addRotation method
		 * @param {(Vector3|Array<number>)} rotation
		 * @returns {Entity} Self to allow chaining
		 */
		addRotation: function () {
			TransformComponent.prototype.addRotation.apply(this.transformComponent, arguments);
			return this;
		},

		// no, there's no addScale

		/**
		 * Attaches the supplied entity to this entity as a child. Injected on entities with a transformComponent
		 * @target-class Entity attachChild method
		 * @param {Entity} childEntity
		 * @param {boolean} keepTransform If enabled will preserve the world transform of the child entity
		 * @returns {Entity} Self to allow chaining
		 */
		attachChild: function (childEntity, keepTransform) {
			this.transformComponent.attachChild(childEntity.transformComponent, keepTransform);
			return this;
		},

		/**
		 * Detaches the supplied entity from this entity. Injected on entities with a transformComponent
		 * @target-class Entity detachChild method
		 * @param {Entity} childEntity
		 * @param {boolean} keepTransform If enabled will preserve the world transform of the child entity
		 * @returns {Entity} Self to allow chaining
		 */
		detachChild: function (childEntity, keepTransform) {
			this.transformComponent.detachChild(childEntity.transformComponent, keepTransform);
			return this;
		},

		/**
		 * Returns an {@link EntitySelection} of the children of this entity. Injected on entities with a transformComponent
		 * @target-class Entity children method
		 * @returns {EntitySelection}
		 */
		children: function () {
			return new EntitySelection(this).children();
		},

		/**
		 * Returns an {@link EntitySelection} of the parent of this entity. Injected on entities with a transformComponent
		 * @target-class Entity parent method
		 * @returns {EntitySelection}
		 */
		parent: function () {
			return new EntitySelection(this).parent();
		},

		/**
		 * Traverses the entity hierarchy downwards starting from this entity and applies a function to all entities traversed.
		 * Traversal can be stopped if the function returns 'false'.
		 * Injected on entities with a transformComponent
		 * @target-class Entity traverse method
		 * @param {function (entity: Entity, level: number) : boolean} callback The function to be applied to traversed entities. Takes an entity and the current deph level and returns a boolean.
		 * @param {number} [level=0]
		 * @returns {Entity} Self to allow chaining
		 */
		traverse: function (callback, level) {
			level = level !== undefined ? level : 0;

			if (callback(this, level) !== false) {
				for (var i = 0; i < this.transformComponent.children.length; i++) {
					var childEntity = this.transformComponent.children[i].entity;
					childEntity.traverse(callback, level + 1);
				}
			}

			return this;
		},

		/**
		 * Traverses the entity hierarchy upwards starting from this entity and applies a function to all entities traversed.
		 * Traversal can be stopped if the function returns 'false'.
		 * Injected on entities with a transformComponent
		 * @target-class Entity traverseUp method
		 * @param {function (entity: Entity) : boolean} callback The function to be applied to traversed entities. Takes an entity and returns a boolean.
		 * @returns {Entity} Self to allow chaining
		 */
		traverseUp: function (callback) {
			var transformComponent = this.transformComponent;
			while (callback(transformComponent.entity) !== false && transformComponent.parent) {
				transformComponent = transformComponent.parent;
			}

			return this;
		},

		/**
		 * Hides the entity and its children. Injected on entities with a transformComponent
		 * @target-class Entity hide method
		 * @returns {Entity} Self to allow chaining
		 */
		hide: function () {
			this._hidden = true;

			// hide everything underneath this
			this.traverse(function (entity) {
				// will have to refactor this loop in some function; it's used in other places too
				for (var i = 0; i < entity._components.length; i++) {
					var component = entity._components[i];
					if (typeof component.hidden === 'boolean') {
						component.hidden = true;
					}
				}
			});

			return this;
		},

		/**
		 * Clears the hidden flag on this entity. The entity may still not show if it has a hidden ancestor. Injected on entities with a transformComponent
		 * @target-class Entity show method
		 * @returns {Entity} Self to allow chaining
		 */
		// will not show the entity (and it's children) if any of its ancestors are hidden
		show: function () {
			this._hidden = false;

			// first search if it has hidden parents to determine if itself should be visible
			var pointer = this;
			while (pointer.transformComponent.parent) {
				pointer = pointer.transformComponent.parent.entity;
				if (pointer._hidden) {
					// extra check and set might be needed
					for (var i = 0; i < this._components.length; i++) {
						var component = this._components[i];
						if (typeof component.hidden === 'boolean') {
							component.hidden = true;
						}
					}
					return this;
				}
			}

			this.traverse(function (entity) {
				if (entity._hidden) { return false; }
				for (var i = 0; i < entity._components.length; i++) {
					var component = entity._components[i];
					if (typeof component.hidden === 'boolean') {
						component.hidden = entity._hidden;
					}
				}
			});

			return this;
		},

		/**
		 * Returns whether the entity or any of its ancestors are hidden. Injected on entities with a transformComponent
		 * @target-class Entity isVisiblyHidden method
		 * @returns {boolean}
		 */
		isVisiblyHidden: function () {
			var pointer = this;

			if (pointer._hidden) {
				return true;
			}

			while (pointer.transformComponent.parent) {
				pointer = pointer.transformComponent.parent.entity;
				if (pointer._hidden) {
					return true;
				}
			}

			return false;
		},

		/**
		 * Returns the 'hidden' status of this entity. The entity may still be hidden if one of its ancestors is hidden. Injected on entities with a transformComponent
		 * @target-class Entity isHidden method
		 * @returns {boolean}
		 */
		isHidden: function () {
			return this._hidden;
		}
	};

	TransformComponent.entitySelectionAPI = {
		setTranslation: TransformComponent.prototype.api.setTranslation,
		setRotation: TransformComponent.prototype.api.setRotation,
		setScale: TransformComponent.prototype.api.setScale,
		lookAt: TransformComponent.prototype.api.lookAt,
		move: TransformComponent.prototype.api.move,
		addTranslation: TransformComponent.prototype.api.addTranslation,
		addRotation: TransformComponent.prototype.api.addRotation,
		hide: TransformComponent.prototype.api.hide,
		show: TransformComponent.prototype.api.show
	};

	var tmpVec = new Vector3();

	/**
	 * Gets the value of transformComponent.transform.translation.
	 * To change the translation, the returned object can be modified
	 * after which transformComponent.setUpdated() must be called.
	 * Alternatively, use setTranslation or addTranslation which call
	 * setUpdated() automatically.
	 * <br /><i>Injected into entity when adding component.</i>
	 * @example
	 * var boxTranslation1 = boxEntity.transformComponent.getTranslation();
	 * var boxTranslation2 = boxEntity.getTranslation();
	 * console.log(boxTranslation1 === boxTranslation2); // true
	 *
	 * @returns {Vector3} translation
	 */
	TransformComponent.prototype.getTranslation = function () {
		return this.transform.translation;
	};

	/**
	 * Sets this transform's translation.
	 * <br /><i>Injected into entity when adding component.</i>
	 * @example
	 * // The lines below are equivalent.
	 * sphereEntity.transformComponent.setTranslation(1, 1, 0);
	 * sphereEntity.setTranslation(1, 1, 0);
	 * sphereEntity.setTranslation(new Vector3(1, 1, 0));
	 *
	 * @param {(Vector | Array<number>)} translation Component values.
	 * @returns {TransformComponent} Self for chaining.
	 */
	TransformComponent.prototype.setTranslation = function () {
		this.transform.translation.set(Vector3.fromAny.apply(null, arguments));
		this._dirty = true;
		return this;
	};

	/**
	 * Gets the value of transformComponent.transform.scale.
	 * To change the scale, the returned object can be modified
	 * after which transformComponent.setUpdated() must be called.
	 * Alternatively, use setScale which calls setUpdated() automatically.
	 * <br /><i>Injected into entity when adding component.</i>
	 * @example
	 * var scale1 = entity.transformComponent.getScale();
	 * var scale2 = entity.getScale();
	 * console.log(scale1 === scale2); // true
	 *
	 * @returns {Vector3} scale
	 */
	TransformComponent.prototype.getScale = function () {
		return this.transform.scale;
	};

	/**
	 * Sets this transform's scale.
	 * <br /><i>Injected into entity when adding component.</i>
	 *
	 * @param {(Vector | Array<number>)} Component values.
	 * @returns {TransformComponent} Self for chaining.
	 */
	TransformComponent.prototype.setScale = function () {
		this.transform.scale.set(Vector3.fromAny.apply(null, arguments));
		this._dirty = true;
		return this;
	};

	/**
	 * Adds to this transform's translation.
	 * <br /><i>Injected into entity when adding component.</i>
	 * @example
	 * // Lines below are equivalent
	 * boxEntity.addTranslation(new Vector(1, 2, 1));
	 * boxEntity.transformComponent.addTranslation(1, 2, 1);
	 *
     * @param {(Vector | Array<number>)} Component values.
	 * @returns {TransformComponent} Self for chaining.
	 */
	TransformComponent.prototype.addTranslation = function () {
		this.transform.translation.add(Vector3.fromAny.apply(null, arguments));
		this._dirty = true;
		return this;
	};

	/**
	 * Gets the value of transformComponent.transform.rotation in Euler angles (in radians, Euler order YZX).
	 * Returns a new Vector3 that cannot be used for modifying the rotation.
	 * <br /><i>Injected into entity when adding component.</i>.
	 * @example
	 * var rot1 = sphereEntity.getRotation();
	 * var rot2 = sphereEntity.transformComponent.getRotation();
	 * console.log(rot1 === rot2); // true
	 *
	 * @param {Vector3} [target] Target vector for storage.
	 * @returns {Vector3} rotation
	 */
	TransformComponent.prototype.getRotation = function (target) {
		target = target || new Vector3();
		return this.transform.rotation.toAngles(target);
	};

	/**
	 * Adds to this transform's rotation using Euler angles (in radians, Euler order YZX).
	 * <br /><i>Injected into entity when adding component.</i>
	 * @example
	 * boxEntity.setRotation(Math.PI/4.0, 0, 0);
	 * console.log(boxEntity.getRotation().toString()); // [0.79, 0, 0]
	 * boxEntity.addRotation(new Vector3(MathUtils.DEG_TO_RAD * 45.0, 0, 0));
	 * console.log(boxEntity.getRotation().toString()); // [1.57, 0, 0]
	 *
	 * @param {(Vector | Array<number>)} Component values.
	 * @returns {TransformComponent} Self for chaining.
	 */
	TransformComponent.prototype.addRotation = function () {
		this.getRotation(tmpVec);
		if (arguments.length === 1 && typeof (arguments[0]) === 'object') {
			var arg0 = arguments[0];
			if (arg0 instanceof Vector3) {
				this.transform.rotation.fromAngles(tmpVec.x + arg0.x, tmpVec.y + arg0.y, tmpVec.z + arg0.z);
			} else if (arg0.length === 3) {
				this.transform.rotation.fromAngles(tmpVec.x + arg0[0], tmpVec.y + arg0[1], tmpVec.z + arg0[2]);
			}
		} else {
			this.transform.rotation.fromAngles(tmpVec.x + arguments[0], tmpVec.y + arguments[1], tmpVec.z + arguments[2]);
		}

		this._dirty = true;
		return this;
	};

	/**
	 * Sets this transform's rotation around X, Y and Z axis (in radians, Euler order YZX).
	 * The rotation is applied in X, Y, Z order.
	 * <br /><i>Injected into entity when adding component.</i>
	 * @example
	 * boxEntity.setRotation(Math.PI, 0, 0);
	 * console.log(boxEntity.getRotation().toString()); // [3.14, 0, 0]
	 *
	 * @param {(Vector | Array<number>)} Component values.
	 * @returns {TransformComponent} Self for chaining.
	 */
	TransformComponent.prototype.setRotation = function () {
		if (arguments.length === 1 && typeof (arguments[0]) === 'object') {
			var arg0 = arguments[0];
			if (arg0 instanceof Vector3) {
				this.transform.rotation.fromAngles(arg0.x, arg0.y, arg0.z);
			} else if (arg0.length === 3) {
				this.transform.rotation.fromAngles(arg0[0], arg0[1], arg0[2]);
			}
		} else {
			this.transform.rotation.fromAngles(arguments[0], arguments[1], arguments[2]);
		}

		this._dirty = true;
		return this;
	};

	/**
	 * Sets the transform to look in a specific direction.
	 * <br /><i>Injected into entity when adding component.</i>
	 *
	 * @param {(Vector3|Entity)} position Target position.
	 * @param {Vector3} [up=(0, 1, 0)] Up vector.
	 * @returns {TransformComponent} Self for chaining.
	 */
	TransformComponent.prototype.lookAt = function (position, up) {
		//! AT: needs updating of transform before the actual lookAt to account for changes in translation
		if (arguments.length === 3) {
			this.transform.lookAt(new Vector3(arguments[0], arguments[1], arguments[2]));
		} else if (position.transformComponent) {
			if (position.transformComponent._dirty) {
				position.transformComponent.updateWorldTransform();
			}
			this.transform.lookAt(position.transformComponent.worldTransform.translation, up);
		} else {
			if (Array.isArray(position)) {
				position = Vector3.fromArray(position);
			}
			if (Array.isArray(up)) {
				up = Vector3.fromArray(up);
			}
			this.transform.lookAt(position, up);
		}
		this._dirty = true;
		return this;
	};

	/**
	 * Adds to the translation in a local direction.<br/>
	 * This is similar to addTranslation but this function takes the argument in local coordinate space and converts it for you.<br/>
	 * So for example move(0, 0, -1) moves forward (because of the right handed coordinate system).<br/>
	 * <i>Injected into entity when adding component.</i>
	 *
	 * @function
	 * @param {(Vector | Array<number>)} component values.
	 * @returns {TransformComponent} Self for chaining.
	 */
	TransformComponent.prototype.move = (function () {
		var moveWorldDirection = new Vector3();
		return function () {
			var moveLocalDirection = Vector3.fromAny.apply(null, arguments);
			this.transform.applyForwardVector(moveLocalDirection, moveWorldDirection);
			this.addTranslation(moveWorldDirection);
			return this;
		};
	})();

	/**
	 * Mark the component for updates of world transform. Needs to be called after manually changing the transform without using helper functions.
	 */
	TransformComponent.prototype.setUpdated = function () {
		this._dirty = true;
	};

	/**
	 * Handles attaching itself to an entity. Should only be called by the engine.
	 * @private
	 * @param entity
	 */
	TransformComponent.prototype.attached = function (entity) {
		this.entity = entity;
	};

	/**
	 * Handles detaching itself to an entity. Should only be called by the engine.
	 * @private
	 * @param entity
	 */
	TransformComponent.prototype.detached = function (/*entity*/) {
		this.entity = undefined; //! AT: used to be 'undefined' when it was handled in Entity; should instead be null
	};

	/**
	 * Attach a child transform to this component tree
	 * <br /><i>Injected into entity when adding component.</i>
	 *
	 * @param {TransformComponent} childComponent Child transform component to attach
	 * @param {boolean} [keepTransform=false] If enabled, the child's position, rotation and scale will appear unaffected
	 */
	TransformComponent.prototype.attachChild = function (childComponent, keepTransform) {
		var component = this;
		while (component) {
			if (component === childComponent) {
				console.warn('attachChild: An object can\'t be added as a descendant of itself.');
				return;
			}
			component = component.parent;
		}
		if (childComponent.parent) {
			childComponent.parent.detachChild(childComponent);
		}

		if (keepTransform) {
			childComponent.updateTransform();
			this.updateTransform();
			this.updateWorldTransform();
			childComponent.transform.multiply(this.worldTransform.invert(), childComponent.transform);
		}

		childComponent.parent = this;
		this.children.push(childComponent);

		// childComponent.setUpdated();
	};

	/**
	 * Detach a child transform from this component tree.
	 * <br /><i>Injected into entity when adding component.</i>
	 *
	 * @param {TransformComponent} childComponent child transform component to detach
	 * @param {boolean} [keepTransform=false] If enabled, the child's position, rotation and scale will appear unaffected
	 */
	TransformComponent.prototype.detachChild = function (childComponent, keepTransform) {
		if (childComponent === this) {
			console.warn('detachChild: An object can\'t be removed from itself.');
			return;
		}

		if (keepTransform) {
			childComponent.transform.copy(childComponent.worldTransform);
		}

		var index = this.children.indexOf(childComponent);
		if (index !== -1) {
			childComponent.parent = null;
			this.children.splice(index, 1);
		}

		// childComponent.setUpdated();
	};

	/**
	 * Update component's transform.
	 */
	TransformComponent.prototype.updateTransform = function () {
		this.transform.update();
	};

	/**
	 * Update component's world transform (resulting transform considering parent transformations).
	 */
	TransformComponent.prototype.updateWorldTransform = function () {
		if (this.parent) {
			this.worldTransform.multiply(this.parent.worldTransform, this.transform);
		} else {
			this.worldTransform.copy(this.transform);
		}

		this.worldTransform.updateNormalMatrix();

		this._dirty = false;
		this._updated = true;
	};

	TransformComponent.applyOnEntity = function (obj, entity) {
		var transformComponent = entity.transformComponent;

		if (!transformComponent) {
			transformComponent = new TransformComponent();
		}

		var matched = false;
		if (Array.isArray(obj) && obj.length === 3) {
			transformComponent.transform.translation.setDirect(obj[0], obj[1], obj[2]);
			matched = true;
		} else if (obj instanceof Vector3) {
			transformComponent.transform.translation.setDirect(obj.x, obj.y, obj.z);
			matched = true;
		} else if (typeof obj === 'object' &&
			typeof obj.x !== 'undefined' && typeof obj.y !== 'undefined' && typeof obj.z !== 'undefined') {
			transformComponent.transform.translation.setDirect(obj.x, obj.y, obj.z);
			matched = true;
		} else if (obj instanceof Transform) {
			transformComponent.transform = obj;
			matched = true;
		}

		if (matched) {
			transformComponent.setUpdated();
			entity.setComponent(transformComponent);
			return true;
		}
	};

	return TransformComponent;
})(goo.Transform,goo.Vector3,goo.Component,goo.EntitySelection);
goo.System = (function () {
	'use strict';

	/**
	 * Creates a new System
	 *
	 * Base class for all entity systems
	 *        <ul>
	 *        <li> interests = null -> listen to all entities
	 *        <li> interests = [] -> don't listen to any entities
	 *        <li> interests = ['coolComponent', 'testComponent'] -> listen to entities that contains at minimum 'coolComponent' and 'testComponent'
	 *        </ul>
	 * See [this engine overview article]{@link http://www.gootechnologies.com/learn/tutorials/engine/engine-overview/} for more info.
	 * @param {string} type System type name as a string
	 * @param {Array<String>} interests Array of component types this system is interested in
	 * @property {string} type System type
	 * @property {Array<String>} interests Array of component types this system is interested in
	 */
	function System(type, interests) {
		this.type = type;
		this.interests = interests;

		this._activeEntities = [];
		this.passive = false;

		/**
		 * Priority of a system. The lower the number the higher the priority is. By default a systems has priority 0. Internal goo systems (like TransformSystem and CameraSystem) should have negative priority.
		 * @type {number}
		 */
		this.priority = 0;
	}

	/**
	 * Called when an entity is added to the world and systems need to be informed
	 * @param entity
	 */
	System.prototype.added = function (entity) {
		//! AT: added shouldn't call _check as it doesn't need to do as much as _check
		this._check(entity);
	};

	/**
	 * Called when an entity gets/loses components
	 * @param entity
	 */
	System.prototype.changed = function (entity) {
		//! AT: can directly say: System.prototype.changed = _check;
		this._check(entity);
	};

	/**
	 * Called when an entity is removed from the world
	 * @param entity
	 */
	System.prototype.removed = function (entity) {
		var index = this._activeEntities.indexOf(entity);
		if (index !== -1) {
			this._activeEntities.splice(index, 1);
			if (this.deleted) {
				this.deleted(entity);
			}
		}
	};

	/**
	 * Called when the system is added to the world.
	 * This method is called automatically when the system is added to a world.
	 * By default it will go through all entities
	 * accounted by the entity manager and try to add them to this system.
	 * @param {World} world
	 */
	System.prototype.setup = function (world) {
		world.entityManager.getEntities().forEach(this._check.bind(this));
	};

	/**
	 * Called when the system is removed from the world.
	 * By default it will call the deleted method on all entities it is keeping track of.
	 */
	System.prototype.cleanup = function () {
		if (this.deleted) {
			for (var i = 0; i < this._activeEntities.length; i++) {
				var entity = this._activeEntities[i];
				this.deleted(entity);
			}
		}
	};

	function getTypeAttributeName(type) {
		return type.charAt(0).toLowerCase() + type.substr(1);
	}

	/**
	 * Checks if a system is interested in an entity based on its interests list and adds or removed the entity from the system's index
	 * @param entity {Entity} to check if the system is interested in
	 * @private
	 */
	System.prototype._check = function (entity) {
		if (this.interests && this.interests.length === 0) {
			return;
		}
		var isInterested = this.interests === null;
		if (!isInterested && this.interests.length <= entity._components.length) {
			isInterested = true;
			for (var i = 0; i < this.interests.length; i++) {
				var interest = getTypeAttributeName(this.interests[i]);

				if (!entity[interest]) {
					isInterested = false;
					break;
				}
			}
		}

		var index = this._activeEntities.indexOf(entity);
		if (isInterested && index === -1) {
			this._activeEntities.push(entity);
			if (this.inserted) {
				this.inserted(entity);
			}
		} else if (!isInterested && index !== -1) {
			this._activeEntities.splice(index, 1);
			if (this.deleted) {
				this.deleted(entity);
			}
		}
	};

	System.prototype._process = function (tpf) {
		if (this.process) { // are there systems without a this.process?
			this.process(this._activeEntities, tpf);
		}
	};

	System.prototype.clear = function () {
		this._activeEntities = [];
	};

	return System;
})();
goo.World = (function (
	Entity,
	EntityManager,
	TransformComponent,
	Manager,
	System,
	Component,
	EntitySelection
) {
	'use strict';

	/**
	 * Main handler for an entity world. The World keeps track of managers and systems,
	 * and also provides methods to create, select and remove entities.
	 * Note that process() has to be called manually if objects need to be added and retrieved within the same update loop.
	 * See [this engine overview article]{@link http://www.gootechnologies.com/learn/tutorials/engine/engine-overview/} for more info.
	 * @param {GooRunner} gooRunner GooRunner for updating the world and calling the renderers.
	 */
	function World(gooRunner) {
		/** GooRunner for updating the world and calling the renderers.
		 * @type {GooRunner}
		 */
		this.gooRunner = gooRunner;

		this._managers = [];
		this._systems = [];

		this._addedEntities = [];
		this._changedEntities = [];
		this._removedEntities = [];

		this.by = {};
		this._installDefaultSelectors();

		/** Main keeper of entities.
		 * @type {EntityManager}
		 */
		this.entityManager = new EntityManager();
		this.setManager(this.entityManager);

		/** Accumulated time per frames(tpf) the world has been running.  Calculated at the start of each frame.
		 * @type {number}
		 */
		this.time = 0.0;

		/** Time since last frame in seconds.
		 * @type {number}
		 */
		this.tpf = 1.0;

		this._components = [];
	}

	//! AT: these need to go
	World.time = 0.0;
	World.tpf = 1.0;


	/** Entity selector. Its methods return an {@link EntitySelection}. Can select by system, component, attribute or tag. See examples for usage.
	 * <br><i>Will get additional methods when an {@link EntityManager} is attached.</i>
	 * @member by
	 * @memberOf World.prototype
	 * @example
	 * var bySystem = gooRunner.world.by.system("RenderSystem").toArray();
	 * var byComponent = gooRunner.world.by.component("cameraComponent").toArray();
	 * var byTag = gooRunner.world.by.tag("monster").toArray()
	 * var byAttribute = gooRunner.world.by.attribute("hit-points").toArray();
	 */
	World.prototype._installDefaultSelectors = function () {
		this.by.system = function (systemType) {
			var system = this.getSystem(systemType);
			return new EntitySelection(system._activeEntities);
		}.bind(this);

		this.by.component = function (componentType) {
			var entities = this.entityManager.getEntities();

			return new EntitySelection(entities.filter(function (entity) {
				return entity.hasComponent(componentType);
			}));
		}.bind(this);

		//! AT: this will be relocated into the Tag Manager once it gets implemented
		this.by.tag = function (tag) {
			var entities = this.entityManager.getEntities();

			return new EntitySelection(entities.filter(function (entity) {
				return entity.hasTag(tag);
			}));
		}.bind(this);

		//! AT: this will be relocated into the Attribute Manager once it gets implemented
		this.by.attribute = function (attribute) {
			var entities = this.entityManager.getEntities();

			return new EntitySelection(entities.filter(function (entity) {
				return entity.hasAttribute(attribute);
			}));
		}.bind(this);
	};

	/**
	 * Universal shorthand for adding managers, systems, entities and registering components.
	 * Arguments can be of types Entity, Manager, System or Component and added in any order or combination.
	 * @param {Entity} [entity]
	 * @param {Manager} [manager]
	 * @param {System} [system]
	 * @param {Component} [component]
	 * @example
	 * // Add two entities and register a component, all in one swoop
	 * var entity1 = new Entity(gooRunner.world, 'Entity 1');
	 * var entity2 = new Entity(gooRunner.world, 'Entity 2');
	 * var animationComponent = new AnimationComponent();
	 * gooRunner.world.add(entity1, animationComponent, entity2);
	 *
	 * @returns {World} Returns self to allow chaining
	 */
	//! AT: again, 'set' vs 'add' - entities are added to the world, systems/managers are set
	World.prototype.add = function () {
		for (var i = 0; i < arguments.length; i++) {
			var argument = arguments[i];

			if (argument instanceof Entity) {
				this.addEntity(argument);
			} else if (argument instanceof Manager) {
				this.setManager(argument);
			} else if (argument instanceof System) {
				this.setSystem(argument);
			} else if (argument instanceof Component) {
				//! AT: TransformComponent and co and NOT instances of Component
				this.registerComponent(argument);
			}
		}

		return this;
	};

	/**
	 * Registers a component type. This is necessary to allow automatic creation of components
	 * from 'basic' data types (CameraComponents from Cameras, MeshRendererComponents from materials and so on).
	 * When a {@link GooRunner} is created, it registers {@link TransformComponent}, {@link MeshDataComponent},
	 * {@link MeshRendererComponent}, {@link CameraComponent}, {@link LightComponent} and {@link ScriptComponent} automatically.
	 * @example
	 * // Register the animation component type so that animations
	 * // can be automatically created.
	 * gooRunner.world.registerComponent(AnimationComponent);
	 *
	 * @param {Component} componentConstructor
	 * @returns {World} Returns self to allow chaining.
	 */
	World.prototype.registerComponent = function (componentConstructor) {
		if (this._components.indexOf(componentConstructor) === -1) {
			this._components.push(componentConstructor);
			Component.applyEntitySelectionAPI(componentConstructor.entitySelectionAPI, componentConstructor.type);
		}
		return this;
	};

	/**
	 * Adds a {@link Manager} to the world.
	 *
	 * @param {Manager} manager
	 * @returns {World} Returns self to allow chaining.
	 */
	World.prototype.setManager = function (manager) {
		this._managers.push(manager);
		manager.applyAPI(this.by);
		return this;
	};

	/**
	 * Retrieves a {@link Manager} of a certain type.
	 *
	 * @param {string} type Type of manager to retrieve eg. 'EntityManager'.
	 * @returns {Manager}
	 */
	World.prototype.getManager = function (type) {
		for (var i = 0; i < this._managers.length; i++) {
			var manager = this._managers[i];
			if (manager.type === type) {
				return manager;
			}
		}
	};

	/**
	 * Adds a {@link System} to the world.
	 *
	 * @param {System} system
	 * @returns {World} Returns self to allow chaining.
	 */
	World.prototype.setSystem = function (system) {
		if (this._systems.indexOf(system) !== -1) {
			return this;
		}

		var priority = system.priority;

		for (var i = 0; i < this._systems.length; i++) {
			if (this._systems[i].priority > priority) {
				break;
			}
		}
		this._systems.splice(i, 0, system);

		if (system.setup) { system.setup(this); }

		return this;
	};

	/**
	 * Retrieve a {@link System} of type 'type'.
	 *
	 * @param {string} type Type of system to retrieve.
	 * @returns {System}
	 */
	World.prototype.getSystem = function (type) {
		for (var i = 0; i < this._systems.length; i++) {
			var system = this._systems[i];
			if (system.type === type) {
				return system;
			}
		}
	};

	/**
	 * Removes the {@link System} of type 'type'.
	 * Entities tracked by the removed system will not get handled properly when they are removed from the world
	 * or when their components (that are tracked by this system) change.
	 *
	 * @param {string} type Type of system to remove.
	 * @returns {World} Returns self to allow chaining.
	 */
	World.prototype.clearSystem = function (type) {
		for (var i = 0; i < this._systems.length; i++) {
			var system = this._systems[i];
			if (system.type === type) {
				if (system.cleanup) {
					system.cleanup();
				}
				this._systems.splice(i, 1);
			}
		}
		return this;
	};

	/**
	 * Creates a new {@link Entity} with an optional MeshData, MeshRenderer, Camera, Script and Light component, placed optionally at a location. Parameters can be given in any order.
	 * @example
	 * // Create a sphere entity and add it to the world
	 * var sphereEntity = world.createEntity(new Sphere(32, 32), material, [0, 0, 5]).addToWorld();
	 * // Create a camera entity and add it to the world
	 * var cameraEntity = world.createEntity(new Camera(), [0, 0, 3]).lookAt(new Vector3(0, 0, 0)).addToWorld();
	 *
	 * @param {MeshData} [meshData]
	 * @param {Material} [material]
	 * @param {string} [name]
	 * @param {Camera} [camera]
	 * @param {Light} [light]
	 * @returns {Entity}
	 */
	World.prototype.createEntity = function () {
		var entity = new Entity(this);
		for (var i = 0; i < arguments.length; i++) {
			if (typeof arguments[i] === 'string') { // does not cover new String()
				entity.name = arguments[i];
			} else {
				entity.set(arguments[i]);
			}
		}

		// separate treatment
		if (!entity.transformComponent) {
			entity.setComponent(new TransformComponent());
		}

		return entity;
	};

	/**
	 * Get an array of all entities in world.
	 *
	 * @returns {Array<Entity>} All entities existing in world.
	 */
	World.prototype.getEntities = function () {
		return this.entityManager.getEntities();
	};

	/**
	 * Add an {@link Entity} to the world.
	 *
	 * @param {Entity} entity Entity to add.
	 * @param {boolean} [recursive=true] If entity hierarchy should be added recursively.
	 * @returns {World} Returns self to allow chaining.
	 */
	World.prototype.addEntity = function (entity, recursive) {
		if (this._addedEntities.indexOf(entity) === -1) {
			this._addedEntities.push(entity);
		}

		if (entity.transformComponent && (recursive === undefined || recursive === true)) {
			var children = entity.transformComponent.children;
			for (var i = 0; i < children.length; i++) {
				this.addEntity(children[i].entity, recursive);
			}
		}

		// directly add to managers
		for (var i = 0; i < this._managers.length; i++) {
			var manager = this._managers[i];
			manager.added(entity);
		}

		return this;
	};

	/**
	 * Remove an {@link Entity} from the world.
	 *
	 * @param {Entity} entity Entity to remove.
	 * @param {boolean} [recursive=true] If entity hierarchy should be removed recursively.
	 * @returns {World} Returns self to allow chaining.
	 */
	World.prototype.removeEntity = function (entity, recursive) {
		if (this._removedEntities.indexOf(entity) === -1) {
			this._removedEntities.push(entity);
		}

		var transformComponent = entity.transformComponent;
		if (transformComponent.parent) {
			transformComponent.parent.detachChild(transformComponent);
			transformComponent.parent = null;
		}

		if (recursive === false) {
			var children = transformComponent.children;
			for (var i = 0; i < children.length; i++) {
				children[i].parent = null;
			}

			transformComponent.children = [];
		} else {
			var children = transformComponent.children;
			for (var i = 0; i < children.length; i++) {
				this._recursiveRemoval(children[i].entity, recursive);
			}
		}

		// directly remove from managers
		for (var i = 0; i < this._managers.length; i++) {
			var manager = this._managers[i];
			manager.removed(entity);
		}

		return this;
	};

	World.prototype._recursiveRemoval = function (entity, recursive) {
		if (this._removedEntities.indexOf(entity) === -1) {
			this._removedEntities.push(entity);
		}

		// this and the whole recursive removal needs refactoring
		for (var i = 0; i < this._managers.length; i++) {
			var manager = this._managers[i];
			manager.removed(entity);
		}

		if (entity.transformComponent && (recursive === undefined || recursive === true)) {
			var children = entity.transformComponent.children;
			for (var i = 0; i < children.length; i++) {
				this._recursiveRemoval(children[i].entity, recursive);
			}
		}
	};

	/**
	 * Let the world and its systems know that an entity has been changed/updated.
	 *
	 * @param entity
	 * @param component
	 * @param eventType
	 */
	World.prototype.changedEntity = function (entity, component, eventType) {
		var event = {
			entity: entity
		};
		if (component !== undefined) {
			event.component = component;
		}
		if (eventType !== undefined) {
			event.eventType = eventType;
		}
		this._changedEntities.push(event);
	};

	/**
	 * Processes newly added entities, changed entities and removed entities
	 */
	World.prototype.processEntityChanges = function () {
		this._check(this._addedEntities, function (observer, entity) {
			if (observer.added) {
				observer.added(entity);
			}

			// not in use by any system
			if (observer.addedComponent) {
				for (var i = 0; i < entity._components.length; i++) {
					observer.addedComponent(entity, entity._components[i]);
				}
			}
		});
		this._check(this._changedEntities, function (observer, event) {
			if (observer.changed) {
				observer.changed(event.entity);
			}
			if (event.eventType !== undefined) {
				if (observer[event.eventType]) {
					observer[event.eventType](event.entity, event.component);
				}
			}
		});
		this._check(this._removedEntities, function (observer, entity) {
			if (observer.removed) {
				observer.removed(entity);
			}

			// not in use by any system
			if (observer.removedComponent) {
				for (var i = 0; i < entity._components.length; i++) {
					observer.removedComponent(entity, entity._components[i]);
				}
			}
		});
	};

	/**
	 * Process all added/changed/removed entities and callback to active systems and managers. Usually called automatically each frame.
	 * Has to be called between adding an entity to the world and getting it back.
	 */
	World.prototype.process = function () {
		this.processEntityChanges();

		for (var i = 0; i < this._systems.length; i++) {
			var system = this._systems[i];
			if (!system.passive) {
				system._process(this.tpf);
			}
		}
	};

	World.prototype._check = function (entities, callback) {
		// each entity needs to be "checked" against each system
		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			for (var systemIndex = 0; systemIndex < this._systems.length; systemIndex++) {
				var system = this._systems[systemIndex];
				callback(system, entity);
			}
		}

		entities.length = 0;
	};

	/**
	 * Calls .clear on all systems that support this method
	 */
	World.prototype.clear = function () {
		for (var i = 0; i < this._systems.length; i++) {
			var system = this._systems[i];
			if (system.clear) {
				system.clear();
			}
		}

		this._systems = [];

		// severe all connections from entities to this world
		var allEntities = this.entityManager.getEntities();
		for (var i = 0; i < allEntities.length; i++) {
			var entity = allEntities[i];
			entity._world = null;
		}

		this.entityManager.clear();

		this._addedEntities = [];
		this._changedEntities = [];
		this._removedEntities = [];

		// severe the connection to gooRunner
		this.gooRunner = null;
	};

	return World;
})(goo.Entity,goo.EntityManager,goo.TransformComponent,goo.Manager,goo.System,goo.Component,goo.EntitySelection);
goo.RendererRecord = (function () {
	'use strict';

	/**
	 * Holds the renderer's state
	 * @hidden
	 */
	function RendererRecord() {
		this.currentBuffer = {
			'ArrayBuffer': {
				buffer: null,
				valid: false
			},
			'ElementArrayBuffer': {
				buffer: null,
				valid: false
			}
		};
		this.currentFrameBuffer = null;
		this.clippingTestValid = false;
		this.clippingTestEnabled = false;
		this.clips = [];
		this.enabledTextures = 0;
		this.texturesValid = false;
		this.currentTextureArraysUnit = 0;

		this.textureRecord = [];

		this.usedProgram = null;
		this.boundAttributes = [];
		this.enabledAttributes = [];
		this.newlyEnabledAttributes = [];

		this.depthRecord = {}; // these can be initialized with their default values
		this.cullRecord = {};
		this.blendRecord = {};
		this.offsetRecord = {};
		this.lineRecord = {};
		this.pointRecord = {};

		this.shaderCache = new Map();
		this.attributeCache = [];

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	RendererRecord.prototype.invalidateBuffer = function (target) {
		this.currentBuffer[target].buffer = null;
		this.currentBuffer[target].valid = false;
	};

	return RendererRecord;
})();
goo.rsvp = (function () {
	'use strict';
	var config = {};

	var browserGlobal = (typeof window !== 'undefined') ? window : {};

	var MutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	//var RSVP;
	var process = window.process;

	if (typeof process !== 'undefined' &&
		{}.toString.call(process) === '[object process]') {
		config.async = function (callback, binding) {
			process.nextTick(function () {
				callback.call(binding);
			});
		};
	} else if (MutationObserver) {
		var queue = [];

		var observer = new MutationObserver(function () {
			var toProcess = queue.slice();
			queue = [];

			toProcess.forEach(function (tuple) {
				var callback = tuple[0], binding = tuple[1];
				callback.call(binding);
			});
		});

		var element = document.createElement('div');
		observer.observe(element, { attributes: true });

		// Chrome Memory Leak: https://bugs.webkit.org/show_bug.cgi?id=93661
		window.addEventListener('unload', function () {
			observer.disconnect();
			observer = null;
		});

		config.async = function (callback, binding) {
			queue.push([callback, binding]);
			element.setAttribute('drainQueue', 'drainQueue');
		};
	} else {
		config.async = function (callback, binding) {
			setTimeout(function () {
				callback.call(binding);
			}, 1);
		};
	}

	var Event = function (type, options) {
		this.type = type;

		for (var option in options) {
			if (!options.hasOwnProperty(option)) {
				continue;
			}

			this[option] = options[option];
		}
	};

	var indexOf = function (callbacks, callback) {
		for (var i = 0, l = callbacks.length; i < l; i++) {
			if (callbacks[i][0] === callback) {
				return i;
			}
		}

		return -1;
	};

	var callbacksFor = function (object) {
		var callbacks = object._promiseCallbacks;

		if (!callbacks) {
			callbacks = object._promiseCallbacks = {};
		}

		return callbacks;
	};

	var EventTarget = {
		mixin: function (object) {
			object.on = this.on;
			object.off = this.off;
			object.trigger = this.trigger;
			return object;
		},

		on: function (eventNames, callback, binding) {
			var allCallbacks = callbacksFor(this), callbacks, eventName;
			eventNames = eventNames.split(/\s+/);
			binding = binding || this;

			while (eventName = eventNames.shift()) {
				callbacks = allCallbacks[eventName];

				if (!callbacks) {
					callbacks = allCallbacks[eventName] = [];
				}

				if (indexOf(callbacks, callback) === -1) {
					callbacks.push([callback, binding]);
				}
			}
		},

		off: function (eventNames, callback) {
			var allCallbacks = callbacksFor(this), callbacks, eventName, index;
			eventNames = eventNames.split(/\s+/);

			while (eventName = eventNames.shift()) {
				if (!callback) {
					allCallbacks[eventName] = [];
					continue;
				}

				callbacks = allCallbacks[eventName];

				index = indexOf(callbacks, callback);

				if (index !== -1) {
					callbacks.splice(index, 1);
				}
			}
		},

		trigger: function (eventName, options) {
			var allCallbacks = callbacksFor(this),
				callbacks, callbackTuple, callback, binding, event;

			if (callbacks = allCallbacks[eventName]) {
				for (var i = 0, l = callbacks.length; i < l; i++) {
					callbackTuple = callbacks[i];
					callback = callbackTuple[0];
					binding = callbackTuple[1];

					if (typeof options !== 'object') {
						options = { detail: options };
					}

					event = new Event(eventName, options);
					callback.call(binding, event);
				}
			}
		}
	};

	var Promise = function () {
		this.on('promise:resolved', function (event) {
			this.trigger('success', { detail: event.detail });
		}, this);

		this.on('promise:failed', function (event) {
			this.trigger('error', { detail: event.detail });
		}, this);
	};

	var noop = function () {
	};

	var invokeCallback = function (type, promise, callback, event) {
		var hasCallback = typeof callback === 'function',
			value, error, succeeded, failed;

		if (hasCallback) {
			try {
				value = callback(event.detail);
				succeeded = true;
			} catch (e) {
				failed = true;
				error = e;
			}
		} else {
			value = event.detail;
			succeeded = true;
		}

		if (value && typeof value.then === 'function') {
			value.then(function (value) {
				promise.resolve(value);
			}, function (error) {
				promise.reject(error);
			});
		} else if (hasCallback && succeeded) {
			promise.resolve(value);
		} else if (failed) {
			promise.reject(error);
		} else {
			promise[type](value);
		}
	};

	Promise.prototype = {
		then: function (done, fail) {
			var thenPromise = new Promise();

			if (this.isResolved) {
				config.async(function () {
					invokeCallback('resolve', thenPromise, done, { detail: this.resolvedValue });
				}, this);
			}

			if (this.isRejected) {
				config.async(function () {
					invokeCallback('reject', thenPromise, fail, { detail: this.rejectedValue });
				}, this);
			}

			this.on('promise:resolved', function (event) {
				invokeCallback('resolve', thenPromise, done, event);
			});

			this.on('promise:failed', function (event) {
				invokeCallback('reject', thenPromise, fail, event);
			});

			return thenPromise;
		},

		resolve: function (value) {
			resolve(this, value);

			this.resolve = noop;
			this.reject = noop;
		},

		reject: function (value) {
			reject(this, value);

			this.resolve = noop;
			this.reject = noop;
		}
	};

	function resolve(promise, value) {
		config.async(function () {
			promise.trigger('promise:resolved', { detail: value });
			promise.isResolved = true;
			promise.resolvedValue = value;
		});
	}

	function reject(promise, value) {
		config.async(function () {
			promise.trigger('promise:failed', { detail: value });
			promise.isRejected = true;
			promise.rejectedValue = value;
		});
	}

	function all(promises) {
		var i, results = [];
		var allPromise = new Promise();
		var remaining = promises.length;

		if (remaining === 0) {
			allPromise.resolve([]);
		}

		var resolve = function (index, value) {
			results[index] = value;
			if (--remaining === 0) {
				allPromise.resolve(results);
			}
		};

		var resolver = function (index) {
			return function (value) {
				resolve(index, value);
			};
		};

		var reject = function (error) {
			allPromise.reject(error);
		};

		for (i = 0; i < remaining; i++) {
			promises[i].then(resolver(i), reject);
		}
		return allPromise;
	}

	EventTarget.mixin(Promise.prototype);

	function configure(name, value) {
		config[name] = value;
	}

	return {
		Promise: Promise,
		Event: Event,
		EventTarget: EventTarget,
		all: all,
		configure: configure
	};
})();
goo.PromiseUtils = (function (
	RSVP
) {
	'use strict';

	/**
	 * Provides promise-related utility methods
	 */
	function PromiseUtils() {}

	//! AT: converting from PromiseUtils.createPromise to new RSVP.Promise is going to be trivial
	/**
	 * Same as ES6 `new Promise`
	 * @param fun
	 * @returns {RSVP.Promise}
	 */
	PromiseUtils.createPromise = function (fun) {
		var promise = new RSVP.Promise();

		fun(function (value) {
			promise.resolve(value);
		}, function (reason) {
			promise.reject(reason);
		});

		return promise;
	};

	//! AT: in line with the native Promise.resolve
	/**
	 * Creates a promise that resolves with the given argument.
	 * @param value
	 */
	PromiseUtils.resolve = function (value) {
		var promise = new RSVP.Promise();
		promise.resolve(value);
		return promise;
	};

	//! AT: in line with the native Promise.reject
	/**
	 * Creates a promise that resolves with the given argument.
	 * @param reason
	 */
	PromiseUtils.reject = function (reason) {
		var promise = new RSVP.Promise();
		promise.reject(reason);
		return promise;
	};


	var createDummyPromiseWarn = false;
	/**
	 * Create a promise that resolves or rejects immediately with the given argument.
	 * @deprecated Use PromiseUtils.resolve/reject instead.
	 * @param {any} arg
	 * @param {any} error
	 * @returns {RSVP.Promise}
	 */
	PromiseUtils.createDummyPromise = function (arg, error) {
		if (!createDummyPromiseWarn) {
			createDummyPromiseWarn = true;
			console.warn('PromiseUtils.createDummyPromise is deprecated; please consider using PromiseUtils.resolve/reject instead');
		}

		var promise = new RSVP.Promise();
		if (error) {
			promise.reject(error);
		} else {
			promise.resolve(arg);
		}
		return promise;
	};


	/**
	 * Returns a promise that resolves when all given promises are resolved or rejected.
	 * Like RSVP.all(), except that instead of rejecting, this promise always resolves.
	 *
	 * @param {Array} promises
	 * @returns {RSVP.Promise} that resolves with the results of the promises. If a
	 * promise fails, the result of that promise will be the error. But the returned
	 * promise will always resolve with an array of objects.
	 */
	PromiseUtils.optimisticAll = function (promises) {
		var resolved = 0,
			len = promises.length,
			results = [],
			promise = new RSVP.Promise();

		if (len > 0) {
			for (var i = 0; i < len; i++) {
				(function (i) {
					promises[i].then(function (result) {
						results[i] = result;
						resolved++;
						if (resolved === len) {
							promise.resolve(results);
						}
					},
					function (error) {
						results[i] = error;
						resolved++;
						if (resolved === len) {
							promise.resolve(results);
						}
					});
				})(i);
			}
		}
		else {
			promise.resolve(results);
		}
		return promise;
	};

	/**
	 * Creates a promise that is resolved within a given amount of time
	 * @param value
	 * @param {number} time
	 * @returns {Promise}
	 */
	PromiseUtils.delay = function (value, time) {
		var promise = new RSVP.Promise();
		setTimeout(function () {
			promise.resolve(value);
		}, time);
		return promise;
	};

	// the doc doesn't align with half of what this function actually does
	/**
	 * Create a promise that resolves or rejects after the specified delay with the given argument.
	 * @deprecated Deprecated as of v0.14.x and scheduled for removal in v0.16.0; consider using
	 * PromiseUtils.delay instead
	 * @param {number} delay in ms
	 * @returns {RSVP.Promise}
	 */
	PromiseUtils.defer = function (delay, arg) {
		var p1, p2, promise;
		promise = new RSVP.Promise();
		if (arg.apply) {
			p1 = new RSVP.Promise();
			p2 = p1.then(function () {
				return arg();
			});
			setTimeout(function () {
				p1.resolve();
			}, delay);
			return p2;
		} else {
			setTimeout(function () {
				promise.resolve(arg);
			}, delay);
		}
		return promise;
	};

	return PromiseUtils;
})(goo.rsvp);
goo.Texture = (function (
	Vector2,
	PromiseUtils,
	ObjectUtils
) {
	'use strict';

	/**
	 * <code>Texture</code> defines a texture object to be used to display an image on a piece of geometry. The image to be displayed is
	 *        defined by the <code>Image</code> class. All attributes required for texture mapping are contained within this class. This includes
	 *        mipmapping if desired, magnificationFilter options, apply options and correction options. Default values are as follows:
	 *        minificationFilter - NearestNeighborNoMipMaps, magnificationFilter - NearestNeighbor, wrap - EdgeClamp on S, T and R, apply - Modulate,
	 *        environment - None.
	 * @param {Image} image Image to use as base for texture
	 * @param {Object} settings Texturing settings
	 * @param {string} [settings.wrapS='Repeat'] possible values:
	 *		<ul>
	 *			<li>'Repeat' = Repeat texture (ignore integer part of texture coords)
	 *			<li>'MirroredRepeat' = Repeat with reversed direction on odd integer part of texture coords
	 *			<li>'EdgeClamp' = Clamp texture coord range to 0..1 and use edge color
	 *		</ul>
	 * @param {string} [settings.wrapT='Repeat'] possible values:
	 *		<ul>
	 *			<li>'Repeat' = Repeat texture (ignore integer part of texture coords)
	 *			<li>'MirroredRepeat' = Repeat with reversed direction on odd integer part of texture coords
	 *			<li>'EdgeClamp' = Clamp texture coord range to 0..1 and use edge color
	 *		</ul>
	 * @param {string} [settings.magFilter='Bilinear'] possible values:
	 *		<ul>
	 *			<li>'NearestNeighbor' =
	 *			<li>'Bilinear' =
	 *		</ul>
	 * @param {string} [settings.minFilter='TriLinear'] possible values:
	 *		<ul>
	 *			<li>'NearestNeighborNoMipMaps' =
	 *			<li>'NearestNeighborNearestMipMap' =
	 *			<li>'NearestNeighborLinearMipMap' =
	 *			<li>'BilinearNoMipMaps' =
	 *			<li>'BilinearNearestMipMap' =
	 *			<li>'Trilinear' =
	 *		</ul>
	 * @param {number} [settings.anisotropy=1] Amount of anisotropic filtering (1=1x, 4=4x etc, max usually 4 or 16. Card max in Capabilities.maxAnisotropy)
	 * @param {string} [settings.format='RGBA'] possible values:
	 *		<ul>
	 *			<li>'RGBA' =
	 *			<li>'RGB' =
	 *			<li>'Alpha' =
	 *			<li>'Luminance' =
	 *			<li>'LuminanceAlpha' =
	 *		</ul>
	 * @param {string} [settings.type='UnsignedByte'] possible values:
	 *		<ul>
	 *			<li>'UnsignedByte' =
	 *			<li>'UnsignedShort565' =
	 *			<li>'UnsignedShort4444' =
	 *			<li>'UnsignedShort5551' =
	 *			<li>'Float' =
	 *		</ul>
	 * @param {Array} [settings.offset=(0, 0)] Texture offset
	 * @param {Array} [settings.repeat=(1, 1)] Texture repeat/scale
	 * @param {boolean} [settings.generateMipmaps='true'] Automatically generate mipmaps
	 * @param {boolean} [settings.premultiplyAlpha='false'] Premultiply alpha
	 * @param {number} [settings.unpackAlignment=1] Unpack alignment setting
	 * @param {boolean} [settings.flipY='true'] Flip texture in y-axis
	 * @param {number} width Width of the texture
	 * @param {number} height Height of the texture
	 */
	function Texture(image, settings, width, height) {
		this.glTexture = null;

		settings = settings || {};

		ObjectUtils.copyOptions(this, settings, {
			wrapS: 'Repeat',
			wrapT: 'Repeat',
			magFilter: 'Bilinear',
			minFilter: 'Trilinear',
			format: 'RGBA',
			type: 'UnsignedByte',
			generateMipmaps: true,
			premultiplyAlpha: false,
			unpackAlignment: 1,
			flipY: true
		});

		/**
		 * The anisotropic filtering level.
		 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/texture/AnisotropicFiltering/Anisotropic-vtest.html Working example
		 * @type {number}
		 */
		this.anisotropy = settings.anisotropy !== undefined ? settings.anisotropy : 1;

		this.variant = '2D'; // CUBE

		this.offset = settings.offset ?	Vector2.fromAny(settings.offset) : new Vector2(0, 0);
		this.repeat = settings.repeat ? Vector2.fromAny(settings.repeat) : new Vector2(1, 1);

		this.lodBias = 0.0;

		this.hasBorder = false;

		this.needsUpdate = false;
		this.updateCallback = null;
		this.readyCallback = null;

		this._originalImage = null;
		this._originalWidth = 0;
		this._originalHeight = 0;

		this.image = null;
		if (image) {
			this.setImage(image, width, height, settings);
		}

		this.loadImage = PromiseUtils.resolve.bind(null, this);

		this.textureRecord = {};

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	/**
	* Checks if the texture's data is ready.
	* @returns {boolean} True if ready.
	*/
	Texture.prototype.checkDataReady = function () {
		return this.image && (this.image.dataReady || this.image instanceof HTMLImageElement) || this.readyCallback !== null && this.readyCallback();
	};

	/**
	* Checks if the texture needs an update.
	* @returns {boolean} True if needed.
	*/
	Texture.prototype.checkNeedsUpdate = function () {
		//! AT: what's the precedence here? || first and then && or the other way around?
		return this.needsUpdate || this.updateCallback !== null && this.updateCallback();
	};

	/**
	 * Marks the texture as needing to be updated by the engine.
	 */
	Texture.prototype.setNeedsUpdate = function () {
		this.needsUpdate = true;
	};

	//! AT: this takes the same parameters as the Texture function but in a different order!
	/**
	 * Sets an image on the texture object.
	 *
	 * @param {Image} image The image to set. Can be an Image, TypedArray or an array of Images (for cubemaps)
	 * @param {number} [width]
	 * @param {number} [height]
	 */
	Texture.prototype.setImage = function (image, width, height, settings) {
		//! AT: this is not a general pattern; it is applied here only because of the complexity of this function
		this._originalImage = image;

		this.image = image; //! AT: is this always overriden? if so then why set it?

		var data = image instanceof Array ? image[0] : image;
		if (data instanceof Uint8Array || data instanceof Uint8ClampedArray || data instanceof Uint16Array || data instanceof Float32Array) {
			width = width || image.width;
			height = height || image.height;
			if (width !== undefined && height !== undefined) {
				this.image = {
					data: image,
					width: width,
					height: height,
					isData: true,
					dataReady: true
				};

				if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
					this.type = settings.type || 'UnsignedByte';
				} else if (data instanceof Uint16Array) {
					this.type = settings.type || 'UnsignedShort565';
					this.format = settings.format || 'RGB';
				} else if (data instanceof Float32Array) {
					this.type = settings.type || 'Float';
					this.format = settings.format || 'RGBA';
				}
			} else {
				throw new Error('Data textures need width and height');
			}
		} else {
			if (image instanceof Array) {
				this.image = {
					data: image
				};
			}
			if (data instanceof HTMLCanvasElement) {
				this.image.dataReady = true;
			}
		}
		this.setNeedsUpdate();

		//! AT: this is not a general pattern; it is applied here only because of the complexity of this function
		// these are delayed here in case width and height are modified in this function
		this._originalWidth = width;
		this._originalHeight = height;
	};

	/**
	 * Releases the allocated texture
	 * @param {WebGLRenderingContext} context
	 */
	Texture.prototype.destroy = function (context) {
		context.deleteTexture(this.glTexture);
		this.glTexture = null;
	};

	/**
	 * Returns the number of bytes this texture occupies in memory
	 * @returns {number}
	 */
	Texture.prototype.getSizeInMemory = function () {
		var size;

		if (!this.image) { return 0; }
		var width = this.image.width || this.image.length;
		var height = this.image.height || 1;

		size = width * height;

		if (this.format === 'Luminance' || this.format === 'Alpha') {
			size *= 1;
		} else if (this.format === 'Lumin`anceAlpha') {
			size *= 2;
		} else if (this.format === 'RGB') {
			size *= 3; // some dubious video cards may use 4 bits anyway
		} else if (this.format === 'RGBA') {
			size *= 4;
		} else if (this.format === 'PrecompressedDXT1') {
			size *= 4 / 8; // 8 : 1 ratio
		} else if (this.format === 'PrecompressedDXT1A') {
			size *= 4 / 6; // 6 : 1 ratio
		} else if (this.format === 'PrecompressedDXT3' || this.format === 'PrecompressedDXT5') {
			size *= 4 / 4; // 4 : 1 ratio
		}

		// account for mip maps
		if (this.generateMipmaps) {
			size = Math.ceil(size * 4 / 3);
		}

		return size;
	};

	/**
	 * Returns a clone of this plane
	 * @returns {Texture}
	 */
	Texture.prototype.clone = function () {
		// reconstructing original settings object passed to the constructor
		var settings = {
			wrapS: this.wrapS,
			wrapT: this.wrapT,
			magFilter: this.magFilter,
			minFilter: this.minFilter,
			anisotropy: this.anisotropy,
			format: this.format,
			type: this.type,
			offset: this.offset,
			repeat: this.repeat,
			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment,
			flipY: this.flipY
		};

		var clone = new Texture(this._originalImage, settings, this._originalWidth, this._originalHeight);
		clone.variant = this.variant;
		clone.lodBias = this.lodBias;
		clone.hasBorder = this.hasBorder;
		return clone;
	};

	Texture.CUBE_FACES = ['PositiveX', 'NegativeX', 'PositiveY', 'NegativeY', 'PositiveZ', 'NegativeZ'];

	return Texture;
})(goo.Vector2,goo.PromiseUtils,goo.ObjectUtils);
goo.ConfigHandler = (function (
	RSVP,
	PromiseUtils
) {
	'use strict';

	/**
	 * Base class for resource handlers, used to load all types of resources into the engine.
	 * All the resource types in the bundle (noted by their extension) need to have a registered config
	 * handler.
	 * To handle a new type of component, create a class that inherits from this class, and override {update}.
	 * In your class, call <code>@_register('yourResourceExtension')</code> to _register
	 * the handler with the loader.
	 *
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {DynamicLoader.update}.
	 * @hidden
	 */
	function ConfigHandler(world, getConfig, updateObject, loadObject) {
		this.world = world;
		this.getConfig = getConfig;
		this.updateObject = updateObject;
		this.loadObject = loadObject;
		this._objects = new Map();
		this._loading = new Map();
	}

	/**
	 * Method for creating empty engine object for ref. Should be overwritten in subclasses.
	 * @returns {Object} the newly created Entity, Material or other engine object
	 * @private
	 */
	ConfigHandler.prototype._create = function () {
		return {};
	};

	/**
	 * Remove the engine object denoted by the given ref. Should be overridden in subclasses.
	 * This method is called by #{DynamicLoader} to remove resources from the engine.
	 * Synchronous, returns nothing.
	 * @param {string} ref
	 * @private
	 */
	ConfigHandler.prototype._remove = function (ref) {
		this._objects.delete(ref);
	};

	/**
	 * Preparing config by populating it with defaults. Should be overwritten in subclasses.
	 * @param {Object} config
	 * @private
	 */
	ConfigHandler.prototype._prepare = function (config) {};

	/**
	 * Loads object for given ref
	 * @param {string} ref
	 * @param {Object} options
	 * @private
	 */
	ConfigHandler.prototype._load = function (ref, options) {
		return this.loadObject(ref, options);
	};

	ConfigHandler.prototype.load = function (ref, options) {
		var type = ref.substr(ref.lastIndexOf('.') + 1);
		if (type !== this.constructor._type) {
			throw new Error('Trying to load type' + type + ' with handler for ' + this._type);
		}

		if (!options) {
			options = {};
		}

		if (this._loading.has(ref) && !(options.instantiate && ConfigHandler.getTypeForRef(ref) === 'machine')) {
			return this._loading.get(ref);
		} else if (this._objects.has(ref) && !options.reload) {
			return PromiseUtils.resolve(this._objects.get(ref));
		} else {
			var promise = this.getConfig(ref, options).then(function (config) {
				return this.update(ref, config, options);
			}.bind(this))
			.then(function (object) {
				this._loading.delete(ref);
				return object;
			}.bind(this))
			.then(null, function (err) {
				this._loading.delete(ref);
				throw err;
			}.bind(this));

			return promise;
		}
	};

	ConfigHandler.prototype.clear = function () {
		var promises = [];
		this._objects.forEach(function (value, ref) {
			promises.push(this.update(ref, null, {}));
		}.bind(this));

		this._objects.clear();
		this._loading.clear();

		return RSVP.all(promises);
	};

	/**
	 * Update engine object based on the config. Should be overridden in subclasses.
	 * This method is called by #{DynamicLoader} to load new resources into the engine.
	 *
	 * @param {string} ref The ref of this config
	 * @param {Object} config
	 * @returns {RSVP.Promise} promise that resolves with the created object when loading is done.
	 */
	ConfigHandler.prototype.update = function (ref, config, options) {
		var promise = this._update(ref, config, options).then(function (object) {
			this._loading.delete(ref);
			return object;
		}.bind(this));

		this._loading.set(ref, promise);

		return promise;
	};

	ConfigHandler.getTypeForRef = function (ref) {
		return ref.substr(ref.lastIndexOf('.') + 1).toLowerCase();
	};

	ConfigHandler.prototype._update = function (ref, config, options) {
		if (!config) {
			this._remove(ref, options);
			return PromiseUtils.resolve();
		}

		if (!options) {
			options = {};
		}

		if (!this._objects.has(ref) || (options.instantiate && ConfigHandler.getTypeForRef(ref) === 'machine')) {
			this._objects.set(ref, this._create());
		}
		this._prepare(config);
		return PromiseUtils.resolve(this._objects.get(ref));
	};

	ConfigHandler.handlerClasses = {};

	/**
	 * Get a handler class for the specified type of resource. The resource can be e.g. 'texture', 'mesh', etc.
	 * @param {string} type
	 * @returns {Class} A subclass of {ConfigHandler}, or null if no registered handler for the given type was found.
	 */
	ConfigHandler.getHandler = function (type) {
		return ConfigHandler.handlerClasses[type];
	};

	/**
	 * Register a handler for a component type. Called in the class body of subclasses.
	 * @param {string} type
	 * @param {Class} klass the class to register for this component type
	 */
	ConfigHandler._registerClass = function (type, klass) {
		klass._type = type;
		return ConfigHandler.handlerClasses[type] = klass;
	};

	return ConfigHandler;
})(goo.rsvp,goo.PromiseUtils);
goo.DdsUtils = (function (
	Capabilities
) {
	'use strict';

	function DdsUtils() {}

	DdsUtils.isSupported = function () {
		return !!Capabilities.CompressedTextureS3TC;
	};

	/**
	 * Get the necessary bit shifts needed to align mask with 0.
	 * @param mask the bit mask to test
	 * @returns number of bits to shift to the right to align mask with 0.
	 */
	DdsUtils.shiftCount = function (mask) {
		if (mask === 0) {
			return 0;
		}

		var i = 0;
		while ((mask & 0x1) === 0) {
			mask >>= 1;
			i++;
			if (i > 32) {
				throw new Error('invalid mask!');
			}
		}

		return i;
	};

	/**
	 * Check a value against a bit mask to see if it is set.
	 * @param value the value to check
	 * @param bitMask our mask
	 * @returns true if the mask passes
	 */
	DdsUtils.isSet = function (value, bitMask) {
		return (value & bitMask) === bitMask;
	};

	/**
	 * Get the string as a dword int value.
	 * @param string our string... should only be 1-4 chars long. Expected to be 1 byte chars.
	 * @returns the int value
	 */
	DdsUtils.getIntFromString = function (string) {
		var bytes = [];
		for (var i = 0; i < string.length; i++) {
			bytes[i] = string.charCodeAt(i);
		}
		return DdsUtils.getIntFromBytes(bytes);
	};

	/**
	 * Get the byte array as a dword int value.
	 * @param bytes our array... should only be 1-4 bytes long.
	 * @returns the int value
	 */
	DdsUtils.getIntFromBytes = function (bytes) {
		var rVal = 0;
		rVal |= (bytes[0] & 0xff) << 0;
		if (bytes.length > 1) {
			rVal |= (bytes[1] & 0xff) << 8;
		}
		if (bytes.length > 2) {
			rVal |= (bytes[2] & 0xff) << 16;
		}
		if (bytes.length > 3) {
			rVal |= (bytes[3] & 0xff) << 24;
		}
		return rVal;
	};

	DdsUtils.getComponents = function (format) {
		switch (format) {
			case 'Alpha':
				return 1;
			case 'RGB':
				return 3;
			case 'RGBA':
				return 4;
			case 'Luminance':
				return 1;
			case 'LuminanceAlpha':
				return 2;
			case 'PrecompressedDXT1':
				return 1;
			case 'PrecompressedDXT1A':
				return 1;
			case 'PrecompressedDXT3':
				return 2;
			case 'PrecompressedDXT5':
				return 2;
		}
		return 0;
	};

	/**
	 * Flip a dxt mipmap/image. Inspired by similar code in opentk and the nvidia sdk.
	 * @param rawData our unflipped image as raw bytes
	 * @param width our image's width
	 * @param height our image's height
	 * @param format our image's format
	 * @returns the flipped image as raw bytes.
	 */
	DdsUtils.flipDXT = function (rawData, width, height, format) {
		var returnData = new Uint8Array(rawData.length);

		var blocksPerColumn = width + 3 >> 2;
		var blocksPerRow = height + 3 >> 2;
		var bytesPerBlock = DdsUtils.getComponents(format) * 8;

		for (var sourceRow = 0; sourceRow < blocksPerRow; sourceRow++) {
			var targetRow = blocksPerRow - sourceRow - 1;
			for (var column = 0; column < blocksPerColumn; column++) {
				var target = (targetRow * blocksPerColumn + column) * bytesPerBlock;
				var source = (sourceRow * blocksPerColumn + column) * bytesPerBlock;
				switch (format) {
					case 'PrecompressedDXT1':
					case 'PrecompressedDXT1A':
						// case PrecompressedLATC_L:
						returnData[target + 0] = rawData[source + 0];
						returnData[target + 1] = rawData[source + 1];
						returnData[target + 2] = rawData[source + 2];
						returnData[target + 3] = rawData[source + 3];
						returnData[target + 4] = rawData[source + 7];
						returnData[target + 5] = rawData[source + 6];
						returnData[target + 6] = rawData[source + 5];
						returnData[target + 7] = rawData[source + 4];
						break;
					case 'PrecompressedDXT3':
						// Alpha
						returnData[target + 0] = rawData[source + 6];
						returnData[target + 1] = rawData[source + 7];
						returnData[target + 2] = rawData[source + 4];
						returnData[target + 3] = rawData[source + 5];
						returnData[target + 4] = rawData[source + 2];
						returnData[target + 5] = rawData[source + 3];
						returnData[target + 6] = rawData[source + 0];
						returnData[target + 7] = rawData[source + 1];
						// Color
						returnData[target + 8] = rawData[source + 8];
						returnData[target + 9] = rawData[source + 9];
						returnData[target + 10] = rawData[source + 10];
						returnData[target + 11] = rawData[source + 11];
						returnData[target + 12] = rawData[source + 15];
						returnData[target + 13] = rawData[source + 14];
						returnData[target + 14] = rawData[source + 13];
						returnData[target + 15] = rawData[source + 12];
						break;
					case 'PrecompressedDXT5':
						// Alpha, the first 2 bytes remain
						returnData[target + 0] = rawData[source + 0];
						returnData[target + 1] = rawData[source + 1];

						// extract 3 bits each and flip them
						DdsUtils.getBytesFromUInt24(returnData, target + 5, DdsUtils.flipUInt24(DdsUtils.getUInt24(rawData, source + 2)));
						DdsUtils.getBytesFromUInt24(returnData, target + 2, DdsUtils.flipUInt24(DdsUtils.getUInt24(rawData, source + 5)));

						// Color
						returnData[target + 8] = rawData[source + 8];
						returnData[target + 9] = rawData[source + 9];
						returnData[target + 10] = rawData[source + 10];
						returnData[target + 11] = rawData[source + 11];
						returnData[target + 12] = rawData[source + 15];
						returnData[target + 13] = rawData[source + 14];
						returnData[target + 14] = rawData[source + 13];
						returnData[target + 15] = rawData[source + 12];
						break;
					// case PrecompressedLATC_LA:
					// // alpha
					// System.arraycopy(rawData, source, returnData, target, 4);
					// returnData[target + 4] = rawData[source + 7];
					// returnData[target + 5] = rawData[source + 6];
					// returnData[target + 6] = rawData[source + 5];
					// returnData[target + 7] = rawData[source + 4];
					//
					// // Color
					// System.arraycopy(rawData, source + 8, returnData, target + 8, 4);
					// returnData[target + 12] = rawData[source + 15];
					// returnData[target + 13] = rawData[source + 14];
					// returnData[target + 14] = rawData[source + 13];
					// returnData[target + 15] = rawData[source + 12];
					// break;
				}
			}
		}
		return returnData;
	};

	// DXT5 Alpha block flipping, inspired by code from Evan Hart (nVidia SDK)
	DdsUtils.getUInt24 = function (input, offset) {
		var result = 0;
		result |= (input[offset + 0] & 0xff) << 0;
		result |= (input[offset + 1] & 0xff) << 8;
		result |= (input[offset + 2] & 0xff) << 16;
		return result;
	};

	DdsUtils.getBytesFromUInt24 = function (input, offset, uint24) {
		input[offset + 0] = (uint24 & 0x000000ff);
		input[offset + 1] = ((uint24 & 0x0000ff00) >> 8);
		input[offset + 2] = ((uint24 & 0x00ff0000) >> 16);
	};

	DdsUtils.ThreeBitMask = 0x7;

	DdsUtils.flipUInt24 = function (uint24) {
		var threeBits = [];
		for (var i = 0; i < 2; i++) {
			threeBits.push([0, 0, 0, 0]);
		}

		// extract 3 bits each into the array
		threeBits[0][0] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[0][1] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[0][2] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[0][3] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[1][0] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[1][1] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[1][2] = (uint24 & DdsUtils.ThreeBitMask);
		uint24 >>= 3;
		threeBits[1][3] = (uint24 & DdsUtils.ThreeBitMask);

		// stuff 8x 3bits into 3 bytes
		var result = 0;
		result |= threeBits[1][0] << 0;
		result |= threeBits[1][1] << 3;
		result |= threeBits[1][2] << 6;
		result |= threeBits[1][3] << 9;
		result |= threeBits[0][0] << 12;
		result |= threeBits[0][1] << 15;
		result |= threeBits[0][2] << 18;
		result |= threeBits[0][3] << 21;
		return result;
	};

	return DdsUtils;
})(goo.Capabilities);
goo.DdsLoader = (function (
	DdsUtils,
	Capabilities
) {
	'use strict';

	function DdsPixelFormat() {
		this.dwSize = 0;
		this.dwFlags = 0;
		this.dwFourCC = 0;
		this.dwRGBBitCount = 0;
		this.dwRBitMask = 0;
		this.dwGBitMask = 0;
		this.dwBBitMask = 0;
		this.dwABitMask = 0;
	}

	DdsPixelFormat.HEADER_OFFSET = 19;

	// ---- VALUES USED IN dwFlags ----
	// Texture contains alpha data; dwABitMask contains valid data.
	DdsPixelFormat.DDPF_ALPHAPIXELS = 0x1;
	// Used in some older DDS files for alpha channel only uncompressed data (dwRGBBitCount contains the alpha channel
	// bitcount; dwABitMask contains valid data)
	DdsPixelFormat.DDPF_ALPHA = 0x2;
	// Texture contains compressed RGB data; dwFourCC contains valid data.
	DdsPixelFormat.DDPF_FOURCC = 0x4;
	// Texture contains uncompressed RGB data; dwRGBBitCount and the RGB masks (dwRBitMask, dwGBitMask, dwBBitMask)
	// contain valid data.
	DdsPixelFormat.DDPF_RGB = 0x40;
	// Used in some older DDS files for YUV uncompressed data (dwRGBBitCount contains the YUV bit count; dwRBitMask
	// contains the Y mask, dwGBitMask contains the U mask, dwBBitMask contains the V mask)
	DdsPixelFormat.DDPF_YUV = 0x200;
	// Used in some older DDS files for single channel color uncompressed data (dwRGBBitCount contains the luminance
	// channel bit count; dwRBitMask contains the channel mask). Can be combined with DDPF_ALPHAPIXELS for a two channel
	// DDS file.
	DdsPixelFormat.DDPF_LUMINANCE = 0x20000;
	// ---- /end VALUES USED IN dwFlags ----

	DdsPixelFormat.read = function (data) { // Int32Array
		var format = new DdsPixelFormat();
		format.dwSize = data[DdsPixelFormat.HEADER_OFFSET + 0];
		if (format.dwSize !== 32) {
			throw ('invalid pixel format size: ' + format.dwSize);
		}
		format.dwFlags = data[DdsPixelFormat.HEADER_OFFSET + 1];
		format.dwFourCC = data[DdsPixelFormat.HEADER_OFFSET + 2];
		format.dwRGBBitCount = data[DdsPixelFormat.HEADER_OFFSET + 3];
		format.dwRBitMask = data[DdsPixelFormat.HEADER_OFFSET + 4];
		format.dwGBitMask = data[DdsPixelFormat.HEADER_OFFSET + 5];
		format.dwBBitMask = data[DdsPixelFormat.HEADER_OFFSET + 6];
		format.dwABitMask = data[DdsPixelFormat.HEADER_OFFSET + 7];
		return format;
	};

	function DdsHeader() {
		this.dwSize = 0;
		this.dwFlags = 0;
		this.dwHeight = 0;
		this.dwWidth = 0;
		this.dwLinearSize = 0;
		this.dwDepth = 0;
		this.dwMipMapCount = 0;
		this.dwAlphaBitDepth = 0;
		this.dwReserved1 = [];
		this.ddpf = null;
		this.dwCaps = 0;
		this.dwCaps2 = 0;
		this.dwCaps3 = 0;
		this.dwCaps4 = 0;
		this.dwTextureStage = 0;
	}

	// Required caps flag.
	DdsHeader.DDSD_CAPS = 0x1;
	// Required caps flag.
	DdsHeader.DDSD_HEIGHT = 0x2;
	// Required caps flag.
	DdsHeader.DDSD_WIDTH = 0x4;
	// Required when pitch is provided for an uncompressed texture.
	DdsHeader.DDSD_PITCH = 0x8;
	// Required caps flag.
	DdsHeader.DDSD_PIXELFORMAT = 0x1000;
	// Required in a mipmapped texture.
	DdsHeader.DDSD_MIPMAPCOUNT = 0x20000;
	// Required when pitch is provided for a compressed texture.
	DdsHeader.DDSD_LINEARSIZE = 0x80000;
	// Required in a depth texture.
	DdsHeader.DDSD_DEPTH = 0x800000;
	// ---- /end VALUES USED IN dwFlags ----

	// ---- VALUES USED IN dwCaps ----
	// Optional; must be used on any file that contains more than one surface (a mipmap, a cubic environment map, or
	// volume texture).
	DdsHeader.DDSCAPS_COMPLEX = 0x8;
	// Optional; should be used for a mipmap.
	DdsHeader.DDSCAPS_MIPMAP = 0x400000;
	// Required caps flag.
	DdsHeader.DDSCAPS_TEXTURE = 0x1000;
	// ---- /end VALUES USED IN dwCaps ----

	// ---- VALUES USED IN dwCaps2 ----
	// Required for a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP = 0x200;
	// Required when these surfaces are stored in a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP_POSITIVEX = 0x400;
	// Required when these surfaces are stored in a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800;
	// Required when these surfaces are stored in a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000;
	// Required when these surfaces are stored in a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000;
	// Required when these surfaces are stored in a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000;
	// Required when these surfaces are stored in a cube map.
	DdsHeader.DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000;
	// Required for a volume texture.
	DdsHeader.DDSCAPS2_VOLUME = 0x200000;
	// ---- /end VALUES USED IN dwCaps2 ----

	DdsHeader.read = function (data) { // Int32Array
		var header = new DdsHeader();
		header.dwSize = data[1];
		if (header.dwSize !== 124) {
			throw ('invalid dds header size: ' + header.dwSize);
		}
		header.dwFlags = data[2];
		header.dwHeight = data[3];
		header.dwWidth = data[4];
		header.dwLinearSize = data[5];
		header.dwDepth = data[6];
		header.dwMipMapCount = data[7];
		header.dwAlphaBitDepth = data[8];
		for (var i = 0; i < header.dwReserved1.length; i++) {
			header.dwReserved1[i] = data[9 + i];
		}
		header.ddpf = DdsPixelFormat.read(data);
		header.dwCaps = data[27];
		header.dwCaps2 = data[28];
		header.dwCaps3 = data[29];
		header.dwCaps4 = data[30];
		header.dwTextureStage = data[31];

		var expectedMipmaps = 1 + Math.ceil(Math.log(Math.max(header.dwHeight, header.dwWidth)) / Math.log(2));

		if (DdsUtils.isSet(header.dwCaps, DdsHeader.DDSCAPS_MIPMAP)) {
			if (!DdsUtils.isSet(header.dwFlags, DdsHeader.DDSD_MIPMAPCOUNT)) {
				header.dwMipMapCount = expectedMipmaps;
			} else if (header.dwMipMapCount !== expectedMipmaps) {
				console.warn('Got ' + header.dwMipMapCount + ' mipmaps, expected ' + expectedMipmaps);
			}
		} else {
			header.dwMipMapCount = 1;
		}

		return header;
	};

	function DdsImageInfo() {
		this.flipVertically = false;
		this.bpp = 0;
		this.header = null;
		this.headerDX10 = null;
		this.mipmapByteSizes = [];
	}

	DdsImageInfo.prototype.calcMipmapSizes = function (compressed) {
		var width = this.header.dwWidth;
		var height = this.header.dwHeight;
		var size = 0;

		for (var i = 0; i < this.header.dwMipMapCount; i++) {
			size = compressed ? ~~((width + 3) / 4) * ~~((height + 3) / 4) * this.bpp * 2 : ~~(width * height * this.bpp / 8);
			this.mipmapByteSizes.push(~~((size + 3) / 4) * 4);
			width = ~~(width / 2) > 1 ? ~~(width / 2) : 1;
			height = ~~(height / 2) > 1 ? ~~(height / 2) : 1;
		}
	};

	/**
	 * Loads dds format images into a format usable by Goo.
	 * @private
	 */
	function DdsLoader() {
	}

	DdsLoader.updateDepth = function (image, info) {
		if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP)) {
			var depth = 0;
			if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP_POSITIVEX)) {
				depth++;
			}
			if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP_NEGATIVEX)) {
				depth++;
			}
			if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP_POSITIVEY)) {
				depth++;
			}
			if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP_NEGATIVEY)) {
				depth++;
			}
			if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP_POSITIVEZ)) {
				depth++;
			}
			if (DdsUtils.isSet(info.header.dwCaps2, DdsHeader.DDSCAPS2_CUBEMAP_NEGATIVEZ)) {
				depth++;
			}

			if (depth !== 6) {
				throw new Error('Cubemaps without all faces defined are not currently supported.');
			}

			image.depth = depth;
		} else {
			// make sure we have at least depth of 1.
			image.depth = (info.header.dwDepth > 0 ? info.header.dwDepth : 1);
		}
	};

	DdsLoader.readDXT = function (imgData, totalSize, info, texture) {
		texture.image.isCompressed = true;

		if (!info.flipVertically) {
			return new Uint8Array(imgData.buffer, imgData.byteOffset + 0, totalSize);
		}

		// NB: since UNPACK_FLIP_Y_WEBGL doesn't handle compressed textures, we have to do it manually.
		var mipWidth = info.header.dwWidth;
		var mipHeight = info.header.dwHeight;

		// flip!
		var rVal = new Uint8Array(totalSize);
		var offset = 0;
		for (var mip = 0; mip < info.header.dwMipMapCount; mip++) {
			var data = imgData.subarray(offset, offset + info.mipmapByteSizes[mip]);

			var flipped = DdsUtils.flipDXT(data, mipWidth, mipHeight, texture.format);
			rVal.set(flipped, offset);
			offset += flipped.length;

			mipWidth = ~~(mipWidth / 2) > 1 ? ~~(mipWidth / 2) : 1;
			mipHeight = ~~(mipHeight / 2) > 1 ? ~~(mipHeight / 2) : 1;
		}
		return rVal;
	};

	DdsLoader.readUncompressed = function (imgData, totalSize, useRgb, useLum, useAlpha, useAlphaPixels, info, texture) {
		var redLumShift = DdsUtils.shiftCount(info.header.ddpf.dwRBitMask);
		var greenShift = DdsUtils.shiftCount(info.header.ddpf.dwGBitMask);
		var blueShift = DdsUtils.shiftCount(info.header.ddpf.dwBBitMask);
		var alphaShift = DdsUtils.shiftCount(info.header.ddpf.dwABitMask);

		var sourcebytesPP = ~~(info.header.ddpf.dwRGBBitCount / 8);
		var targetBytesPP = DdsUtils.getComponents(texture.format) * 1; // 1 byte per unsignedbyte store

		var rVal = new Uint8Array(totalSize);

		var mipWidth = info.header.dwWidth;
		var mipHeight = info.header.dwHeight;
		var dstOffset = 0, srcOffset = 0;
		var i = 0;
		var b = [];
		for (i = 0; i < sourcebytesPP; i++) {
			b.push(0);
		}

		for (var mip = 0; mip < info.header.dwMipMapCount; mip++) {
			for (var y = 0; y < mipHeight; y++) {
				for (var x = 0; x < mipWidth; x++) {
					for (i = 0; i < sourcebytesPP; i++) {
						b[i] = imgData[srcOffset++];
					}

					i = DdsUtils.getIntFromBytes(b);

					var redLum = ((i & info.header.ddpf.dwRBitMask) >> redLumShift);
					var green = ((i & info.header.ddpf.dwGBitMask) >> greenShift);
					var blue = ((i & info.header.ddpf.dwBBitMask) >> blueShift);
					var alpha = ((i & info.header.ddpf.dwABitMask) >> alphaShift);

					// Uncompressed, so handled by UNPACK_FLIP_Y_WEBGL instead.
					// if (info.flipVertically) {
					// dstOffset = ((mipHeight - y - 1) * mipWidth + x) * targetBytesPP;
					// }

					if (useAlpha) {
						rVal[dstOffset++] = alpha;
					} else if (useLum) {
						rVal[dstOffset++] = redLum;
						if (useAlphaPixels) {
							rVal[dstOffset++] = alpha;
						}
					} else if (useRgb) {
						rVal[dstOffset++] = redLum;
						rVal[dstOffset++] = green;
						rVal[dstOffset++] = blue;
						if (useAlphaPixels) {
							rVal[dstOffset++] = alpha;
						}
					}
				}
			}

			dstOffset += mipWidth * mipHeight * targetBytesPP;

			mipWidth = ~~(mipWidth / 2) > 1 ? ~~(mipWidth / 2) : 1;
			mipHeight = ~~(mipHeight / 2) > 1 ? ~~(mipHeight / 2) : 1;
		}

		return rVal;
	};

	DdsLoader.populate = function (texture, info, data) {
		var flags = info.header.ddpf.dwFlags;

		var compressedFormat = DdsUtils.isSet(flags, DdsPixelFormat.DDPF_FOURCC);
		var rgb = DdsUtils.isSet(flags, DdsPixelFormat.DDPF_RGB);
		var alphaPixels = DdsUtils.isSet(flags, DdsPixelFormat.DDPF_ALPHAPIXELS);
		var lum = DdsUtils.isSet(flags, DdsPixelFormat.DDPF_LUMINANCE);
		var alpha = DdsUtils.isSet(flags, DdsPixelFormat.DDPF_ALPHA);
		texture.type = 'UnsignedByte';

		if (compressedFormat) {
			var fourCC = info.header.ddpf.dwFourCC;
			// DXT1 format
			if (fourCC === DdsUtils.getIntFromString('DXT1')) {
				info.bpp = 4;
				// if (isSet(flags, DdsPixelFormat.DDPF_ALPHAPIXELS)) {
				// XXX: many authoring tools do not set alphapixels, so we'll error on the side of alpha
//				console.info('DDS format: DXT1A');
				texture.format = 'PrecompressedDXT1A';
				// } else {
				// logger.finest('DDS format: DXT1');
				// texture.setDataFormat(ImageDataFormat.PrecompressedDXT1);
				// }
			}

			// DXT3 format
			else if (fourCC === DdsUtils.getIntFromString('DXT3')) {
//				console.info('DDS format: DXT3');
				info.bpp = 8;
				texture.format = 'PrecompressedDXT3';
			}

			// DXT5 format
			else if (fourCC === DdsUtils.getIntFromString('DXT5')) {
//				console.info('DDS format: DXT5');
				info.bpp = 8;
				texture.format = 'PrecompressedDXT5';
			}

			// DXT10 info present...
			else if (fourCC === DdsUtils.getIntFromString('DX10')) {
				// switch (info.headerDX10.dxgiFormat) {
				// case DXGI_FORMAT_BC4_UNORM:
				// console.info('DXGI format: BC4_UNORM');
				// info.bpp = 4;
				// texture.setDataFormat(ImageDataFormat.PrecompressedLATC_L);
				// break;
				// case DXGI_FORMAT_BC5_UNORM:
				// console.info('DXGI format: BC5_UNORM');
				// info.bpp = 8;
				// texture.setDataFormat(ImageDataFormat.PrecompressedLATC_LA);
				// break;
				// default:
				// throw new Error('dxgiFormat not supported: ' + info.headerDX10.dxgiFormat);
				// }
				throw new Error('dxt10 LATC formats not supported currently: ' + info.headerDX10.dxgiFormat);
			}

			// DXT2 format - unsupported
			else if (fourCC === DdsUtils.getIntFromString('DXT2')) {
				throw 'DXT2 is not supported.';
			}

			// DXT4 format - unsupported
			else if (fourCC === DdsUtils.getIntFromString('DXT4')) {
				throw 'DXT4 is not supported.';
			}

			// Unsupported compressed type.
			else {
				throw 'unsupported compressed dds format found (' + fourCC + ')';
			}
		}

		// not a compressed format
		else {
			// TODO: more use of bit masks?
			// TODO: Use bit size instead of hardcoded 8 bytes? (need to also implement in readUncompressed)

			info.bpp = info.header.ddpf.dwRGBBitCount;

			// One of the RGB formats?
			if (rgb) {
				if (alphaPixels) {
//					console.info('DDS format: uncompressed rgba');
					texture.format = 'RGBA';
				} else {
//					console.info('DDS format: uncompressed rgb ');
					texture.format = 'RGB';
				}
			}

			// A luminance or alpha format
			else if (lum || alphaPixels) {
				if (lum && alphaPixels) {
//					console.info('DDS format: uncompressed LumAlpha');
					texture.format = 'LuminanceAlpha';
				}

				else if (lum) {
//					console.info('DDS format: uncompressed Lum');
					texture.format = 'Luminance';
				}

				else if (alpha) {
//					console.info('DDS format: uncompressed Alpha');
					texture.format = 'Alpha';
				}
			} // end luminance/alpha type

			// Unsupported type.
			else {
				throw new Error('unsupported uncompressed dds format found.');
			}
		}

		info.calcMipmapSizes(compressedFormat);
		texture.image.mipmapSizes = (info.mipmapByteSizes);

		// Add up total byte size of single depth layer
		var totalSize = 0;
		for (var i = 0; i < info.mipmapByteSizes.length; i++) {
			totalSize += info.mipmapByteSizes[i];
		}

		// Go through and load in image data
		var imageData = [];
		for (var i = 0; i < texture.image.depth; i++) {
			// read in compressed data
			if (compressedFormat) {
				imageData.push(DdsLoader.readDXT(data, totalSize, info, texture));
			}

			// read in uncompressed data
			else if (rgb || lum || alpha) {
				imageData.push(DdsLoader.readUncompressed(data, totalSize, rgb, lum, alpha, alphaPixels, info, texture));
			}
		}

		// set on image
		texture.image.data = texture.image.depth === 1 ? imageData[0] : imageData;
		texture.image.useArrays = true;
	};

	DdsLoader.prototype.load = function (buffer, tex, flipped, arrayByteOffset, arrayByteLength) {
		var header = new Int32Array(buffer, arrayByteOffset + 0, 32);

		// Read and check magic word...
		var dwMagic = header[0];
		if (dwMagic !== DdsUtils.getIntFromString('DDS ')) {
			throw 'Not a dds file.';
		}
//		console.info('Reading DDS file.');

		// Create our data store;
		var info = new DdsImageInfo();

		info.flipVertically = flipped;

		// Read standard dds header
		info.header = DdsHeader.read(header);

		// if applicable, read DX10 header
		info.headerDX10 = info.header.ddpf.dwFourCC === DdsUtils.getIntFromString('DX10') ? DdsHeader.read(Int32Array.create(buffer,
			arrayByteOffset + 128, 5)) : null;

		// Create our new image
		var image = tex.image;
		if (typeof image === 'undefined' || image === null) {
			image = {};
			tex.image = image;
		}
		image.width = info.header.dwWidth;
		image.height = info.header.dwHeight;

		// update depth based on flags / header
		DdsLoader.updateDepth(image, info);

		// add our format and image data.
		var contentOffset = 128 + (info.headerDX10 ? 20 : 0);
		DdsLoader.populate(tex, info, new Uint8Array(buffer, arrayByteOffset + contentOffset, arrayByteLength - contentOffset));

		if (!info.mipmapByteSizes || info.mipmapByteSizes.length < 2) {
			tex.minFilter = 'BilinearNoMipMaps';
		}

		image.bpp = info.bpp;
		image.dataReady = true;
		image.isData = true;
		tex.needsUpdate = true;
	};

	DdsLoader.prototype.isSupported = function () {
		return !!Capabilities.CompressedTextureS3TC;
	};

	DdsLoader.prototype.toString = function () {
		return 'DdsLoader';
	};

	return DdsLoader;
})(goo.DdsUtils,goo.Capabilities);
goo.CrunchLoader = (function (
	DdsLoader,
	DdsUtils,
	Capabilities
) {
	'use strict';

	/**
	 * @private
	 */
	function CrunchLoader() {
	}

	CrunchLoader.cCRNFmtDXT1 = 0;
	CrunchLoader.cCRNFmtDXT3 = 1;
	CrunchLoader.cCRNFmtDXT5 = 2;

	CrunchLoader.prototype.arrayBufferCopy = function (src, dst, dstByteOffset, numBytes) {
		var dst32Offset = dstByteOffset / 4,
			tail = (numBytes % 4),
			src32 = new Uint32Array(src.buffer, 0, (numBytes - tail) / 4),
			dst32 = new Uint32Array(dst.buffer),
			i;

		for (i = 0; i < src32.length; i++) {
			dst32[dst32Offset + i] = src32[i];
		}
		for (i = numBytes - tail; i < numBytes; i++) {
			dst[dstByteOffset + i] = src[i];
		}
	};

	CrunchLoader.prototype.load = function (arrayBuffer, texture, flipped/*, arrayByteOffset, arrayByteLength*/) {
		if (typeof (window.CrunchModule) === 'undefined') {
			console.warn('Crunch library not loaded! Include a script tag pointing to lib/crunch/crunch.js in your html-file.');
			return;
		}

		var CrunchModule = window.CrunchModule;

		var bytes = new Uint8Array(arrayBuffer),
			srcSize = arrayBuffer.byteLength,
			src = CrunchModule._malloc(srcSize),
			format, dst, dstSize,
			width, height, levels, dxtData, i;

		this.arrayBufferCopy(bytes, CrunchModule.HEAPU8, src, srcSize);

		format = CrunchModule._crn_get_dxt_format(src, srcSize);

		var bpp;
		switch (format) {
			case CrunchLoader.cCRNFmtDXT1:
				texture.format = 'PrecompressedDXT1A';
				bpp = 4;
				break;
			case CrunchLoader.cCRNFmtDXT3:
				texture.format = 'PrecompressedDXT3';
				bpp = 8;
				break;
			case CrunchLoader.cCRNFmtDXT5:
				texture.format = 'PrecompressedDXT5';
				bpp = 8;
				break;
			default:
				console.error('Unsupported image format');
				return 0;
		}

		width = CrunchModule._crn_get_width(src, srcSize);
		height = CrunchModule._crn_get_height(src, srcSize);
		levels = CrunchModule._crn_get_levels(src, srcSize);
		dstSize = CrunchModule._crn_get_uncompressed_size(src, srcSize, 0);
		dst = CrunchModule._malloc(dstSize);

		var image = texture.image;
		if (typeof image === 'undefined' || image === null) {
			image = {};
			texture.image = image;
		}

		image.width = width;
		image.height = height;
		image.depth = 1;

		var imageData = [];
		texture.image.mipmapSizes = [];
		for (i = 0; i < levels; ++i) {
			if (i) {
				dstSize = CrunchModule._crn_get_uncompressed_size(src, srcSize, i);
			}
			CrunchModule._crn_decompress(src, srcSize, dst, dstSize, i);
			dxtData = new Uint8Array(CrunchModule.HEAPU8.buffer, dst, dstSize);
			if (flipped) {
				dxtData = DdsUtils.flipDXT(dxtData, width, height, texture.format);
			}

			imageData.push(dxtData);
			texture.image.mipmapSizes.push(dstSize);

			width *= 0.5;
			height *= 0.5;
		}

		texture.image.data = imageData;
		texture.image.useArrays = true;
		texture.type = 'UnsignedByte';
		texture.image.isCompressed = true;

		if (levels <= 1) {
			texture.minFilter = 'BilinearNoMipMaps';
		}

		image.bpp = bpp;
		image.dataReady = true;
		image.isData = true;
		texture.needsUpdate = true;

		CrunchModule._free(src);
		CrunchModule._free(dst);
	};

	/**
	 * Transcodes DXT into RGB565.
	 * Optimizations:
	 * 1. Use integer math to compute c2 and c3 instead of floating point
	 *    math.  Specifically:
	 *      c2 = 5/8 * c0 + 3/8 * c1
	 *      c3 = 3/8 * c0 + 5/8 * c1
	 *    This is about a 40% performance improvement.  It also appears to
	 *    match what hardware DXT decoders do, as the colors produced
	 *    by this integer math match what hardware produces, while the
	 *    floating point in dxtToRgb565Unoptimized() produce slightly
	 *    different colors (for one GPU this was tested on).
	 * 2. Unroll the inner loop.  Another ~10% improvement.
	 * 3. Compute r0, g0, b0, r1, g1, b1 only once instead of twice.
	 *    Another 10% improvement.
	 * 4. Use a Uint16Array instead of a Uint8Array.  Another 10% improvement.
	 * @author Evan Parker
	 * @param {Uint16Array} src The src DXT bits as a Uint16Array.
	 * @param {number} srcByteOffset
	 * @param {number} width
	 * @param {number} height
	 * @returns {Uint16Array} dst
	 */
	CrunchLoader.prototype.dxtToRgb565 = function (src, src16Offset, width, height) {
		var c = new Uint16Array(4);
		var dst = new Uint16Array(width * height);
		// var nWords = (width * height) / 4;
		var m = 0;
		var dstI = 0;
		var i = 0;
		var r0 = 0,
			g0 = 0,
			b0 = 0,
			r1 = 0,
			g1 = 0,
			b1 = 0;

		var blockWidth = width / 4;
		var blockHeight = height / 4;
		for (var blockY = 0; blockY < blockHeight; blockY++) {
			for (var blockX = 0; blockX < blockWidth; blockX++) {
				i = src16Offset + 4 * (blockY * blockWidth + blockX);
				c[0] = src[i];
				c[1] = src[i + 1];
				r0 = c[0] & 0x1f;
				g0 = c[0] & 0x7e0;
				b0 = c[0] & 0xf800;
				r1 = c[1] & 0x1f;
				g1 = c[1] & 0x7e0;
				b1 = c[1] & 0xf800;
				// Interpolate between c0 and c1 to get c2 and c3.
				// Note that we approximate 1/3 as 3/8 and 2/3 as 5/8 for
				// speed.  This also appears to be what the hardware DXT
				// decoder in many GPUs does :)
				c[2] = ((5 * r0 + 3 * r1) >> 3) | (((5 * g0 + 3 * g1) >> 3) & 0x7e0) | (((5 * b0 + 3 * b1) >> 3) & 0xf800);
				c[3] = ((5 * r1 + 3 * r0) >> 3) | (((5 * g1 + 3 * g0) >> 3) & 0x7e0) | (((5 * b1 + 3 * b0) >> 3) & 0xf800);
				m = src[i + 2];
				dstI = (blockY * 4) * width + blockX * 4;
				dst[dstI] = c[m & 0x3];
				dst[dstI + 1] = c[(m >> 2) & 0x3];
				dst[dstI + 2] = c[(m >> 4) & 0x3];
				dst[dstI + 3] = c[(m >> 6) & 0x3];
				dstI += width;
				dst[dstI] = c[(m >> 8) & 0x3];
				dst[dstI + 1] = c[(m >> 10) & 0x3];
				dst[dstI + 2] = c[(m >> 12) & 0x3];
				dst[dstI + 3] = c[(m >> 14)];
				m = src[i + 3];
				dstI += width;
				dst[dstI] = c[m & 0x3];
				dst[dstI + 1] = c[(m >> 2) & 0x3];
				dst[dstI + 2] = c[(m >> 4) & 0x3];
				dst[dstI + 3] = c[(m >> 6) & 0x3];
				dstI += width;
				dst[dstI] = c[(m >> 8) & 0x3];
				dst[dstI + 1] = c[(m >> 10) & 0x3];
				dst[dstI + 2] = c[(m >> 12) & 0x3];
				dst[dstI + 3] = c[(m >> 14)];
			}
		}
		return dst;
	};

	CrunchLoader.prototype.isSupported = function () {
		return !!Capabilities.CompressedTextureS3TC;
	};

	CrunchLoader.prototype.toString = function () {
		return 'CrunchLoader';
	};

	return CrunchLoader;
})(goo.DdsLoader,goo.DdsUtils,goo.Capabilities);
goo.TgaLoader = (function (
) {
	'use strict';

	/**
	 * @private
	 */
	function TgaLoader() {
		this.header = null;
		this.offset = 0;
		this.use_rle = false;
		this.use_pal = false;
		this.use_rgb = false;
		this.use_grey = false;
	}

	// TGA Constants
	TgaLoader.TYPE_NO_DATA = 0;
	TgaLoader.TYPE_INDEXED = 1;
	TgaLoader.TYPE_RGB = 2;
	TgaLoader.TYPE_GREY = 3;
	TgaLoader.TYPE_RLE_INDEXED = 9;
	TgaLoader.TYPE_RLE_RGB = 10;
	TgaLoader.TYPE_RLE_GREY = 11;

	TgaLoader.ORIGIN_MASK = 0x30;
	TgaLoader.ORIGIN_SHIFT = 0x04;
	TgaLoader.ORIGIN_BL = 0x00;
	TgaLoader.ORIGIN_BR = 0x01;
	TgaLoader.ORIGIN_UL = 0x02;
	TgaLoader.ORIGIN_UR = 0x03;


	/**
	 * Load and parse a TGA file
	 */
	TgaLoader.prototype.load = function (buffer, tex/*, flipped, arrayByteOffset, arrayByteLength*/) {
		this.loadData(new Uint8Array(buffer));
		var imageData = this.getCanvas();
		tex.setImage(imageData, imageData.width, imageData.height);
		//imageData.isData = true;
		imageData.dataReady = true;
		tex.needsUpdate = true;
	};

	/**
	 * Parse TGA data
	 *
	 * @param {Uint8Array} data - Binary data of the TGA file
	 */
	TgaLoader.prototype.loadData = function (data) {
		// Not enough data to contain header ?
		if (data.length < 19) {
			throw new Error('Targa::load() - Not enough data to contain header.');
		}

		// Read Header
		this.offset = 0;
		this.header = {
			id_length: data[this.offset++],
			colormap_type: data[this.offset++],
			image_type: data[this.offset++],
			colormap_index: data[this.offset++] | data[this.offset++] << 8,
			colormap_length: data[this.offset++] | data[this.offset++] << 8,
			colormap_size: data[this.offset++],
			origin: [
				data[this.offset++] | data[this.offset++] << 8,
				data[this.offset++] | data[this.offset++] << 8
			],
			width: data[this.offset++] | data[this.offset++] << 8,
			height: data[this.offset++] | data[this.offset++] << 8,
			pixel_size: data[this.offset++],
			flags: data[this.offset++]
		};

		// Assume it's a valid Targa file.
		this.checkHeader();
		if (this.header.id_length + this.offset > data.length) {
			throw new Error('Targa::load() - No data ?');
		}

		// Skip not needed data
		this.offset += this.header.id_length;

		// Get some informations.
		switch (this.header.image_type) {
			case TgaLoader.TYPE_RLE_INDEXED:
				this.use_rle = true;
				break;
			case TgaLoader.TYPE_INDEXED:
				this.use_pal = true;
				break;

			case TgaLoader.TYPE_RLE_RGB:
				this.use_rle = true;
				break;
			case TgaLoader.TYPE_RGB:
				this.use_rgb = true;
				break;

			case TgaLoader.TYPE_RLE_GREY:
				this.use_rle = true;
				break;
			case TgaLoader.TYPE_GREY:
				this.use_grey = true;
				break;
		}

		this.parse(data);
	};

	/**
	 * Check the header of TGA file to detect errors
	 *
	 * @throws Error
	 */
	TgaLoader.prototype.checkHeader = function () {
		switch (this.header.image_type) {
			// Check indexed type
			case TgaLoader.TYPE_INDEXED:
			case TgaLoader.TYPE_RLE_INDEXED:
				if (this.header.colormap_length > 256 || this.header.colormap_size !== 24 || this.header.colormap_type !== 1) {
					throw new Error("Targa::checkHeader() - Invalid type colormap data for indexed type");
				}
				break;

				// Check colormap type
			case TgaLoader.TYPE_RGB:
			case TgaLoader.TYPE_GREY:
			case TgaLoader.TYPE_RLE_RGB:
			case TgaLoader.TYPE_RLE_GREY:
				if (this.header.colormap_type) {
					throw new Error("Targa::checkHeader() - Invalid type colormap data for colormap type");
				}
				break;

				// What the need of a file without data ?
			case TgaLoader.TYPE_NO_DATA:
				throw new Error("Targa::checkHeader() - No data on this TGA file");

				// Invalid type ?
			default:
				throw new Error("Targa::checkHeader() - Invalid type '" + this.header.image_type + "'");
		}

		// Check image size
		if (this.header.width <= 0 || this.header.height <= 0) {
			throw new Error('Targa::checkHeader() - Invalid image size');
		}

		// Check pixel size
		if (this.header.pixel_size !== 8 && this.header.pixel_size !== 16 && this.header.pixel_size !== 24 && this.header.pixel_size !== 32) {
			throw new Error("Targa::checkHeader() - Invalid pixel size '" + this.header.pixel_size + "'");
		}
	};

	/**
	 * Parse data from TGA file
	 *
	 * @param {Uint8Array} data - Binary data of the TGA file
	 */
	TgaLoader.prototype.parse = function (data) {
		var _header,
			numAlphaBits,
			pixel_data,
			pixel_size,
			pixel_total;

		_header = this.header;
		numAlphaBits = _header.flags & 0xf;
		pixel_size = _header.pixel_size >> 3;
		pixel_total = _header.width * _header.height * pixel_size;

		// Read palettes
		if (this.use_pal) {
			this.palettes = data.subarray(
				this.offset,
				this.offset += _header.colormap_length * pixel_size);
		}

		// Read LRE
		if (this.use_rle) {
			pixel_data = new Uint8Array(pixel_total);

			var c, count, i;
			var offset = 0;
			var pixels = new Uint8Array(pixel_size);

			while (offset < pixel_total) {
				c = data[this.offset++];
				count = (c & 0x7f) + 1;

				// RLE pixels.
				if (c & 0x80) {
					// Bind pixel tmp array
					for (i = 0; i < pixel_size; ++i) {
						pixels[i] = data[this.offset++];
					}

					// Copy pixel array
					for (i = 0; i < count; ++i) {
						pixel_data.set(pixels, offset + i * pixel_size);
					}

					offset += pixel_size * count;
				}

				// Raw pixels.
				else {
					count *= pixel_size;
					for (i = 0; i < count; ++i) {
						pixel_data[offset + i] = data[this.offset++];
					}
					offset += count;
				}
			}
		}

		// RAW Pixels
		else {
			pixel_data = data.subarray(
				this.offset,
				this.offset += (
				this.use_pal ? _header.width * _header.height : pixel_total));
		}

		this.image = pixel_data;
	};

	/**
	 * Return a ImageData object from a TGA file
	 *
	 * @param {imageData} imageData - Optional ImageData to work with
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageData = function (imageData) {
		var width = this.header.width,
			height = this.header.height,
			x_start,
			y_start,
			x_step,
			y_step,
			y_end,
			x_end,
			func,
			data;

		data =
		// sent as argument
		imageData ||

		{
			width: width,
			height: height,
			data: new Uint8Array(width * height * 4)
		};

		// Check how we should write the pixels
		switch ((this.header.flags & TgaLoader.ORIGIN_MASK) >> TgaLoader.ORIGIN_SHIFT) {
			default:
			case TgaLoader.ORIGIN_UL:
				x_start = 0;
				x_step = 1;
				x_end = width;
				y_start = 0;
				y_step = 1;
				y_end = height;
				break;

			case TgaLoader.ORIGIN_BL:
				x_start = 0;
				x_step = 1;
				x_end = width;
				y_start = height - 1;
				y_step = -1;
				y_end = -1;
				break;

			case TgaLoader.ORIGIN_UR:
				x_start = width - 1;
				x_step = -1;
				x_end = -1;
				y_start = 0;
				y_step = 1;
				y_end = height;
				break;

			case TgaLoader.ORIGIN_BR:
				x_start = width - 1;
				x_step = -1;
				x_end = -1;
				y_start = height - 1;
				y_step = -1;
				y_end = -1;
				break;
		}

		// TODO: use this.header.origin[0-1] ?
		// x_start += this.header.origin[0];
		// y_start += this.header.origin[1];

		// Load the specify method
		func = 'getImageData' + (this.use_grey ? 'Grey' : '') + (this.header.pixel_size) + 'bits';
		this[func](data.data, y_start, y_step, y_end, x_start, x_step, x_end);
		return data;
	};

	/**
	 * Return a canvas with the TGA render on it
	 *
	 * @returns {canvas}
	 */
	TgaLoader.prototype.getCanvas = function () {
		var canvas = document.createElement('canvas');
		var ctx = canvas.getContext('2d');
		var imageData = ctx.createImageData(this.header.width, this.header.height);
		canvas.width = this.header.width;
		canvas.height = this.header.height;
		ctx.putImageData(this.getImageData(imageData), 0, 0);
		return canvas;
	};

	/**
	 * Return a dataURI of the TGA file
	 *
	 * @param {string} type - Optional image content-type to output (default: image/png)
	 * @returns {canvas}
	 */
	TgaLoader.prototype.getDataURL = function (type) {
		return this.getCanvas().toDataURL(type || "image/png");
	};

	/**
	 * Return a ImageData object from a TGA file (8bits)
	 *
	 * @param {imageData} imageData - ImageData to bind
	 * @param {int} y_start - start at y pixel.
	 * @param {int} x_start - start at x pixel.
	 * @param {int} y_step  - increment y pixel each time.
	 * @param {int} y_end   - stop at pixel y.
	 * @param {int} x_step  - increment x pixel each time.
	 * @param {int} x_end   - stop at pixel x.
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageData8bits = function (imageData, y_start, y_step, y_end, x_start, x_step, x_end) {
		var image = this.image,
			colormap = this.palettes;
		var width = this.header.width;
		var color, i = 0,
			x, y;

		for (y = y_start; y !== y_end; y += y_step) {
			for (x = x_start; x !== x_end; x += x_step, i++) {
				color = image[i];
				imageData[(x + width * y) * 4 + 3] = 255;
				imageData[(x + width * y) * 4 + 2] = colormap[(color * 3) + 0];
				imageData[(x + width * y) * 4 + 1] = colormap[(color * 3) + 1];
				imageData[(x + width * y) * 4 + 0] = colormap[(color * 3) + 2];
			}
		}

		return imageData;
	};

	/**
	 * Return a ImageData object from a TGA file (16bits)
	 *
	 * @param {imageData} imageData - ImageData to bind
	 * @param {int} y_start - start at y pixel.
	 * @param {int} x_start - start at x pixel.
	 * @param {int} y_step  - increment y pixel each time.
	 * @param {int} y_end   - stop at pixel y.
	 * @param {int} x_step  - increment x pixel each time.
	 * @param {int} x_end   - stop at pixel x.
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageData16bits = function (imageData, y_start, y_step, y_end, x_start, x_step, x_end) {
		var image = this.image;
		var width = this.header.width;
		var color, i = 0,
			x, y;

		for (y = y_start; y !== y_end; y += y_step) {
			for (x = x_start; x !== x_end; x += x_step, i += 2) {
				color = image[i + 0] + (image[i + 1] << 8); // Inversed ?
				imageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;
				imageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;
				imageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;
				imageData[(x + width * y) * 4 + 3] = (color & 0x8000) ? 0 : 255;
			}
		}

		return imageData;
	};

	/**
	 * Return a ImageData object from a TGA file (24bits)
	 *
	 * @param {imageData} imageData - ImageData to bind
	 * @param {int} y_start - start at y pixel.
	 * @param {int} x_start - start at x pixel.
	 * @param {int} y_step  - increment y pixel each time.
	 * @param {int} y_end   - stop at pixel y.
	 * @param {int} x_step  - increment x pixel each time.
	 * @param {int} x_end   - stop at pixel x.
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageData24bits = function (imageData, y_start, y_step, y_end, x_start, x_step, x_end) {
		var image = this.image;
		var width = this.header.width;
		var i = 0,
			x, y;

		for (y = y_start; y !== y_end; y += y_step) {
			for (x = x_start; x !== x_end; x += x_step, i += 3) {
				imageData[(x + width * y) * 4 + 3] = 255;
				imageData[(x + width * y) * 4 + 2] = image[i + 0];
				imageData[(x + width * y) * 4 + 1] = image[i + 1];
				imageData[(x + width * y) * 4 + 0] = image[i + 2];
			}
		}

		return imageData;
	};

	/**
	 * Return a ImageData object from a TGA file (32bits)
	 *
	 * @param {imageData} imageData - ImageData to bind
	 * @param {int} y_start - start at y pixel.
	 * @param {int} x_start - start at x pixel.
	 * @param {int} y_step  - increment y pixel each time.
	 * @param {int} y_end   - stop at pixel y.
	 * @param {int} x_step  - increment x pixel each time.
	 * @param {int} x_end   - stop at pixel x.
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageData32bits = function (imageData, y_start, y_step, y_end, x_start, x_step, x_end) {
		var image = this.image;
		var width = this.header.width;
		var i = 0,
			x, y;

		for (y = y_start; y !== y_end; y += y_step) {
			for (x = x_start; x !== x_end; x += x_step, i += 4) {
				imageData[(x + width * y) * 4 + 2] = image[i + 0];
				imageData[(x + width * y) * 4 + 1] = image[i + 1];
				imageData[(x + width * y) * 4 + 0] = image[i + 2];
				imageData[(x + width * y) * 4 + 3] = image[i + 3];
			}
		}

		return imageData;
	};

	/**
	 * Return a ImageData object from a TGA file (8bits grey)
	 *
	 * @param {imageData} imageData - ImageData to bind
	 * @param {int} y_start - start at y pixel.
	 * @param {int} x_start - start at x pixel.
	 * @param {int} y_step  - increment y pixel each time.
	 * @param {int} y_end   - stop at pixel y.
	 * @param {int} x_step  - increment x pixel each time.
	 * @param {int} x_end   - stop at pixel x.
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageDataGrey8bits = function (imageData, y_start, y_step, y_end, x_start, x_step, x_end) {
		var image = this.image;
		var width = this.header.width;
		var color, i = 0,
			x, y;

		for (y = y_start; y !== y_end; y += y_step) {
			for (x = x_start; x !== x_end; x += x_step, i++) {
				color = image[i];
				imageData[(x + width * y) * 4 + 0] = color;
				imageData[(x + width * y) * 4 + 1] = color;
				imageData[(x + width * y) * 4 + 2] = color;
				imageData[(x + width * y) * 4 + 3] = 255;
			}
		}

		return imageData;
	};

	/**
	 * Return a ImageData object from a TGA file (16bits grey)
	 *
	 * @param {imageData} imageData - ImageData to bind
	 * @param {int} y_start - start at y pixel.
	 * @param {int} x_start - start at x pixel.
	 * @param {int} y_step  - increment y pixel each time.
	 * @param {int} y_end   - stop at pixel y.
	 * @param {int} x_step  - increment x pixel each time.
	 * @param {int} x_end   - stop at pixel x.
	 * @returns {imageData}
	 */
	TgaLoader.prototype.getImageDataGrey16bits = function (imageData, y_start, y_step, y_end, x_start, x_step, x_end) {
		var image = this.image;
		var width = this.header.width;
		var i = 0,
			x, y;

		for (y = y_start; y !== y_end; y += y_step) {
			for (x = x_start; x !== x_end; x += x_step, i += 2) {
				imageData[(x + width * y) * 4 + 0] = image[i + 0];
				imageData[(x + width * y) * 4 + 1] = image[i + 0];
				imageData[(x + width * y) * 4 + 2] = image[i + 0];
				imageData[(x + width * y) * 4 + 3] = image[i + 1];
			}
		}

		return imageData;
	};

	TgaLoader.prototype.isSupported = function () {
		return true;
	};

	TgaLoader.prototype.toString = function () {
		return "TgaLoader";
	};

	return TgaLoader;
})();
goo.CanvasUtils = (function (
	PromiseUtils,
	ObjectUtils
) {
	'use strict';

	// TODO: make promise based instead of sending callbacks

	/**
	 * Provides useful canvas-related methods
	 */
	function CanvasUtils() {}

	// REVIEW: add documentation about what happens if the image is corrupt
	/**
	 * Loads an image element from a given URL and returns the image rendered on a canvas within a callback.
	 *
	 * @param {string} canvasPath	                 The URL to the image to render to the canvas.
	 * @param {Object} [options]
	 * @param {number} [options.width]             Resulting width of the canvas, falls back to image width.
	 * @param {number} [options.height]            Resulting height of the canvas, falls back to image height.
	 * @param {number} [options.sourceX]           Where to start clipping in x
	 * @param {number} [options.sourceY]           Where to start clipping in y
	 * @param {number} [options.sourceWidth]       The width of the clipped image
	 * @param {number} [options.sourceHeight]      The height of the clipped image
	 * @param {number} [options.destX]             Destination frame offset in x
	 * @param {number} [options.destY]             Destination frame offset in y
	 * @param {number} [options.destWidth]         Destination frame width
	 * @param {number} [options.destHeight]        Destination frame height
	 * @param {number} [options.resizeToFit=false] If true, the image is stretched to fit and centered on the canvas.
	 * @param {Function} callback
	 */
	CanvasUtils.loadCanvasFromPath = function (canvasPath, callback) {
		var options = {};
		if (arguments.length === 3) {
			// Called with loadCanvasFromPath(path, options, callback)
			options = arguments[1];
			callback = arguments[2];
		}

		// have the image load
		var img = new Image();
		img.onerror = function () {
			console.error('Failed to load svg!');
			callback();
		};
		img.src = canvasPath;

		// create an off screen canvas
		var canvas = document.createElement('canvas');

		// get its context
		var context = canvas.getContext('2d');

		img.onload = function () {
			// when ready, paint the image on the canvas

			if (img.width === 0 && img.height === 0) {
				// Could not load
				return callback();
			}

			ObjectUtils.defaults(options, {
				// Canvas size
				width: img.width,
				height: img.height,

				// Clipping window size & position
				sourceX: 0,
				sourceY: 0,
				sourceWidth: img.width,
				sourceHeight: img.height,

				// Destination window size & position
				destX: 0,
				destY: 0
			});

			ObjectUtils.defaults(options, {
				destWidth: options.width,
				destHeight: options.height
			});

			if (options.resizeToFit) {
				// preserve aspect ratio of input image and center it
				var ratio = options.sourceWidth / options.sourceHeight;
				if (ratio > 1) {
					options.destHeight = options.destWidth / ratio;
					options.destY = (options.height - options.destHeight) * 0.5;
				} else if (ratio < 1) {
					options.destWidth = options.destHeight * ratio;
					options.destX = (options.width - options.destWidth) * 0.5;
				}
			}

			// Set dimensions
			canvas.width = options.width;
			canvas.height = options.height;

			// Render to canvas
			context.drawImage(
				img,
				options.sourceX, options.sourceY,
				options.sourceWidth, options.sourceHeight,
				options.destX, options.destY,
				options.destWidth, options.destHeight
			);

			callback(canvas);
		};
	};

	/**
	 * Renders an SVG to a canvas element.
	 *
	 * @param {string} svgSource			The SVG XML source code
	 * @param {Object} options				Will be passed to loadCanvasFromPath.
	 * @param {Function} callback			Will be called when done. The single argument to this function will be the HTMLCanvasElement, or null if an error occurred.
	 * @example
	 * var data = '&lt;svg xmlns="http://www.w3.org/2000/svg" width=100 height=100&gt;&lt;rect x=0 y=0 width=100 height=100 fill="blue" /&gt;&lt;/svg&gt;';
	 * CanvasUtils.renderSvgToCanvas(data, {
	 *     resizeToFit:true,
	 *     width:100,
	 *     height:100
	 * }, function (canvas){
	 *     // canvas is an HTMLCanvasElement
	 * });
	 */
	CanvasUtils.renderSvgToCanvas = function (svgSource, options, callback) {
		var url = 'data:image/svg+xml;base64,' + btoa(svgSource);

		CanvasUtils.loadCanvasFromPath(url, options, callback);
	};

	/**
	 * Takes a canvas element and returns it's image data as a matrix.
	 * Useful for things such as heightmap displacement from image source.
	 *
	 * @param canvas
	 * @returns {Array}
	 */
	CanvasUtils.getMatrixFromCanvas = function (canvas) {
		var context = canvas.getContext('2d');

		var getAt = function (x, y) {
			if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) {
				return 0;
			} else {
				return context.getImageData(x, y, 1, 1).data[0] / 255;
			}
		};

		var matrix = [];
		for (var i = 0; i < canvas.width; i++) {
			matrix.push([]);
			for (var j = 0; j < canvas.height; j++) {
				matrix[i].push(getAt(i, canvas.height - (j + 1)));
			}
		}
		return matrix;
	};

	/**
	 *
	 * Convert SVG XML content to an HTMLImageElement.
	 * @param  {string} data
	 * @returns {RSVP.Promise} Promise that resolves with the Image.
	 */
	CanvasUtils.svgDataToImage = function (data) {
		var DOMURL = window.URL || window.webkitURL || window;

		var svg = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });

		var img = new Image();
		img.src = DOMURL.createObjectURL(svg);

		return PromiseUtils.createPromise(function (resolve, reject) {
			img.onload = function () {
				resolve(img);
			};
			img.onerror = function () {
				reject('Could not load SVG image.');
			};
		});
	};

	return CanvasUtils;
})(goo.PromiseUtils,goo.ObjectUtils);
goo.SystemBus = (function (
	Bus
) {
	'use strict';

	/**
	 * SystemBus is a global instance of the {@link Bus} class.
	 * @target-class SystemBus SystemBus constructor
	 * @require-path goo/entities/SystemBus
	 * @group entities
	 */
	return new Bus();
})(goo.Bus);
goo.TextureHandler = (function (
	ConfigHandler,
	Texture,
	DdsLoader,
	CrunchLoader,
	TgaLoader,
	RSVP,
	PromiseUtils,
	RendererUtils,
	_,
	CanvasUtils,
	StringUtils,
	SystemBus,
	MathUtils
) {
	'use strict';

	/*jshint eqeqeq: false, -W041 */
	/**
	 * Handler for loading materials into engine
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function TextureHandler() {
		ConfigHandler.apply(this, arguments);
		SystemBus.addListener('playStateChanged', function (playState) {
			this._objects.forEach(function (texture) {
				if (texture.image && texture.image.play && texture.image.pause) {
					var video = texture.image;
					if (playState === 'play') {
						video.play();
					} else if (playState === 'stop') {
						video.pause();
						video.currentTime = 0;
					} else if (playState === 'pause') {
						video.pause();
					}
				}
			});
		}.bind(this));
	}

	TextureHandler.prototype = Object.create(ConfigHandler.prototype);
	TextureHandler.prototype.constructor = TextureHandler;
	ConfigHandler._registerClass('texture', TextureHandler);

	TextureHandler.minFilters = [
		'NearestNeighborNoMipMaps',
		'NearestNeighborNearestMipMap',
		'NearestNeighborLinearMipMap',
		'BilinearNoMipMaps',
		'BilinearNearestMipMap',
		'Trilinear'
	];

	TextureHandler.magFilters = [
		'NearestNeighbor',
		'Bilinear'
	];

	TextureHandler.noMipMapAlternatives = {
		'NearestNeighborNoMipMaps': 'NearestNeighborNoMipMaps',
		'NearestNeighborNearestMipMap': 'NearestNeighborNoMipMaps',
		'NearestNeighborLinearMipMap': 'NearestNeighborNoMipMaps',
		'BilinearNoMipMaps': 'BilinearNoMipMaps',
		'BilinearNearestMipMap': 'BilinearNoMipMaps',
		'Trilinear': 'BilinearNoMipMaps'
	};

	TextureHandler.loaders = {
		dds: DdsLoader,
		crn: CrunchLoader, // TODO: not working atm.
		tga: TgaLoader
	};

	// Dummy textures to use while loading image
	TextureHandler.WHITE = new Uint8Array([255, 255, 255, 255]);
	TextureHandler.BLACK = new Uint8Array([0, 0, 0, 255]);

	/**
	 * Preparing texture config by populating it with defaults.
	 * @param {Object} config
	 * @private
	 */
	TextureHandler.prototype._prepare = function (config) {
		_.defaults(config, {
			wrapS: 'Repeat',
			wrapT: 'Repeat',
			magFilter: 'Bilinear',
			minFilter: 'Trilinear',
			anisotropy: 1,
			offset: [0, 0],
			repeat: [1, 1],
			flipY: true,
			lodBias: 0.0,
			loop: true
		});
	};

	/**
	 * Removes a texture
	 * @param {string} ref
	 * @private
	 */
	TextureHandler.prototype._remove = function (ref) {
		var texture = this._objects.get(ref);
		if (texture && this.world.gooRunner) {
			texture.destroy(this.world.gooRunner.renderer.context);
		}
		this._objects.delete(ref);
	};

	/**
	 * Creates an empty Texture.
	 * @returns {Texture}
	 * @private
	 */
	TextureHandler.prototype._create = function () {
		return new Texture();
	};


	TextureHandler.prototype._loadWebSupportedImage = function (texture, config, options) {
		return this.loadObject(config.imageRef, options).then(function (image) {
			if (texture.image !== image) {
				texture.setImage(image);
			}
			return texture;
		});
	};

	TextureHandler.prototype._loadSpecialImage = function (texture, config, type, options) {
		// Special (dds, tga, crn)
		var Loader = TextureHandler.loaders[type];
		var imageRef = config.imageRef;
		return this.loadObject(imageRef)
		.then(function (data) {
			if (data && data.preloaded) {
				_.extend(texture.image, data.image);
				texture.format = data.format;
				texture.setNeedsUpdate();
				return texture;
			}
			var loader = new Loader();
			loader.load(data, texture, config.flipY, 0, data.byteLength);
			return texture;
		});
	};

	TextureHandler.prototype._loadVideo = function (texture, config, options) {
		// Video
		return this.loadObject(config.imageRef, options).then(function (video) {
			video.width = video.videoWidth;
			video.height = video.videoHeight;
			video.loop = config.loop !== undefined ? config.loop : true;

			if (!(MathUtils.isPowerOfTwo(video.width) && MathUtils.isPowerOfTwo(video.height))) {
				texture.generateMipmaps = false;
				texture.minFilter = 'BilinearNoMipMaps';
			}
			texture.setImage(video);
			texture.updateCallback = function () {
				return !video.paused;
			};
			if (config.autoPlay !== false && !options.editMode) {
				video.play();
			}
			else {
				video.pause();
				video.currentTime = 0;
			}
			return texture;
		});
	};

	TextureHandler.prototype._loadImage = function (texture, config, options) {
		var imageRef = config.imageRef;
		var path = StringUtils.parseURL(imageRef).path;
		var type = path.substr(path.lastIndexOf('.') + 1).toLowerCase();
		if (TextureHandler.loaders[type]) {
			return this._loadSpecialImage(texture, config, type, options);
		}
		if (['jpg', 'jpeg', 'png', 'gif'].indexOf(type) !== -1) {
			return this._loadWebSupportedImage(texture, config, options);
		}
		if (['mp4', 'ogv', 'webm'].indexOf(type) !== -1) {
			return this._loadVideo(texture, config, options);
		}

		return PromiseUtils.reject(new Error('Unknown image type: ' + type));
	};

	/**
	 * Adds/updates/removes a texture
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated texture or null if removed
	 */
	TextureHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (texture) {
			if (!texture) { return; }
			var ret;

			// Texture settings
			texture.wrapS = config.wrapS;
			texture.wrapT = config.wrapT;

			if (TextureHandler.magFilters.indexOf(config.magFilter) !== -1) {
				texture.magFilter = config.magFilter;
			}
			if (TextureHandler.minFilters.indexOf(config.minFilter) !== -1) {
				texture.minFilter = config.generateMipmaps !== false ?
					config.minFilter :
					TextureHandler.noMipMapAlternatives[config.minFilter];
			}

			texture.anisotropy = Math.max(config.anisotropy, 1);

			texture.offset.setDirect(config.offset[0], config.offset[1]);
			texture.repeat.setDirect(config.repeat[0], config.repeat[1]);
			texture.lodBias = config.lodBias;

			if (texture.flipY !== config.flipY) {
				texture.flipY = config.flipY;
				texture.setNeedsUpdate();
			}

			if (texture.generateMipmaps !== config.generateMipmaps) {
				texture.generateMipmaps = config.generateMipmaps !== false;
				texture.setNeedsUpdate();
			}

			texture.updateCallback = null;

			if (config.imageRef) {
				if (!config.lazy) {
					ret = that._loadImage(texture, config, options);
				} else {
					texture.loadImage = function () {
						return that._loadImage(texture, config, options);
					};
					ret = texture;
				}
			} else if (config.svgData) {
				// Load SVG data
				ret = PromiseUtils.createPromise(function (resolve, reject) {
					CanvasUtils.renderSvgToCanvas(config.svgData, {}, function (canvas) {
						if (canvas) {
							texture.setImage(canvas);
							resolve(texture);
						} else {
							reject('could not render svg to canvas');
						}
					});
				});
			} else {
				// Blank
				// console.warn('Texture ' + ref + ' has no imageRef');
				// texture.setImage(TextureHandler.WHITE, 1, 1);
				ret = texture;
			}
			if (options && options.texture && options.texture.dontwait) {
				return texture;
			} else {
				return ret;
			}
		});
	};

	return TextureHandler;
})(goo.ConfigHandler,goo.Texture,goo.DdsLoader,goo.CrunchLoader,goo.TgaLoader,goo.rsvp,goo.PromiseUtils,goo.RendererUtils,goo.ObjectUtils,goo.CanvasUtils,goo.StringUtils,goo.SystemBus,goo.MathUtils);
goo.Ajax = (function (
	TextureHandler,
	PromiseUtils,
	_,
	StringUtils,
	RSVP
) {
	'use strict';

	/**
	 * Ajax helper class
	 * @param {string} rootPath
	 * @param {Object} options
	 */
	function Ajax(rootPath, options) {
		if (rootPath) {
			this._rootPath = rootPath;
			if (rootPath.slice(-1) !== '/') {
				this._rootPath += '/';
			}
		}
		this.options = options || {};
		this._cache = {};
	}

	/**
	 * Prefill ajax cache with data
	 * @param {Object} bundle Pairs of key-configs
	 * @param {boolean} [clear=false] If set to true will overwrite cache, otherwise extend it
	 */
	Ajax.prototype.prefill = function (bundle, clear) {
		if (clear) {
			this._cache = bundle;
		} else {
			_.extend(this._cache, bundle);
		}
	};

	/**
	 * Clears the ajax cache
	 * Is called by {@link DynamicLoader.clear}
	 */
	Ajax.prototype.clear = function () {
		this._cache = {};
	};

	/**
	 * Uses GET to retrieve data at a remote location.
	 * @hidden
	 * @param {Object} options
	 * @param {string} options.url
	 * @returns {Promise} Returns a promise that is resolved and rejected with the XMLHttpRequest.
	 */
	Ajax.prototype.get = function (options) {
		options = options || {};
		var url = options.url || '';

		var method = 'GET';

		var request = new XMLHttpRequest();

		request.open(method, url, true);
		if (options.responseType) {
			request.responseType = options.responseType;
		}

		return PromiseUtils.createPromise(function (resolve, reject) {
			var handleStateChange = function () {
				if (request.readyState === 4) {
					if (request.status >= 200 && request.status <= 299) {
						request.removeEventListener('readystatechange', handleStateChange);
						resolve(request);
					} else {
						request.removeEventListener('readystatechange', handleStateChange);
						reject(request.statusText);
					}
				}
			};

			request.addEventListener('readystatechange', handleStateChange);

			request.send();
		});
	};

	Ajax.ARRAY_BUFFER = 'arraybuffer';
	Ajax.crossOrigin = false;

	var MIME_TYPES = {
		mp4: 'video/mp4',
		ogv: 'video/ogg',
		webm: 'video/webm'
	};

	/**
	 * Loads data at specified path which is returned in a Promise object.
	 *
	 * @param {string} path Path to whatever shall be loaded.
	 * @param {boolean} [reload=false] If set to true, reloads even if url is cached
	 *
	 * @returns {RSVP.Promise} The promise is resolved with the data loaded. If a parser is specified
	 * the data will be of the type resolved by the parser promise.
	 */
	Ajax.prototype.load = function (path, reload) {
		var that = this;
		var path2 = StringUtils.parseURL(path).path;//! AT: dunno what to call this
		var type = path2.substr(path2.lastIndexOf('.') + 1).toLowerCase();

		function typeInGroup(type, group) {
			return type && Ajax.types[group] && Ajax.types[group][type];
		}

		if (!path) {
			PromiseUtils.reject('Path was undefined'); //! AT: no return?
			// anyways, the engine should not call this method without a path
		}

		if (path.indexOf(Ajax.ENGINE_SHADER_PREFIX) === 0) {
			return PromiseUtils.resolve();
		}

		if (this._cache[path] && !reload) {
			if (typeInGroup(type, 'bundle')) {
				this.prefill(this._cache[path], reload);
			}
			if (this._cache[path] instanceof RSVP.Promise) {
				return this._cache[path];
			} else {
				return PromiseUtils.resolve(this._cache[path]);
			}
		}

		var url = this._rootPath ? this._rootPath + path : path;

		if (typeInGroup(type, 'image')) {
			this._cache[path] = this._loadImage(url);
			return this._cache[path];
		} else if (typeInGroup(type, 'video')) {
			this._cache[path] = this._loadVideo(url, MIME_TYPES[type]);
			return this._cache[path];
		} else if (typeInGroup(type, 'audio')) {
			this._cache[path] = this._loadAudio(url);
			return this._cache[path];
		}

		var ajaxProperties = {
			url: url
		};

		if (typeInGroup(type, 'binary')) {
			ajaxProperties.responseType = Ajax.ARRAY_BUFFER;
		}

		return this._cache[path] = this.get(ajaxProperties)
		.then(function (request) {
			if (typeInGroup(type, 'bundle')) {
				var bundle = JSON.parse(request.response);
				that.prefill(bundle, reload);
				return bundle;
			}
			if (typeInGroup(type, 'json')) {
				return JSON.parse(request.response);
			}
			return request.response;
		}).then(null, function (err) {
			throw new Error('Could not load data from ' + path + ', ' + err);
		});
	};

	Ajax.prototype.update = function (path, config) {
		this._cache[path] = config;
		return PromiseUtils.resolve(config);
	};

	/**
	 * Loads image data at specified path which is returned in a Promise object.
	 *
	 * @example
	 * loader.loadImage('resources/image.png').then(function (image) {
	 *   // handle {@link Image} image
	 * });
	 * @param {string} url Path to whatever shall be loaded.
	 * @returns {RSVP.Promise} The promise is resolved with an Image object.
	 */
	Ajax.prototype._loadImage = function (url) {
		window.URL = window.URL || window.webkitURL;
		var image = new Image();
		if (Ajax.crossOrigin) {
			image.crossOrigin = 'anonymous';
		}

		return PromiseUtils.createPromise(function (resolve, reject) {
			var onLoad = function loadHandler() {
				image.dataReady = true;
				if (window.URL && window.URL.revokeObjectURL !== undefined) {
					window.URL.revokeObjectURL(image.src);
				}
				image.removeEventListener('load', onLoad);
				image.removeEventListener('error', onError);
				resolve(image);
			};

			var onError = function errorHandler(e) {
				image.removeEventListener('load', onLoad);
				image.removeEventListener('error', onError);
				reject('Could not load image from ' + url + ', ' + e);
			};

			image.addEventListener('load', onLoad, false);
			image.addEventListener('error', onError, false);

			image.src = url;
		});
	};

	Ajax.prototype._loadVideo = function (url, mimeType) {
		var VIDEO_LOAD_TIMEOUT = 1000; // Timeout to 'canplay' event.
		var video = document.createElement('video');
		var iOS = /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
		if (Ajax.crossOrigin) {
			video.crossOrigin = 'anonymous';
		}

		var promise = PromiseUtils.createPromise(function (resolve, reject) {
			var timeout;

			var _resolve = function () {
				if (!video.dataReady) {
					console.warn('Video is not ready');
				}
				video.removeEventListener('canplay', canPlay);
				video.removeEventListener('loadstart', loadStart);
				clearTimeout(timeout);
				resolve(video);
			};

			var canPlay = function () {
				video.dataReady = true;
				_resolve();
			};

			var loadStart = function () {
				if (iOS) {
					_resolve();
				}
				else {
					timeout = setTimeout(_resolve, VIDEO_LOAD_TIMEOUT);
				}
			};

			// iOS doesn't auto-load video
			video.addEventListener('canplay', canPlay, false);
			video.addEventListener('loadstart', loadStart, false);

			video.addEventListener('error', function (e) {
				reject('Could not load video from ' + url + ', ' + e);
			}, false);
		});

		var ajaxProperties = {
			url: url,
			responseType: Ajax.ARRAY_BUFFER
		};

		this.get(ajaxProperties).then(function (request) {
			var blob = new Blob([request.response], { type: mimeType });
			var url = window.URL.createObjectURL(blob);
			video.src = url;
		});

		return promise;
	};

	Ajax.prototype._loadAudio = function (url) {
		var ajaxProperties = {
			url: url,
			responseType: Ajax.ARRAY_BUFFER
		};
		return this.get(ajaxProperties).then(function (request) {
			return request.response;
		})
		.then(null, function (err) {
			throw new Error('Could not load data from ' + url + ', ' + err);
		});
	};

	// TODO Put this somewhere nicer
	Ajax.ENGINE_SHADER_PREFIX = 'GOO_ENGINE_SHADERS/';

	function addKeys(obj, keys) {
		for (var i = 0; i < keys.length; i++) {
			obj[keys[i]] = true;
		}
		return obj;
	}

	Ajax.types = {
		text: {
			vert: true,
			frag: true // + Scripts in the future
		},
		json: {
			shader: true,
			script: true,
			entity: true,
			material: true,
			scene: true,
			mesh: true,
			texture: true,
			skeleton: true,
			animation: true,
			clip: true,
			bundle: true,
			project: true,
			machine: true,
			posteffects: true,
			animstate: true,
			sound: true,
			environment: true,
			skybox: true
		},
		image: {
			jpg: true,
			jpeg: true,
			png: true,
			gif: true
		},
		video: {
			mp4: true,
			ogv: true,
			webm: true
		},
		binary: addKeys({
			dat: true,
			bin: true
		}, Object.keys(TextureHandler.loaders)),
		audio: {
			mp3: true,
			wav: true,
			ogg: true
		},
		bundle: {
			bundle: true
		}
	};

	Ajax.types.asset = addKeys(
		{},
		Object.keys(Ajax.types.image)
			.concat(Object.keys(Ajax.types.binary))
	);

	return Ajax;
})(goo.TextureHandler,goo.PromiseUtils,goo.ObjectUtils,goo.StringUtils,goo.rsvp);
goo.TextureCreator = (function (
	Texture,
	MathUtils,
	TextureHandler,
	Ajax,
	StringUtils,
	PromiseUtils,
	RSVP
) {
	'use strict';

	//! AT: shouldn't this stay in util?

	/**
	 * Takes away the pain of creating textures of various sorts.
	 * @param {Settings} settings Texturing settings
	 */
	function TextureCreator() {
		var ajax = this.ajax = new Ajax();
		this.textureHandler = new TextureHandler(
			{},
			function (ref, options) {
				return ajax.load(ref, options ? options.noCache : false);
			},
			function () {},
			function (ref, options) {
				return ajax.load(ref, options ? options.noCache : false);
			}
		);
	}

	//! AT: unused?
	TextureCreator.UNSUPPORTED_FALLBACK = '.png';
	TextureCreator.clearCache = function () {};

	/**
	 * Releases any references to cached objects
	 */
	TextureCreator.prototype.clear = function () {
		this.ajax.clear();
		this.textureHandler.clear();
	};

	/**
	 * Creates a texture and loads an image into it.
	 * @param {string} imageUrl
	 * @param {Object} settings passed to the {Texture} constructor
	 * @returns {RSVP.Promise} Returns a promise that will resolve with the created Texture.
	 * @example
	 * new TextureCreator().loadTexture2D('goo.jpg').then(function (texture) {
	 *     material.setTexture('DIFFUSE_MAP', texture);
	 * }, function () {
	 *     console.error('Error loading image.');
	 * });
	 */
	TextureCreator.prototype.loadTexture2D = function (imageUrl, settings) {
		var id = StringUtils.createUniqueId('texture');
		settings = settings || {};
		settings.imageRef = imageUrl;

		var texture = this.textureHandler._create();
		this.textureHandler._objects.set(id, texture);
		return this.textureHandler.update(id, settings);
	};

	/**
	 * Creates a texture and loads a video into it
	 * @param {string} videoURL
	 * @param {Object} [options]
	 * @param {boolean} [options.loop=true]
	 * @param {boolean} [options.autoPlay=true]
	 * @param {boolean} [options.wrapS='EdgeClamp']
	 * @param {boolean} [options.wrapT='EdgeClamp']
	 * @returns {RSVP.Promise} Returns a promise that will resolve with the created Texture.
	 * @example
	 * new TextureCreator().loadTexture2D('goo.mp4').then(function (texture) {
	 *     material.setTexture('DIFFUSE_MAP', texture);
	 * }, function () {
	 *     console.error('Error loading video texture.');
	 * });
	 */
	TextureCreator.prototype.loadTextureVideo = function (videoURL, options) {
		var id = StringUtils.createUniqueId('texture');
		options = options || {};
		options.imageRef = videoURL;
		options.loop = options.loop !== undefined ? options.loop : true;
		options.wrapS = options.wrapS !== undefined ? options.wrapS : 'EdgeClamp';
		options.wrapT = options.wrapT !== undefined ? options.wrapT : 'EdgeClamp';
		options.autoPlay = options.autoPlay !== undefined ? options.autoPlay : true;
		options.texture = options.texture !== undefined ? options.texture : { dontwait: true };

		var texture = this.textureHandler._create();
		this.textureHandler._objects.set(id, texture);

		return this.textureHandler.update(id, options, options);
	};

	/**
	 * Creates a video texture streamed from the webcam.
	 * @returns {RSVP.Promise} A promise that will resolve with the created Texture.
	 * @example
	 * new TextureCreator().loadTextureWebCam().then(function (texture) {
	 *     material.setTexture('DIFFUSE_MAP', texture);
	 * }, function () {
	 *     console.error('Error loading webcam texture.');
	 * });
	 */
	TextureCreator.prototype.loadTextureWebCam = function () {

		return PromiseUtils.createPromise(function (resolve, reject) {
			var video = document.createElement('video');
			video.autoplay = true;
			video.loop = true;

			var texture = new Texture(video, {
				wrapS: 'EdgeClamp',
				wrapT: 'EdgeClamp'
			});

			texture.readyCallback = function () {
				if (video.readyState >= 3) {
					video.width = video.videoWidth;
					video.height = video.videoHeight;

					// set minification filter based on pow2
					if (!(MathUtils.isPowerOfTwo(video.width) && MathUtils.isPowerOfTwo(video.height))) {
						texture.generateMipmaps = false;
						texture.minFilter = 'BilinearNoMipMaps';
					}

					video.dataReady = true;

					return true;
				}

				return false;
			};

			texture.updateCallback = function () {
				return !video.paused;
			};

			// Webcam video
			window.URL = window.URL || window.webkitURL;
			navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
			if (navigator.getUserMedia) {
				navigator.getUserMedia({
					video: true
				}, function (stream) {
					video.src = window.URL.createObjectURL(stream);
					resolve(texture);
				}, reject);
			} else {
				reject(new Error('No support for WebCam getUserMedia found!'));
			}
		});
	};

	/**
	 * Loads an array of six images into a Texture.
	 * @param {Array} imageDataArray Array containing images, image elements or image urls. [left, right, bottom, top, back, front]
	 * @param {Object} settings Settings object to pass to the Texture constructor
	 * @returns {RSVP.Promise} A promise that will resolve with the resulting Texture
	 */
	TextureCreator.prototype.loadTextureCube = function (imageDataArray, settings) {
		var texture = new Texture(null, settings);
		texture.variant = 'CUBE';

		var promises = imageDataArray.map(function (queryImage) {
			return PromiseUtils.createPromise(function (resolve, reject) {
				if (typeof queryImage === 'string') {
					this.ajax._loadImage(queryImage).then(resolve, reject);
				} else {
					resolve(queryImage);
				}
			}.bind(this));
		}.bind(this));

		return RSVP.all(promises).then(function (images) {
			return PromiseUtils.createPromise(function (resolve, reject) {
				var width = images[0].width;
				var height = images[0].height;
				for (var i = 0; i < 6; i++) {
					var image = images[i];
					if (width !== image.width || height !== image.height) {
						texture.generateMipmaps = false;
						texture.minFilter = 'BilinearNoMipMaps';
						reject(new Error('The images passed to loadTextureCube() must be of the same size!'));
						return;
					}
				}

				texture.setImage(images);
				texture.image.dataReady = true;
				texture.image.width = width;
				texture.image.height = height;

				resolve(texture);
			});
		});
	};

	//! AT: unused
	TextureCreator._globalCallback = null;
	TextureCreator._finishedLoading = function (image) {
		if (TextureCreator._globalCallback) {
			try {
				TextureCreator._globalCallback(image);
			} catch (e) {
				console.error('Error in texture callback:', e);
			}
		}
	};

	// Add Object.freeze when fast enough in browsers
	var colorInfo = new Uint8Array([255, 255, 255, 255]);
	TextureCreator.DEFAULT_TEXTURE_2D = new Texture(colorInfo, null, 1, 1);
	TextureCreator.DEFAULT_TEXTURE_CUBE = new Texture([colorInfo, colorInfo, colorInfo, colorInfo, colorInfo, colorInfo], null, 1, 1);
	TextureCreator.DEFAULT_TEXTURE_CUBE.variant = 'CUBE';

	return TextureCreator;
})(goo.Texture,goo.MathUtils,goo.TextureHandler,goo.Ajax,goo.StringUtils,goo.PromiseUtils,goo.rsvp);
goo.ObjectUtil = (function (ObjectUtils) {

	/**
	 * Object-related utilities
	 * @target-class ObjectUtil ObjectUtil constructor
	 * @require-path goo/util/ObjectUtil
	 * @group util
	 * @deprecated Deprecated as of 0.14.x and scheduled for removal in 0.16.0; The class has been renamed to `goo/util/ObjectUtils`
	 */
	return ObjectUtils;
})(goo.ObjectUtils);
goo.RenderTarget = (function (
	Vector2,
	ObjectUtil
) {
	'use strict';

	/**
	 * Creates a new RenderTarget object
	 *
	 * Post processing handler
	 * @param {number} width Width of rendertarget
	 * @param {number} height Height of rendertarget
	 * @param {Object} options Options
	 */
	function RenderTarget(width, height, options) {
		this.glTexture = null;
		this._glRenderBuffer = null;
		this._glFrameBuffer = null;

		this.width = Math.max(Math.floor(width), 1);
		this.height = Math.max(Math.floor(height), 1);

		ObjectUtil.copyOptions(this, options, {
			wrapS: 'EdgeClamp',
			wrapT: 'EdgeClamp',
			magFilter: 'Bilinear',
			minFilter: 'BilinearNoMipMaps',
			anisotropy: 1,
			format: 'RGBA',
			type: 'UnsignedByte',
			generateMipmaps: false,
			premultiplyAlpha: false,
			unpackAlignment: 1,
			flipY: true,
			depthBuffer: true,
			stencilBuffer: true
		});

		this.variant = '2D'; // CUBE

		this.offset = new Vector2(0, 0);
		this.repeat = new Vector2(1, 1);

		this.textureRecord = {};
	}

	RenderTarget.prototype.clone = function () {
		var tmp = new RenderTarget(this.width, this.height);

		tmp.wrapS = this.wrapS;
		tmp.wrapT = this.wrapT;

		tmp.magFilter = this.magFilter;
		tmp.minFilter = this.minFilter;

		tmp.anisotropy = this.anisotropy;

		tmp.format = this.format;
		tmp.type = this.type;
		tmp.variant = this.variant;

		tmp.offset.copy(this.offset);
		tmp.repeat.copy(this.repeat);

		tmp.generateMipmaps = this.generateMipmaps;
		tmp.premultiplyAlpha = this.premultiplyAlpha;
		tmp.unpackAlignment = this.unpackAlignment;
		tmp.flipY = this.flipY;

		tmp.depthBuffer = this.depthBuffer;
		tmp.stencilBuffer = this.stencilBuffer;

		return tmp;
	};

	/**
	 * Returns the number of bytes this render target occupies in memory
	 * @returns {number}
	 */
	RenderTarget.prototype.getSizeInMemory = function () {
		var size = this.width * this.height * 4;

		if (this.generateMipmaps) {
			size = Math.ceil(size * 4 / 3);
		}

		return size;
	};

	/**
	 * Deallocates all allocated resources from the WebGL context.
	 * @param  {WebGLRenderingContext} context
	 */
	RenderTarget.prototype.destroy = function (context) {
		if (this.glTexture) {
			context.deleteTexture(this.glTexture);
			this.glTexture = null;
		}
		if (this._glRenderBuffer) {
			context.deleteRenderbuffer(this._glRenderBuffer);
			this._glRenderBuffer = null;
		}
		if (this._glFrameBuffer) {
			context.deleteFramebuffer(this._glFrameBuffer);
			this._glFrameBuffer = null;
		}
	};

	return RenderTarget;
})(goo.Vector2,goo.ObjectUtil);
goo.ShaderCall = (function () {
	'use strict';

	/**
	 * Makes sure shader calls are not done when already set
	 */
	function ShaderCall(context, uniform, type) {
		this.context = context;
		this.location = uniform;
		this.location.value = undefined;

		if (type) {
			switch (type) {
				case 'float':
					this.call = this.uniform1f;
					break;
				case 'bool':
				case 'int':
				case 'integer':
				case 'sampler2D':
				case 'sampler3D':
				case 'samplerCube':
					this.call = this.uniform1i;
					break;
				case 'floatarray':
					this.call = this.uniform1fv;
					break;
				case 'intarray':
				case 'samplerArray':
					this.call = this.uniform1iv;
					break;
				case 'ivec2':
					this.call = this.uniform2iv;
					break;
				case 'ivec3':
					this.call = this.uniform3iv;
					break;
				case 'ivec4':
					this.call = this.uniform4iv;
					break;
				case 'vec2':
					this.call = this.uniform2fv;
					break;
				case 'vec3':
					this.call = this.uniform3fv;
					break;
				case 'vec4':
					this.call = this.uniform4fv;
					break;
				case 'mat2':
					this.call = this.uniformMatrix2fv;
					break;
				case 'mat3':
					this.call = this.uniformMatrix3fv;
					break;
				case 'mat4':
					this.call = this.uniformMatrix4fv;
					break;
				default:
					throw new Error('Uniform type not handled: ' + type);
			}
		}
	}

	ShaderCall.prototype.uniform1f = function (v0) {
		var curValue = this.location.value;
		if (curValue === v0) {
			return;
		}
		this.context.uniform1f(this.location, v0);
		this.location.value = v0;
	};

	ShaderCall.prototype.uniform1fv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		}
		this.context.uniform1fv(this.location, values);
		this.location.value = values.slice();
	};

	ShaderCall.prototype.uniform1i = function (v0) {
		var curValue = this.location.value;
		if (curValue === v0) {
			return;
		}
		this.context.uniform1i(this.location, v0);
		this.location.value = v0;
	};

	ShaderCall.prototype.uniform1iv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		}
		this.context.uniform1iv(this.location, values);
		this.location.value = values.slice();
	};

	ShaderCall.prototype.uniform2f = function (v0, v1) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (curValue[0] === v0 && curValue[1] === v1) {
				return;
			}
		}
		this.context.uniform2f(this.location, v0, v1);
		this.location.value = [v0, v1];
	};

	ShaderCall.prototype.uniform2fv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		} else {
			curValue = this.location.value = new Float64Array(values.length);
		}
		this.context.uniform2fv(this.location, values);
		var l = values.length;
		while (l--) {
			curValue[l] = values[l];
		}
	};

	ShaderCall.prototype.uniform2i = function (v0, v1) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (curValue[0] === v0 && curValue[1] === v1) {
				return;
			}
		}
		this.context.uniform2i(this.location, v0, v1);
		this.location.value = [v0, v1];
	};

	ShaderCall.prototype.uniform2iv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		}
		this.context.uniform2iv(this.location, values);
		this.location.value = values.slice();
	};

	ShaderCall.prototype.uniform3f = function (v0, v1, v2) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (curValue[0] === v0 && curValue[1] === v1 && curValue[2] === v2) {
				return;
			}
		} else {
			curValue = this.location.value = [];
		}
		this.context.uniform3f(this.location, v0, v1, v2);
		curValue[0] = v0;
		curValue[1] = v1;
		curValue[2] = v2;
	};

	ShaderCall.prototype.uniform3fv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		} else {
			curValue = this.location.value = new Float64Array(values.length);
		}
		this.context.uniform3fv(this.location, values);
		var l = values.length;
		while (l--) {
			curValue[l] = values[l];
		}
	};

	ShaderCall.prototype.uniform3i = function (v0, v1, v2) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (curValue[0] === v0 && curValue[1] === v1 && curValue[2] === v2) {
				return;
			}
		}
		this.context.uniform3i(this.location, v0, v1, v2);
		this.location.value = [v0, v1, v2];
	};

	ShaderCall.prototype.uniform3iv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		}
		this.context.uniform3iv(this.location, values);
		this.location.value = values.slice();
	};

	ShaderCall.prototype.uniform4f = function (v0, v1, v2, v3) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (curValue[0] === v0 && curValue[1] === v1 && curValue[2] === v2 && curValue[3] === v3) {
				return;
			}
		}
		this.context.uniform4f(this.location, v0, v1, v2, v3);
		this.location.value = [v0, v1, v2, v3];
	};

	ShaderCall.prototype.uniform4fv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		} else {
			curValue = this.location.value = new Float64Array(values.length);
		}
		this.context.uniform4fv(this.location, values);
		var l = values.length;
		while (l--) {
			curValue[l] = values[l];
		}
	};

	ShaderCall.prototype.uniform4i = function (v0, v1, v2, v3) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (curValue[0] === v0 && curValue[1] === v1 && curValue[2] === v2 && curValue[3] === v3) {
				return;
			}
		}
		this.context.uniform4i(this.location, v0, v1, v2, v3);
		this.location.value = [v0, v1, v2, v3];
	};

	ShaderCall.prototype.uniform4iv = function (values) {
		var curValue = this.location.value;
		if (curValue !== undefined) {
			if (compareArrays(values, curValue)) {
				return;
			}
		}
		this.context.uniform4iv(this.location, values);
		this.location.value = values.slice();
	};

	function compareArrays(a1, a2) {
		var l = a1.length;
		while (l--) {
			if (a1[l] !== a2[l]) {
				return false;
			}
		}
		return true;
	}

	// NOTE: optimize check before calling.
	ShaderCall.prototype.uniformMatrix2fv = function (matrix, transpose) {
		transpose = transpose === true;
		if (!matrix.data) {
			var values = matrix;
			var curValue = this.location.value;
			if (curValue !== undefined) {
				if (compareArrays(values, curValue)) {
					return;
				}
			} else {
				curValue = this.location.value = new Float64Array(values.length);
			}
			this.context.uniformMatrix2fv(this.location, transpose, values);
			var l = values.length;
			while (l--) {
				curValue[l] = values[l];
			}
			return;
		}

		var curValue = this.location.value;
		if (curValue !== undefined) {
			var equals = compareArrays(curValue.data, matrix.data);
			if (equals) {
				return;
			} else {
				curValue.copy(matrix);
			}
		} else {
			this.location.value = matrix.clone();
		}

		this.context.uniformMatrix2fv(this.location, transpose, matrix.data);
	};

	// NOTE: optimize check before calling.
	ShaderCall.prototype.uniformMatrix3fv = function (matrix, transpose) {
		transpose = transpose === true;
		if (!matrix.data) {
			var values = matrix;
			var curValue = this.location.value;
			if (curValue !== undefined) {
				if (compareArrays(values, curValue)) {
					return;
				}
			} else {
				curValue = this.location.value = new Float64Array(values.length);
			}
			this.context.uniformMatrix3fv(this.location, transpose, values);
			var l = values.length;
			while (l--) {
				curValue[l] = values[l];
			}
			return;
		}

		var curValue = this.location.value;
		if (curValue !== undefined) {
			var equals = compareArrays(curValue.data, matrix.data);
			if (equals) {
				return;
			} else {
				curValue.copy(matrix);
			}
		} else {
			this.location.value = matrix.clone();
		}

		this.context.uniformMatrix3fv(this.location, transpose, matrix.data);
	};

	ShaderCall.prototype.uniformMatrix4fv = function (matrix, transpose) {
		transpose = transpose === true;
		if (!matrix.data) {
			var values = matrix;
			var curValue = this.location.value;
			if (curValue !== undefined) {
				if (compareArrays(values, curValue)) {
					return;
				}
			} else {
				curValue = this.location.value = new Float64Array(values.length);
			}
			this.context.uniformMatrix4fv(this.location, transpose, values);
			var l = values.length;
			while (l--) {
				curValue[l] = values[l];
			}
			return;
		}

		var curValue = this.location.value;
		if (curValue !== undefined) {
			var equals = compareArrays(curValue.data, matrix.data);
			if (equals) {
				return;
			} else {
				curValue.copy(matrix);
			}
		} else {
			this.location.value = matrix.clone();
		}

		this.context.uniformMatrix4fv(this.location, transpose, matrix.data);
	};

	return ShaderCall;
})();
goo.RenderQueue = (function (Vector3) {
	'use strict';

	/**
	 * The RenderQueue handles sorting of entities. Entities are ordered by their renderQueue value into buckets.
	 * Entities within the opaque buckets are sorted front to back and entities within the transparent buckets are sorted
	 * back to front.
	 */
	function RenderQueue() {
		this.opaqueSorter = function (a, b) {
			var shader1 = a.meshRendererComponent.materials[0].shader;
			var shader2 = b.meshRendererComponent.materials[0].shader;
			if (shader1 === null || shader2 === null) {
				return 0;
			}
			if (shader1.defineKey === shader2.defineKey) {
				return a.meshRendererComponent._renderDistance - b.meshRendererComponent._renderDistance;
			}

			if (shader2.defineKey < shader1.defineKey) {
				return -1;
			} else if (shader2.defineKey > shader1.defineKey) {
				return 1;
			} else {
				return 0;
			}
		};

		this.transparentSorter = function (a, b) {
			return b.meshRendererComponent._renderDistance - a.meshRendererComponent._renderDistance;
		};

		this.bucketSorter = function (a, b) {
			return a - b;
		};
	}

	var bucketSortList = [];

	var tmpVec = new Vector3();

	/**
	 * @param {Array<Entity>} renderList
	 * @param {Camera} camera
	 */
	RenderQueue.prototype.sort = function (renderList, camera) {
		// TODO: Reuse objects more
		var index = 0;
		var buckets = {};
		bucketSortList.length = 0;
		for (var i = 0, l = renderList.length; i < l; i++) {
			var renderable = renderList[i];
			var meshRendererComponent = renderable.meshRendererComponent;

			if (!meshRendererComponent || meshRendererComponent.materials.length === 0) {
				renderList[index] = renderable;
				index++;
				continue;
			}
			var renderQueue = meshRendererComponent.materials[0].getRenderQueue();

			var distance = 0;
			var bound = meshRendererComponent.worldBound;
			if (bound !== null) {
				distance = tmpVec.set(camera.translation).sub(bound.center).lengthSquared();
			} else if (renderable.transformComponent) {
				distance = tmpVec.set(camera.translation).sub(renderable.transformComponent.worldTransform.translation).lengthSquared();
			}
			meshRendererComponent._renderDistance = distance;

			var bucket = buckets[renderQueue];
			if (!bucket) {
				bucket = [];
				buckets[renderQueue] = bucket;
				bucketSortList.push(renderQueue);
			}
			bucket.push(renderable);
		}

		if (bucketSortList.length > 1) {
			bucketSortList.sort(this.bucketSorter);
		}
		for (var bucketIndex = 0, l = bucketSortList.length; bucketIndex < l; bucketIndex++) {
			var key = bucketSortList[bucketIndex];
			var bucket = buckets[key];
			var bl = bucket.length;
			if (bl > 1 && key >= 0) {
				if (key < RenderQueue.TRANSPARENT) {
					bucket.sort(this.opaqueSorter);
				} else {
					bucket.sort(this.transparentSorter);
				}
			}
			for (var i = 0; i < bl; i++) {
				renderList[index] = bucket[i];
				index++;
			}
		}
	};

	/** Rendered before any other objects. Commonly used for skyboxes and the likes
	 * @type {number}
	 * @readonly
	 * @default
	 */
	RenderQueue.BACKGROUND = 0;
	/** Used for most objects, typically opaque geometry. Rendered front to back
	 * @type {number}
	 * @readonly
	 * @default
	 */
	RenderQueue.OPAQUE = 1000;
	/** For all alpha-blended objects. Rendered back to front
	 * @type {number}
	 * @readonly
	 * @default
	 */
	RenderQueue.TRANSPARENT = 2000;
	/** For overlay effects like lens-flares etc
	 * @type {number}
	 * @readonly
	 * @default
	 */
	RenderQueue.OVERLAY = 3000;

	return RenderQueue;
})(goo.Vector3);
goo.Shader = (function (
	ShaderCall,
	Matrix3,
	Matrix4,
	World,
	RenderQueue,
	ObjectUtils,
	SystemBus
) {
	'use strict';

	/* global WebGLRenderingContext */

	/**
	 * Defines vertex and fragment shader and uniforms to shader callbacks
	 * @param {string} name Shader name (mostly for debug/tool use)
	 * @param {ShaderDefinition} shaderDefinition Shader data
	 *
	 * <code>
	 * {
	 *    vshader: [required] vertex shader source
	 *    fshader: [required] fragment shader source
	 *    defines : shader definitions (becomes #define)
	 *    attributes : attribute bindings
	 *       attribute bindings need to map to an attribute in the meshdata being rendered
	 *    uniforms : uniform bindings
	 *       uniform bindings can be a value (like 2.5 or [1, 2]) or a function
	 * }
	 * </code>
	 */
	function Shader(name, shaderDefinition) {
		if (!shaderDefinition.vshader || !shaderDefinition.fshader) {
			throw new Error('Missing shader sources for shader: ' + name);
		}

		this.originalShaderDefinition = shaderDefinition;
		this.shaderDefinition = shaderDefinition;

		this.origVertexSource = shaderDefinition.vshader;
		this.origFragmentSource = shaderDefinition.fshader;

		/** The shader name
		 * @type {string}
		 */
		this.name = name;

		this.shaderProgram = null;
		this.vertexShader = null;
		this.fragmentShader = null;

		/**
		 * The renderer where the program and shaders were allocated.
		 * @type {WebGLRenderingContext}
		 */
		this.renderer = null;

		/**
		 * Attributes detected in the shader source code.
		 * Maps attribute variable's name to <code>{format: string}</code>
		 * @type {Object<string, object>}}
		 */
		this.attributeMapping = {};

		/**
		 * Maps attribute variable's name to attribute location (from getAttribLocation).
		 * @type {Object<string, number>}
		 */
		this.attributeIndexMapping = {};

		/**
		 * Uniforms detected in the shader source code.
		 * Maps variable name to <code>{format: string}</code>.
		 * @type {Object<string, object>}
		 */
		this.uniformMapping = {};

		/**
		 * Maps uniform variable name to ShaderCall object.
		 * @type {Object<string, ShaderCall>}
		 */
		this.uniformCallMapping = {};

		/**
		 * Texture slots detected in the shader source code.
		 * Will be an array of <code>{format: string, name: string}</code>
		 * @type {Array}
		 */
		this.textureSlots = [];
		this.textureSlotsNaming = {};
		this.textureIndex = 0;

		this.currentCallbacks = {};

		this.overridePrecision = shaderDefinition.precision || null;
		this.processors = shaderDefinition.processors;
		this.builder = shaderDefinition.builder;
		this.defines = shaderDefinition.defines || {};
		this.attributes = shaderDefinition.attributes || {};
		this.uniforms = shaderDefinition.uniforms || {};
		this.defineKey = shaderDefinition.defineKey || '';
		this.defineKeyDirty = true;
		this.frameStart = true;
		this.attributeKeys = null;
		this.matchedUniforms = [];

		/** Determines the order in which an object is drawn. There are four pre-defined render queues:
		 *		<ul>
		 *			<li>RenderQueue.BACKGROUND = Rendered before any other objects. Commonly used for skyboxes and the likes (0-999)
		 *			<li>RenderQueue.OPAQUE = Used for most objects, typically opaque geometry. Rendered front to back (1000-1999)
		 *			<li>RenderQueue.TRANSPARENT = For all alpha-blended objects. Rendered back to front (2000-2999)
		 *			<li>RenderQueue.OVERLAY = For overlay effects like lens-flares etc (3000+)
		 *		</ul>
		 * By default materials use the render queue of the shader. See {@link RenderQueue} for more info
		 * @type {number}
		 */
		this.renderQueue = RenderQueue.OPAQUE;

		// this._id = Shader.id++;
		if (Shader.cache.has(shaderDefinition)) {
			this._id = Shader.cache.get(shaderDefinition);
		} else {
			this._id = Shader.cache.size;
			Shader.cache.set(shaderDefinition, this._id);
		}
		// console.log('creating shader', this._id, shaderDefinition);

		this.errorOnce = false;

		this.vertexSource = typeof this.origVertexSource === 'function' ? this.origVertexSource() : this.origVertexSource;
		this.fragmentSource = typeof this.origFragmentSource === 'function' ? this.origFragmentSource() : this.origFragmentSource;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	// Shader.id = 0;
	Shader.cache = new Map();

	Shader.prototype.clone = function () {
		return new Shader(this.name, ObjectUtils.deepClone({
			precision: this.precision,
			processors: this.processors,
			builder: this.builder,
			defines: this.defines,
			attributes: this.attributes,
			uniforms: this.uniforms,
			vshader: this.origVertexSource,
			fshader: this.origFragmentSource,
			defineKey: this.defineKey
		}));
	};

	Shader.prototype.cloneOriginal = function () {
		return new Shader(this.name, this.originalShaderDefinition);
	};

	/**
	 * Compiles a shader and does not apply it
	 * @private
	 * @param renderer
	 */
	Shader.prototype.precompile = function (renderer) {
		if (this.shaderProgram === null) {
			this._investigateShaders();
			this.addDefines(this.defines);
			this.addPrecision(this.overridePrecision || renderer.shaderPrecision);
			this.compile(renderer);
		}
	};

	/*
	 * Matches an attribute or uniform variable declaration.
	 *
	 * Match groups:
	 *
	 *   1: type (attribute|uniform)
	 *   2: format (float|int|bool|vec2|vec3|vec4|mat2|mat3|mat4|sampler2D|sampler3D|samplerCube)
	 *   3: variable name
	 *   4: if exists, the variable is an array
	 */
	var regExp = /\b(attribute|uniform)\s+(float|int|bool|vec2|vec3|vec4|mat2|mat3|mat4|sampler2D|sampler3D|samplerCube)\s+(\w+)(\s*\[\s*\w+\s*\])*;/g;

	Shader.prototype.compileProgram = function (renderer) {
		if (this.shaderProgram === null) {
			this._investigateShaders();
			this.addDefines(this.defines);
			this.addPrecision(this.overridePrecision || renderer.shaderPrecision);
			this.compile(renderer);
		}
	};

	Shader.prototype.activateProgram = function (record, context) {
		if (record.usedProgram !== this.shaderProgram) {
			context.useProgram(this.shaderProgram);
			record.usedProgram = this.shaderProgram;
			return true;
		}
	};

	Shader.prototype.bindAttributeKey = function (record, renderer, attributeMap, key) {
		var attribute = attributeMap[this.attributes[key]];
		if (!attribute) {
			return;
		}

		var attributeIndex = this.attributeIndexMapping[key];
		if (attributeIndex === undefined) {
			// console.warn('Attribute binding [' + name + '] does not exist in the shader.');
			return;
		}

		record.newlyEnabledAttributes[attributeIndex] = true;
		renderer.bindVertexAttribute(attributeIndex, attribute);
	};

	Shader.prototype.bindAttributes = function (record, renderer, attributeMap) {
		if (this.attributes) {
			for (var i = 0, l = this.attributeKeys.length; i < l; i++) {
				this.bindAttributeKey(record, renderer, attributeMap, this.attributeKeys[i]);
			}
		}
	};

	Shader.prototype.disableAttributes = function (record, context) {
		for (var i = 0, l = record.enabledAttributes.length; i < l; i++) {
			var enabled = record.enabledAttributes[i];
			var newEnabled = record.newlyEnabledAttributes[i];
			if (!newEnabled && enabled) {
				context.disableVertexAttribArray(i);
				record.enabledAttributes[i] = false;
			}
		}
	};

	Shader.prototype.enableAttributes = function (record, context) {
		for (var i = 0, l = record.newlyEnabledAttributes.length; i < l; i++) {
			var enabled = record.enabledAttributes[i];
			var newEnabled = record.newlyEnabledAttributes[i];
			if (newEnabled && !enabled) {
				context.enableVertexAttribArray(i);
				record.enabledAttributes[i] = true;
			}
		}
	};

	Shader.prototype.matchUniforms = function (shaderInfo) {
		var uniforms = this.matchedUniforms;
		if (uniforms) {
			this.textureIndex = 0;

			for (var i = 0, l = uniforms.length; i < l; i++) {
				this._bindUniform(uniforms[i], shaderInfo);
			}
		}
	};

	Shader.prototype.apply = function (shaderInfo, renderer) {
		var context = renderer.context;
		var record = renderer.rendererRecord;

		this.compileProgram(renderer);
		// Set the ShaderProgram active
		this.activateProgram(record, context);

		record.newlyEnabledAttributes.length = 0;

		// Bind attributes
		this.bindAttributes(record, renderer, shaderInfo.meshData.attributeMap);

		this.disableAttributes(record, context);
		this.enableAttributes(record, context);
		this.matchUniforms(shaderInfo);
	};

	Shader.prototype.defineValue = function (shaderInfo, name) {
		var defValue = shaderInfo.material.uniforms[name];
		if (defValue === undefined) {
			defValue = this.uniforms[name];
		}
		return defValue;
	};


	Shader.prototype.mapSlot = function (shaderInfo, mapping, slot) {
		var maps = shaderInfo.material.getTexture(slot.mapping);
		if (maps instanceof Array) {
			this.arrayType(mapping, slot, maps);
		} else {
			slot.index = this.textureIndex;
			mapping.call(this.textureIndex++);
		}
	};

	Shader.prototype.arrayType = function (mapping, slot, maps) {
		var arr = [];
		slot.index = [];
		for (var i = 0; i < maps.length; i++) {
			slot.index.push(this.textureIndex);
			arr.push(this.textureIndex++);
		}
		mapping.call(arr);
	};

	Shader.prototype.stringType = function (shaderInfo, name, mapping) {
		var callback = this.currentCallbacks[name];
		if (callback) {
			callback(mapping, shaderInfo);
		} else {
			var slot = this.textureSlotsNaming[name];
			if (slot !== undefined) {
				this.mapSlot(shaderInfo, mapping, slot);
			}
		}
	};

	Shader.prototype.callMapping = function (shaderInfo, name, mapping) {
		var defValue = this.defineValue(shaderInfo, name);
		var type = typeof defValue;
		if (type === 'string') {
			this.stringType(shaderInfo, name, mapping, defValue);
		} else {
			var value = type === 'function' ? defValue(shaderInfo) : defValue;
			mapping.call(value);
		}
	};

	Shader.prototype._bindUniform = function (name, shaderInfo) {
		var mapping = this.uniformCallMapping[name];
		if (mapping === undefined) {
			return;
		}
		this.callMapping(shaderInfo, name, mapping);
	};

	Shader.prototype.setDefine = function (key, value) {
		this.defineKeyDirty = this.defineKeyDirty || this.defines[key] !== value;
		this.defines[key] = value;
	};

	Shader.prototype.removeDefine = function (key) {
		this.defineKeyDirty = this.defineKeyDirty || this.defines[key] !== undefined;
		this.defines[key] = undefined;
	};

	Shader.prototype.hasDefine = function (key) {
		return this.defines[key] !== false && this.defines[key] !== undefined;
	};

	Shader.prototype.startFrame = function () {
		this.frameStart = true;
	};

	Shader.prototype.endFrame = function () {
		this.frameStart = false;
	};

	Shader.prototype.updateProcessors = function (renderInfo) {
		if (this.processors) {
			for (var j = 0; j < this.processors.length; j++) {
				this.processors[j](this, renderInfo);
			}
		}
	};

	Shader.prototype.getDefineKey = function (definesIndices) {
		if (this.defineKeyDirty) {
			var key = 'Key:' + this.name;
			var defineArray = Object.keys(this.defines);
			for (var i = 0; i < defineArray.length; i++) {
				var defineArrayKey = defineArray[i];
				var defineVal = this.defines[defineArrayKey];
				if (defineVal === undefined || defineVal === false) {
					continue;
				}
				if (definesIndices.indexOf(defineArrayKey) === -1) {
					definesIndices.push(defineArrayKey);
				}
			}
			for (var i = 0, l = definesIndices.length; i < l; i++) {
				var defineArrayKey = definesIndices[i];
				var defineVal = this.defines[defineArrayKey];
				if (defineVal === undefined || defineVal === false) {
					continue;
				}
				key += '_' + i + ':' + defineVal;
			}
			this.defineKey = key;
			this.defineKeyDirty = false;
		}

		return this.defineKey;
	};


	Shader.prototype.rebuild = function () {
		this.shaderProgram = null;
		this.attributeMapping = {};
		this.attributeIndexMapping = {};
		this.uniformMapping = {};
		this.uniformCallMapping = {};
		this.currentCallbacks = {};
		this.attributeKeys = null;
		this.vertexSource = typeof this.origVertexSource === 'function' ? this.origVertexSource() : this.origVertexSource;
		this.fragmentSource = typeof this.origFragmentSource === 'function' ? this.origFragmentSource() : this.origFragmentSource;
		this.defineKeyDirty = true;
	};

	Shader.prototype._investigateShaders = function () {
		this.textureSlots = [];
		this.textureSlotsNaming = {};
		Shader.investigateShader(this.vertexSource, this);
		Shader.investigateShader(this.fragmentSource, this);
	};

	/**
	 * Extract shader variable definitions from shader source code.
	 * @param {string} source The source code.
	 * @param {Object} target
	 * @param {Object} target.attributeMapping
	 * @param {Object} target.uniformMapping
	 * @param {Array} target.textureSlots
	 */
	Shader.investigateShader = function (source, target) {
		regExp.lastIndex = 0;
		var matcher = regExp.exec(source);

		while (matcher !== null) {
			var definition = {
				// data type: float, int, ...
				format: matcher[2]
			};
			var type = matcher[1];  // "attribute" or "uniform"
			var variableName = matcher[3];
			var arrayDeclaration = matcher[4];
			if (arrayDeclaration) {
				if (definition.format === 'float') {
					definition.format = 'floatarray';
				} else if (definition.format === 'int') {
					definition.format = 'intarray';
				} else if (definition.format.indexOf('sampler') === 0) {
					definition.format = 'samplerArray';
				}
			}

			if (type === 'attribute') {
				target.attributeMapping[variableName] = definition;
			} else {
				if (definition.format.indexOf('sampler') === 0) {
					var textureSlot = {
						format: definition.format,
						name: variableName,
						mapping: target.uniforms[variableName],
						index: target.textureSlots.length
					};
					target.textureSlots.push(textureSlot);
					target.textureSlotsNaming[textureSlot.name] = textureSlot;
				}
				target.uniformMapping[variableName] = definition;
			}

			matcher = regExp.exec(source);
		}
	};

	Shader.prototype.compile = function (renderer) {
		var context = renderer.context;
		this.renderer = renderer;
		this.vertexShader = this._getShader(context, context.VERTEX_SHADER !== undefined ? context.VERTEX_SHADER : WebGLRenderingContext.VERTEX_SHADER, this.vertexSource);
		this.fragmentShader = this._getShader(context, context.FRAGMENT_SHADER !== undefined ? context.FRAGMENT_SHADER : WebGLRenderingContext.FRAGMENT_SHADER, this.fragmentSource);

		if (this.vertexShader === null || this.fragmentShader === null) {
			console.error('Shader error - no shaders');
		}

		this.shaderProgram = context.createProgram();

		var error = context.getError();
		if (this.shaderProgram === null || error !== 0) {
			console.error('Shader error: ' + error + ' [shader: ' + this.name + ']');
			SystemBus.emit('goo.shader.error');
		}

		context.attachShader(this.shaderProgram, this.vertexShader);
		context.attachShader(this.shaderProgram, this.fragmentShader);

		// Link the Shader Program
		context.linkProgram(this.shaderProgram);
		if (!context.getProgramParameter(this.shaderProgram, (context.LINK_STATUS !== undefined ? context.LINK_STATUS : WebGLRenderingContext.LINK_STATUS))) {
			var errInfo = context.getProgramInfoLog(this.shaderProgram);
			console.error('Could not initialise shaders: ' + errInfo);
			SystemBus.emit('goo.shader.error', errInfo);
		}

		for (var key in this.attributeMapping) {
			var attributeIndex = context.getAttribLocation(this.shaderProgram, key);
			if (attributeIndex === -1) {
				// more corpses!
				// if (this.attributes[key]) {
					// delete this.attributes[key];
				// }
				// console.warn('Attribute [' + this.attributeMapping[key].format + ' ' + key + '] variable not found in shader. Probably unused and optimized away.');
				continue;
			}

			this.attributeIndexMapping[key] = attributeIndex;
		}

		for (var key in this.uniformMapping) {
			var uniform = context.getUniformLocation(this.shaderProgram, key);

			if (uniform === null) {
				// if (this.uniforms[key]) {
					// delete this.uniforms[key];
				// }

				var l = this.textureSlots.length;
				for (var i = 0; i < l; i++) {
					var slot = this.textureSlots[i];
					if (slot.name === key) {
						this.textureSlots.splice(i, 1);
						delete this.textureSlotsNaming[slot.name];
						for (; i < l - 1; i++) {
							this.textureSlots[i].index--;
						}
						break;
					}
				}
				// console.warn('Uniform [' + this.uniformMapping[key].format + ' ' + key + '] variable not found in shader. Probably unused and optimized away.');
				continue;
			}

			this.uniformCallMapping[key] = new ShaderCall(context, uniform, this.uniformMapping[key].format);
		}

		if (this.attributes) {
			// corpse!
		// 	for (var name in this.attributeIndexMapping) {
		// 		var mapping = this.attributes[name];
		// 		if (mapping === undefined) {
		// 			console.warn('No binding found for attribute: ' + name + ' [' + this.name + '][' + this._id + ']');
		// 		}
		// 	}

			this.attributeKeys = Object.keys(this.attributes);
		}

		if (this.uniforms) {
			// Fix links ($link)
			if (this.uniforms.$link) {
				var links = this.uniforms.$link instanceof Array ? this.uniforms.$link : [this.uniforms.$link];
				for (var i = 0; i < links.length; i++) {
					var link = links[i];
					for (var key in link) {
						this.uniforms[key] = link[key];
					}
				}
				delete this.uniforms.$link;
			}

			this.matchedUniforms = [];
			for (var name in this.uniforms) {
				var mapping = this.uniformCallMapping[name];
				if (mapping !== undefined) {
					this.matchedUniforms.push(name);
				}
				// else {
					// console.warn('No uniform found for binding: ' + name + ' [' + this.name + '][' + this._id + ']');
				// }

				var value = this.uniforms[name];
				if (this.defaultCallbacks[value]) {
					this.currentCallbacks[name] = this.defaultCallbacks[value];
				}
			}

			// for (var name in this.uniformCallMapping) {
			// 	var mapping = this.uniforms[name];
			// 	if (mapping === undefined) {
			// 		console.warn('No binding found for uniform: ' + name + ' [' + this.name + '][' + this._id + ']');
			// 	}
			// }
		}
	};

	var errorRegExp = /\b\d+:(\d+):\s(.+)\b/g;
	var errorRegExpIE = /\((\d+),\s*\d+\):\s(.+)/g;

	Shader.prototype._getShader = function (context, type, source) {
		var shader = context.createShader(type);

		context.shaderSource(shader, source);
		context.compileShader(shader);

		// check if the Shader is successfully compiled
		if (!context.getShaderParameter(shader, context.COMPILE_STATUS !== undefined ? context.COMPILE_STATUS : WebGLRenderingContext.COMPILE_STATUS)) {
			var infoLog = context.getShaderInfoLog(shader);
			var shaderType = type === (context.VERTEX_SHADER !== undefined ? context.VERTEX_SHADER : WebGLRenderingContext.VERTEX_SHADER) ? 'VertexShader' : 'FragmentShader';

			errorRegExp.lastIndex = 0;
			var errorMatcher = errorRegExp.exec(infoLog);
			if (errorMatcher === null) {
				errorMatcher = errorRegExpIE.exec(infoLog);
			}
			if (errorMatcher !== null) {
				while (errorMatcher !== null) {
					var splitSource = source.split('\n');
					var lineNum = errorMatcher[1];
					var errorStr = errorMatcher[2];
					console.error('Error in ' + shaderType + ' - [' + this.name + '][' + this._id + '] at line ' + lineNum + ':');
					console.error('\tError: ' + errorStr);
					console.error('\tSource: ' + splitSource[lineNum - 1]);
					errorMatcher = errorRegExp.exec(infoLog);
				}
			} else {
				console.error('Error in ' + shaderType + ' - [' + this.name + '][' + this._id + '] ' + infoLog);
			}

			return null;
		}

		return shader;
	};

	var precisionRegExp = /\bprecision\s+(lowp|mediump|highp)\s+(float|int);/g;

	Shader.prototype.addPrecision = function (precision) {
		precisionRegExp.lastIndex = 0;
		var vertMatcher = precisionRegExp.exec(this.vertexSource);
		if (vertMatcher === null) {
			this.vertexSource = 'precision ' + precision + ' float;' + '\n' + this.vertexSource;
		}
		precisionRegExp.lastIndex = 0;
		var fragMatcher = precisionRegExp.exec(this.fragmentSource);
		if (fragMatcher === null) {
			this.fragmentSource = 'precision ' + precision + ' float;' + '\n' + this.fragmentSource;
		}
	};

	Shader.prototype.addDefines = function (defines) {
		if (!defines) {
			return;
		}

		var defineStr = this.generateDefines(defines);

		this.vertexSource = defineStr + '\n' + this.vertexSource;
		this.fragmentSource = defineStr + '\n' + this.fragmentSource;
	};

	Shader.prototype.generateDefines = function (defines) {
		var chunks = [];
		for (var d in defines) {
			var value = defines[d];
			if (value === false || value === undefined) {
				continue;
			}

			var chunk = '#define ' + d + ' ' + value;
			chunks.push(chunk);
		}

		return chunks.join('\n');
	};

	function setupDefaultCallbacks(defaultCallbacks) {
		defaultCallbacks[Shader.PROJECTION_MATRIX] = function (uniformCall, shaderInfo) {
			var matrix = shaderInfo.camera.getProjectionMatrix();
			uniformCall.uniformMatrix4fv(matrix);
		};
		defaultCallbacks[Shader.VIEW_MATRIX] = function (uniformCall, shaderInfo) {
			var matrix = shaderInfo.camera.getViewMatrix();
			uniformCall.uniformMatrix4fv(matrix);
		};
		defaultCallbacks[Shader.WORLD_MATRIX] = function (uniformCall, shaderInfo) {
			//! AT: when is this condition ever true?
			var matrix = shaderInfo.transform !== undefined ? shaderInfo.transform.matrix : Matrix4.IDENTITY;
			uniformCall.uniformMatrix4fv(matrix);
		};
		defaultCallbacks[Shader.NORMAL_MATRIX] = function (uniformCall, shaderInfo) {
			//! AT: when is this condition ever true?
			var matrix = shaderInfo.transform !== undefined ? shaderInfo.transform.normalMatrix : Matrix3.IDENTITY;
			uniformCall.uniformMatrix3fv(matrix);
		};

		defaultCallbacks[Shader.VIEW_INVERSE_MATRIX] = function (uniformCall, shaderInfo) {
			var matrix = shaderInfo.camera.getViewInverseMatrix();
			uniformCall.uniformMatrix4fv(matrix);
		};
		defaultCallbacks[Shader.VIEW_PROJECTION_MATRIX] = function (uniformCall, shaderInfo) {
			var matrix = shaderInfo.camera.getViewProjectionMatrix();
			uniformCall.uniformMatrix4fv(matrix);
		};
		defaultCallbacks[Shader.VIEW_PROJECTION_INVERSE_MATRIX] = function (uniformCall, shaderInfo) {
			var matrix = shaderInfo.camera.getViewProjectionInverseMatrix();
			uniformCall.uniformMatrix4fv(matrix);
		};

		for (var i = 0; i < 16; i++) {
			/*jshint loopfunc: true */
			defaultCallbacks[Shader['TEXTURE' + i]] = (function (i) {
				return function (uniformCall) {
					uniformCall.uniform1i(i);
				};
			})(i);
		}

		for (var i = 0; i < 8; i++) {
			/*jshint loopfunc: true */
			defaultCallbacks[Shader['LIGHT' + i]] = (function (i) {
				return function (uniformCall, shaderInfo) {
					var light = shaderInfo.lights[i];
					if (light !== undefined) {
						uniformCall.uniform3f(light.translation.x, light.translation.y, light.translation.z);
					} else {
						uniformCall.uniform3f(-20, 20, 20);
					}
				};
			})(i);
		}
		defaultCallbacks[Shader.LIGHTCOUNT] = function (uniformCall, shaderInfo) {
			uniformCall.uniform1i(shaderInfo.lights.length);
		};

		defaultCallbacks[Shader.CAMERA] = function (uniformCall, shaderInfo) {
			var cameraPosition = shaderInfo.camera.translation;
			uniformCall.uniform3f(cameraPosition.x, cameraPosition.y, cameraPosition.z);
		};
		defaultCallbacks[Shader.NEAR_PLANE] = function (uniformCall, shaderInfo) {
			uniformCall.uniform1f(shaderInfo.camera.near);
		};
		defaultCallbacks[Shader.FAR_PLANE] = function (uniformCall, shaderInfo) {
			uniformCall.uniform1f(shaderInfo.camera.far);
		};
		defaultCallbacks[Shader.MAIN_NEAR_PLANE] = function (uniformCall, shaderInfo) {
			uniformCall.uniform1f(shaderInfo.mainCamera.near);
		};
		defaultCallbacks[Shader.MAIN_FAR_PLANE] = function (uniformCall, shaderInfo) {
			uniformCall.uniform1f(shaderInfo.mainCamera.far);
		};
		defaultCallbacks[Shader.MAIN_DEPTH_SCALE] = function (uniformCall, shaderInfo) {
			uniformCall.uniform1f(1.0 / (shaderInfo.mainCamera.far - shaderInfo.mainCamera.near));
		};


		defaultCallbacks[Shader.AMBIENT] = function (uniformCall, shaderInfo) {
			var materialState = shaderInfo.material.materialState !== undefined ? shaderInfo.material.materialState.ambient : Shader.DEFAULT_AMBIENT;
			uniformCall.uniform4fv(materialState);
		};
		defaultCallbacks[Shader.EMISSIVE] = function (uniformCall, shaderInfo) {
			var materialState = shaderInfo.material.materialState !== undefined ? shaderInfo.material.materialState.emissive : Shader.DEFAULT_EMISSIVE;
			uniformCall.uniform4fv(materialState);
		};
		defaultCallbacks[Shader.DIFFUSE] = function (uniformCall, shaderInfo) {
			var materialState = shaderInfo.material.materialState !== undefined ? shaderInfo.material.materialState.diffuse : Shader.DEFAULT_DIFFUSE;
			uniformCall.uniform4fv(materialState);
		};
		defaultCallbacks[Shader.SPECULAR] = function (uniformCall, shaderInfo) {
			var materialState = Shader.DEFAULT_SPECULAR;
			if (shaderInfo.material.materialState !== undefined) {
				materialState = shaderInfo.material.materialState.specular;
				materialState[3] = Math.max(shaderInfo.material.materialState.shininess, 1);
			}
			uniformCall.uniform4fv(materialState);
		};
		defaultCallbacks[Shader.SPECULAR_POWER] = function (uniformCall, shaderInfo) {
			var shininess = shaderInfo.material.materialState !== undefined ? shaderInfo.material.materialState.shininess : Shader.DEFAULT_SHININESS;
			shininess = Math.max(shininess, 1.0);
			uniformCall.uniform1f(shininess);
		};

		defaultCallbacks[Shader.TIME] = function (uniformCall) {
			uniformCall.uniform1f(World.time);
		};
		defaultCallbacks[Shader.TPF] = function (uniformCall) {
			uniformCall.uniform1f(World.tpf);
		};

		defaultCallbacks[Shader.RESOLUTION] = function (uniformCall, shaderInfo) {
			uniformCall.uniform2f(shaderInfo.renderer.viewportWidth, shaderInfo.renderer.viewportHeight);
		};
	}

	Shader.prototype.getShaderDefinition = function () {
		return {
			vshader: this.vertexSource,
			fshader: this.fragmentSource,
			defines: this.defines,
			attributes: this.attributes,
			uniforms: this.uniforms
		};
	};

	Shader.prototype.destroy = function () {
		if (this.shaderProgram) {
			this.renderer.context.deleteProgram(this.shaderProgram);
			this.shaderProgram = null;
		}
		if (this.vertexShader) {
			this.renderer.context.deleteShader(this.vertexShader);
			this.vertexShader = null;
		}
		if (this.fragmentShader) {
			this.renderer.context.deleteShader(this.fragmentShader);
			this.fragmentShader = null;
		}
		this.renderer = null;
	};

	Shader.prototype.toString = function () {
		return this.name;
	};

	Shader.PROJECTION_MATRIX = 'PROJECTION_MATRIX';
	Shader.VIEW_MATRIX = 'VIEW_MATRIX';
	Shader.VIEW_INVERSE_MATRIX = 'VIEW_INVERSE_MATRIX';
	Shader.VIEW_PROJECTION_MATRIX = 'VIEW_PROJECTION_MATRIX';
	Shader.VIEW_PROJECTION_INVERSE_MATRIX = 'VIEW_PROJECTION_INVERSE_MATRIX';
	Shader.WORLD_MATRIX = 'WORLD_MATRIX';
	Shader.NORMAL_MATRIX = 'NORMAL_MATRIX';
	for (var i = 0; i < 8; i++) {
		Shader['LIGHT' + i] = 'LIGHT' + i;
	}
	Shader.CAMERA = 'CAMERA';
	Shader.AMBIENT = 'AMBIENT';
	Shader.EMISSIVE = 'EMISSIVE';
	Shader.DIFFUSE = 'DIFFUSE';
	Shader.SPECULAR = 'SPECULAR';
	Shader.SPECULAR_POWER = 'SPECULAR_POWER';
	Shader.NEAR_PLANE = 'NEAR_PLANE';
	Shader.FAR_PLANE = 'FAR_PLANE';
	Shader.MAIN_NEAR_PLANE = 'NEAR_PLANE';
	Shader.MAIN_FAR_PLANE = 'FAR_PLANE';
	Shader.MAIN_DEPTH_SCALE = 'DEPTH_SCALE';
	Shader.TIME = 'TIME';
	Shader.TPF = 'TPF';
	Shader.RESOLUTION = 'RESOLUTION';

	Shader.DIFFUSE_MAP = 'DIFFUSE_MAP';
	Shader.NORMAL_MAP = 'NORMAL_MAP';
	Shader.SPECULAR_MAP = 'SPECULAR_MAP';
	Shader.LIGHT_MAP = 'LIGHT_MAP';
	Shader.SHADOW_MAP = 'SHADOW_MAP';
	Shader.AO_MAP = 'AO_MAP';
	Shader.EMISSIVE_MAP = 'EMISSIVE_MAP';
	Shader.DEPTH_MAP = 'DEPTH_MAP';

	Shader.DEFAULT_AMBIENT = [0.1, 0.1, 0.1, 1.0];
	Shader.DEFAULT_EMISSIVE = [0, 0, 0, 0];
	Shader.DEFAULT_DIFFUSE = [0.8, 0.8, 0.8, 1.0];
	Shader.DEFAULT_SPECULAR = [0.6, 0.6, 0.6, 64.0];
	Shader.DEFAULT_SHININESS = 64.0;

	Shader.prototype.defaultCallbacks = {};
	setupDefaultCallbacks(Shader.prototype.defaultCallbacks);

	return Shader;
})(goo.ShaderCall,goo.Matrix3,goo.Matrix4,goo.World,goo.RenderQueue,goo.ObjectUtils,goo.SystemBus);
goo.Material = (function (
	Shader,
	_
) {
	'use strict';

	/**
	 * A Material defines the look of an object
	 * @param {string} [name='Default Material'] Material name
	 * @param {{ vshader, fshader }} [shaderDefinition] Optional shader to associate with the material
	 */
	function Material(name, shaderDefinition) {
		this.id = null;

		/** Material name
		 * @type {string}
		 */
		this.name = 'Default Material';

		/** [Shader]{@link Shader} to use when rendering
		 * @type {Shader}
		 */
		this.shader = null;

		//! AT: horrendous type checking follows
		// function has 2 signatures because the deprecated .createMaterial had parameters in inverse order
		if (typeof arguments[0] === 'string') {
			this.name = arguments[0];
		} else if (arguments[0] && arguments[0].vshader && arguments[0].fshader) {
			this.shader = Material.createShader(arguments[0]);
		}

		if (arguments[1] && arguments[1].vshader && arguments[1].fshader) {
			this.shader = Material.createShader(arguments[1]);
		} else if (typeof arguments[1] === 'string') {
			this.name = arguments[1];
		}

		/** Possible overrides for shader uniforms
		 * @type {Object}
		 * @default
		 */
		this.uniforms = {};

		// Texture storage
		this._textureMaps = {};
		/* REVIEW
		 * There was an idea to specify and jsdoc uniforms.materialDiffuse etc instead,
		 * since those are the ones we use now
		 */

		/* Specification of colors for this Material
		 * @type {Object}
		 * @property {Array<number>} ambient The ambient color, [r, g, b, a]
		 * @property {Array<number>} diffuse The diffuse color, [r, g, b, a]
		 * @property {Array<number>} emissive The emissive color, [r, g, b, a]
		 * @property {Array<number>} specular The specular color, [r, g, b, a]
		 * @property {number} shininess The shininess exponent.
		 */
		/*
		this.materialState = {
			ambient: Shader.DEFAULT_AMBIENT,
			diffuse: Shader.DEFAULT_DIFFUSE,
			emissive: Shader.DEFAULT_EMISSIVE,
			specular: Shader.DEFAULT_SPECULAR,
			shininess: Shader.DEFAULT_SHININESS
		};
		*/

		/** Specification of culling for this Material
		 * @type {Object}
		 * @property {boolean} enabled
		 * @property {string} cullFace possible values: 'Front', 'Back', 'FrontAndBack', default 'Back'
		 * @property {string} frontFace possible values: 'CW' (clockwise) and 'CCW' (counterclockwise - default)
		 */
		this.cullState = {
			enabled: true,
			cullFace: 'Back', // Front, Back, FrontAndBack
			frontFace: 'CCW' // CW, CCW
		};

		/** Specification of blending for this Material
		 * @type {Object}
		 * @property {string} blending possible values: <strong>'NoBlending'</strong>, 'TransparencyBlending', 'AdditiveBlending', 'SubtractiveBlending', 'MultiplyBlending', 'CustomBlending'
		 * @property {string} blendEquation possible values: <strong>'AddEquation'</strong>, 'SubtractEquation', 'ReverseSubtractEquation'
		 * @property {string} blendSrc possible values: <strong>'SrcAlphaFactor'</strong>, 'ZeroFactor', 'OneFactor', 'SrcColorFactor', 'OneMinusSrcColorFactor', 'OneMinusSrcAlphaFactor', 'OneMinusDstAlphaFactor''DstColorFactor', 'OneMinusDstColorFactor', 'SrcAlphaSaturateFactor', 'DstAlphaFactor'
		 * @property {string} blendDst possible values: 'SrcAlphaFactor', 'ZeroFactor', 'OneFactor', 'SrcColorFactor', 'OneMinusSrcColorFactor', <strong>'OneMinusSrcAlphaFactor'</strong>, 'OneMinusDstAlphaFactor''DstColorFactor', 'OneMinusDstColorFactor', 'DstAlphaFactor'
		 */
		this.blendState = {
			blending: 'NoBlending',
			blendEquation: 'AddEquation',
			blendSrc: 'SrcAlphaFactor',
			blendDst: 'OneMinusSrcAlphaFactor'
		};

		/** Specification of depth handling for this Material
		 * @type {Object}
		 * @property {boolean} enabled default: true
		 * @property {boolean} write default: true
		 */
		this.depthState = {
			enabled: true,
			write: true
		};

		/** Specification of the polygon offset for this Material
		 * @type {Object}
		 * @property {boolean} enabled
		 * @property {number} factor default: 1
		 * @property {number} units default: 1
		 */
		this.offsetState = {
			enabled: false,
			factor: 1,
			units: 1
		};

		/** Render the mesh twice with front/back-facing for double transparency rendering
		 * @type {boolean}
		 * @default
		 */
		this.dualTransparency = false;

		/** Show wireframe on this material
		 * @type {boolean}
		 * @default
		 */
		this.wireframe = false;
		this.flat = false;

		this.lineWidth = 1;

		/** Determines the order in which an object is drawn. There are four pre-defined render queues:
		 *		<ul>
		 *			<li>RenderQueue.BACKGROUND = Rendered before any other objects. Commonly used for skyboxes and the likes (0-999)
		 *			<li>RenderQueue.OPAQUE = Used for most objects, typically opaque geometry. Rendered front to back (1000-1999)
		 *			<li>RenderQueue.TRANSPARENT = For all alpha-blended objects. Rendered back to front (2000-2999)
		 *			<li>RenderQueue.OVERLAY = For overlay effects like lens-flares etc (3000+)
		 *		</ul>
		 * By default materials use the render queue of the shader. See {@link Shader} or {@link RenderQueue} for more info
		 * @type {number}
		 */
		this.renderQueue = null;

		this.fullOverride = false;
		this.errorOnce = false;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	/**
	 * Sets a texture in a specific slot
	 *
	 * @param {string} name Name of texture slot
	 * @param {Texture} texture Texture to set
	 */
	Material.prototype.setTexture = function (name, texture) {
		this._textureMaps[name] = texture;
	};

	/**
	 * Gets a texture in a specific slot
	 *
	 * @param {string} name Name of texture slot to retrieve texture from
	 * @returns {Texture} Texture if found, or undefined if not in slot
	 */
	Material.prototype.getTexture = function (name) {
		return this._textureMaps[name];
	};

	/**
	 * Removes a texture in a specific slot
	 *
	 * @param {string} name Name of texture slot to remove
	 */
	Material.prototype.removeTexture = function (name) {
		delete this._textureMaps[name];
	};

	/**
	 * Get all textures as an array
	 *
	 * @returns {Array<Texture>} Array containing all set textures
	 */
	Material.prototype.getTextures = function () {
		var textures = [];
		for (var key in this._textureMaps) {
			textures.push(this._textureMaps[key]);
		}
		return textures;
	};

	/**
	 * Get the map of [slot_name]: [Texture]
	 *
	 * @returns {Object} Mapping of slot - textures
	 */
	Material.prototype.getTextureEntries = function () {
		return this._textureMaps;
	};

	/**
	 * Returns the render queue of this material
	 * @returns {number}
	 */
	Material.prototype.getRenderQueue = function () {
		if (this.renderQueue !== null) {
			return this.renderQueue;
		} else if (this.shader !== null) {
			return this.shader.renderQueue;
		}
		return 1000;
	};

	/**
	 * Sets the render queue of this material
	 * @param {number} queue See {@link RenderQueue} for options
	 */
	Material.prototype.setRenderQueue = function (queue) {
		this.renderQueue = queue;
	};

	/**
	 * Returns a clone of this material
	 * @param {Object} [options]
	 * @param {boolean} [options.shareUniforms=false] Cloning this material clones the uniforms by default
	 * @param {boolean} [options.shareTextures=false] Cloning this material clones the textures by default
	 * @returns {Material}
	 */
	Material.prototype.clone = function (options) {
		options = options || {};

		var clone = new Material(this.name);

		clone.id = this.id;
		clone.name = this.name;
		clone.shader = this.shader.clone();

		if (options.shareUniforms) {
			clone.uniforms = this.uniforms;
		} else {
			clone.uniforms = _.deepClone(this.uniforms);
		}

		if (options.shareTextures) {
			var textureKeys = Object.keys(this._textureMaps);
			for (var i = 0; i < textureKeys.length; i++) {
				var textureKey = textureKeys[i];
				clone._textureMaps[textureKey] = this._textureMaps[textureKey];
			}
		} else {
			var textureKeys = Object.keys(this._textureMaps);
			for (var i = 0; i < textureKeys.length; i++) {
				var textureKey = textureKeys[i];
				clone._textureMaps[textureKey] = this._textureMaps[textureKey].clone();
			}
		}

		clone.cullState.enabled = this.cullState.enabled;
		clone.cullState.cullFace = this.cullState.cullFace;
		clone.cullState.frontFace = this.cullState.frontFace;

		clone.blendState.blending = this.blendState.blending;
		clone.blendState.blendEquation = this.blendState.blendEquation;
		clone.blendState.blendSrc = this.blendState.blendSrc;
		clone.blendState.blendDst = this.blendState.blendDst;

		clone.depthState.enabled = this.depthState.enabled;
		clone.depthState.write = this.depthState.write;

		clone.offsetState.enabled = this.offsetState.enabled;
		clone.offsetState.factor = this.offsetState.factor;
		clone.offsetState.units = this.offsetState.units;

		clone.dualTransparency = this.dualTransparency;

		clone.wireframe = this.wireframe;
		clone.flat = this.flat;

		clone.renderQueue = this.renderQueue;

		clone.fullOverride = this.fullOverride;
		clone.errorOnce = this.errorOnce;

		return clone;
	};

	/**
	 * Creates a new or finds an existing, cached Shader object
	 *
	 * @param {ShaderDefinition} shaderDefinition see {@link Shader}
	 * @param {string} [name=DefaultShader]
	 * @returns {Shader}
	 */
	Material.createShader = function (shaderDefinition, name) {
		//! AT: function has parameters in reverse order than the constructor
		var shader = new Shader(name || null, shaderDefinition);
		if (shader.name === null) {
			shader.name = 'DefaultShader' + shader._id;
		}
		return shader;
	};

	/**
	 * Clears the shader cache.
	 * @deprecated Deprecated since 0.12.0 and scheduled for removal in 0.14.0
	 */
	Material.clearShaderCache = function () {
	};

	/**
	 * Creates an 'empty' material
	 * @private
	 * @param shaderDefinition see {@link Shader}
	 * @param name [name='Empty Material'] The name of the newly created material
	 * @returns {Material}
	 */
	Material.createEmptyMaterial = function (shaderDefinition, name) {
		var material = new Material(name || 'Empty Material');
		material.empty();
		if (shaderDefinition) {
			material.shader = Material.createShader(shaderDefinition);
		} else {
			material.shader = undefined;
		}
		return material;
	};

	//! AT: how about a immutable material named EMPTY and a clone method for materials instead of this mutable madness?
	/**
	 * Removed the material's properties
	 * @private
	 */
	Material.prototype.empty = function () {
		this.cullState = {};
		this.blendState = {};
		this.depthState = {};
		this.offsetState = {};
		this.wireframe = undefined;
		this.renderQueue = undefined;
		this.flat = undefined;
		this._textureMaps = {};
		this.shader = undefined;
		this.uniforms = {};
	};

	return Material;
})(goo.Shader,goo.ObjectUtils);
goo.ShaderFragment = (function () {
	'use strict';

	/**
	 * Collection of useful shader fragments
	 */
	function ShaderFragment() {
	}

	ShaderFragment.noisecommon = [
		'vec4 mod289(vec4 x) {',
			'return x - floor(x * (1.0 / 289.0)) * 289.0;',
		'}',

		'vec3 mod289(vec3 x) {',
			'return x - floor(x * (1.0 / 289.0)) * 289.0;',
		'}',

		'vec2 mod289(vec2 x) {',
			'return x - floor(x * (1.0 / 289.0)) * 289.0;',
		'}',

		'vec3 permute(vec3 x) {',
			'return mod289(((x*34.0)+1.0)*x);',
		'}',

		'vec4 permute(vec4 x) {',
			'return mod289(((x*34.0)+1.0)*x);',
		'}'
	].join('\n');

	ShaderFragment.noise2d = [
		ShaderFragment.noisecommon,
		'float snoise(vec2 v) {',
			'const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0',
				'0.366025403784439, // 0.5*(sqrt(3.0)-1.0)',
				'-0.577350269189626, // -1.0 + 2.0 * C.x',
				'0.024390243902439); // 1.0 / 41.0',
			'vec2 i  = floor(v + dot(v, C.yy) );',
			'vec2 x0 = v - i + dot(i, C.xx);',
			'vec2 i1;',
			'//i1.x = step( x0.y, x0.x ); x0.x > x0.y ? 1.0 : 0.0',
			'//i1.y = 1.0 - i1.x;',
			'i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);',
			'// x0 = x0 - 0.0 + 0.0 * C.xx ;',
			'// x1 = x0 - i1 + 1.0 * C.xx ;',
			'// x2 = x0 - 1.0 + 2.0 * C.xx ;',
			'vec4 x12 = x0.xyxy + C.xxzz;',
			'x12.xy -= i1;',
			'i = mod289(i); // Avoid truncation effects in permutation',
			'vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))',
				'+ i.x + vec3(0.0, i1.x, 1.0 ));',
			'vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);',
			'm = m*m ;',
			'm = m*m ;',
			'vec3 x = 2.0 * fract(p * C.www) - 1.0;',
			'vec3 h = abs(x) - 0.5;',
			'vec3 ox = floor(x + 0.5);',
			'vec3 a0 = x - ox;',
			'm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );',
			'vec3 g;',
			'g.x  = a0.x  * x0.x  + h.x  * x0.y;',
			'g.yz = a0.yz * x12.xz + h.yz * x12.yw;',
			'return 130.0 * dot(m, g);',
		'}'
	].join('\n');

	ShaderFragment.noise3d = [
		ShaderFragment.noisecommon,
		'vec4 taylorInvSqrt(vec4 r) {',
			'return 1.79284291400159 - 0.85373472095314 * r;',
		'}',

		'float snoise(vec3 v) {',
			'const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;',
			'const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);',
			'vec3 i  = floor(v + dot(v, C.yyy) );',
			'vec3 x0 = v - i + dot(i, C.xxx);',
			'vec3 g = step(x0.yzx, x0.xyz);',
			'vec3 l = 1.0 - g;',
			'vec3 i1 = min( g.xyz, l.zxy );',
			'vec3 i2 = max( g.xyz, l.zxy );',
			'vec3 x1 = x0 - i1 + C.xxx;',
			'vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y',
			'vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y',
			'i = mod289(i); ',
			'vec4 p = permute( permute( permute( ',
				'i.z + vec4(0.0, i1.z, i2.z, 1.0 ))',
				'+ i.y + vec4(0.0, i1.y, i2.y, 1.0 )) ',
				'+ i.x + vec4(0.0, i1.x, i2.x, 1.0 ));',
			'float n_ = 0.142857142857; // 1.0/7.0',
			'vec3 ns = n_ * D.wyz - D.xzx;',
			'vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)',
			'vec4 x_ = floor(j * ns.z);',
			'vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)',
			'vec4 x = x_ *ns.x + ns.yyyy;',
			'vec4 y = y_ *ns.x + ns.yyyy;',
			'vec4 h = 1.0 - abs(x) - abs(y);',
			'vec4 b0 = vec4( x.xy, y.xy );',
			'vec4 b1 = vec4( x.zw, y.zw );',
			'vec4 s0 = floor(b0)*2.0 + 1.0;',
			'vec4 s1 = floor(b1)*2.0 + 1.0;',
			'vec4 sh = -step(h, vec4(0.0));',
			'vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;',
			'vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;',
			'vec3 p0 = vec3(a0.xy,h.x);',
			'vec3 p1 = vec3(a0.zw,h.y);',
			'vec3 p2 = vec3(a1.xy,h.z);',
			'vec3 p3 = vec3(a1.zw,h.w);',
			'vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));',
			'p0 *= norm.x;',
			'p1 *= norm.y;',
			'p2 *= norm.z;',
			'p3 *= norm.w;',
			'vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);',
			'm = m * m;',
			'return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );',
		'}'
	].join('\n');

	var packCommon = [
		'float shift_right (float v, float amt) {',
			'v = floor(v) + 0.5;',
			'return floor(v / exp2(amt));',
		'}',
		'float shift_left (float v, float amt) {',
			'return floor(v * exp2(amt) + 0.5);',
		'}',
		'float mask_last (float v, float bits) {',
			'return mod(v, shift_left(1.0, bits));',
		'}',
		'float extract_bits (float num, float from, float to) {',
			'from = floor(from + 0.5); to = floor(to + 0.5);',
			'return mask_last(shift_right(num, from), to - from);',
		'}'
	].join('\n');

	ShaderFragment.methods = {
		packDepth: [
			'vec4 packDepth( const in float depth ) {',
				'const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );',
				'const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );',
				'vec4 res = fract( depth * bit_shift );',
				'res -= res.xxyz * bit_mask;',
				'return res;',
			'}'
		].join('\n'),
		unpackDepth: [
			'float unpackDepth( const in vec4 rgba_depth ) {',
				'const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );',
				'float depth = dot( rgba_depth, bit_shift );',
				'return depth;',
			'}'
		].join('\n'),
		packFloat: [
			packCommon,
			'vec4 packFloat (float val) {',
				'if (val == 0.0) return vec4(0, 0, 0, 0);',
				'float sign = val > 0.0 ? 0.0 : 1.0;',
				'val = abs(val);',
				'float exponent = floor(log2(val));',
				'float biased_exponent = exponent + 127.0;',
				'float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;',
				'float t = biased_exponent / 2.0;',
				'float last_bit_of_biased_exponent = fract(t) * 2.0;',
				'float remaining_bits_of_biased_exponent = floor(t);',
				'float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;',
				'float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;',
				'float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0;',
				'float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;',
				'return vec4(byte4, byte3, byte2, byte1);',
			'}'
		].join('\n'),
		unpackFloat: [
			packCommon,
			'float unpackFloat (vec4 val) {',
				// 'if (val == vec4(0.0)) return 0.0;',
				'val = val * vec4(255.0);',
				'float sign = - shift_right(val.w, 7.0) * 2.0 + 1.0;',

				'float mantissa = ',
					'val.x +',
					'shift_left(val.y, 8.0) +',
					'shift_left(extract_bits(val.z, 0.0, 7.0), 16.0);',
				' mantissa = mantissa / 8388608.0 + 1.0;',

				'float exponent = ',
					'shift_left(extract_bits(val.w, 0.0, 7.0), 1.0) +',
					'shift_right(val.z, 7.0) - 127.0;',

				'return sign * mantissa * exp2(exponent);',
			'}'
		].join('\n'),
		packDepth16: [
			'vec2 packDepth16( const in float depth ) {',
				'const vec2 bias = vec2(1.0 / 255.0, 0.0);',
				'vec2 res = vec2(depth, fract(depth * 255.0));',
				'return res - (res.yy * bias);',
			'}'
		].join('\n'),
		unpackDepth16: [
			'float unpackDepth16( const in vec2 rg_depth ) {',
				'return rg_depth.x + (rg_depth.y / 255.0);',
			'}'
		].join('\n'),
		hsv: [
			'vec3 rgb2hsv(vec3 c) {',
				'vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);',
				'vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));',
				'vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));',
				'float d = q.x - min(q.w, q.y);',
				'float e = 1.0e-10;',
				'return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);',
			'}',
			'vec3 hsv2rgb(vec3 c) {',
				'vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);',
				'vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);',
				'return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);',
			'}'
		].join('\n')
	};

	ShaderFragment.blendmodes = [
		'#define BlendLinearDodgef				BlendAddf',
		'#define BlendLinearBurnf				BlendSubstractf',
		'#define BlendAddf(base, blend)			min(base + blend, 1.0)',
		'#define BlendSubstractf(base, blend)	max(base + blend - 1.0, 0.0)',
		'#define BlendLightenf(base, blend)		max(blend, base)',
		'#define BlendDarkenf(base, blend)		min(blend, base)',
		'#define BlendLinearLightf(base, blend)	(blend < 0.5 ? BlendLinearBurnf(base, (2.0 * blend)) : BlendLinearDodgef(base, (2.0 * (blend - 0.5))))',
		'#define BlendScreenf(base, blend)		(1.0 - ((1.0 - base) * (1.0 - blend)))',
		'#define BlendOverlayf(base, blend)		(base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)))',
		'#define BlendSoftLightf(base, blend)	((blend < 0.5) ? (2.0 * base * blend + base * base * (1.0 - 2.0 * blend)) : (sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend)))',
		'#define BlendColorDodgef(base, blend)	((blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0))',
		'#define BlendColorBurnf(base, blend)	((blend == 0.0) ? blend : max((1.0 - ((1.0 - base) / blend)), 0.0))',
		'#define BlendVividLightf(base, blend)	((blend < 0.5) ? BlendColorBurnf(base, (2.0 * blend)) : BlendColorDodgef(base, (2.0 * (blend - 0.5))))',
		'#define BlendPinLightf(base, blend)	((blend < 0.5) ? BlendDarkenf(base, (2.0 * blend)) : BlendLightenf(base, (2.0 *(blend - 0.5))))',
		'#define BlendHardMixf(base, blend)		((BlendVividLightf(base, blend) < 0.5) ? 0.0 : 1.0)',
		'#define BlendReflectf(base, blend)		((blend == 1.0) ? blend : min(base * base / (1.0 - blend), 1.0))',
		'#define Blend(base, blend, funcf)		vec3(funcf(base.r, blend.r), funcf(base.g, blend.g), funcf(base.b, blend.b))',
		'#define BlendNormal(base, blend)		(blend)',
		'#define BlendLighten					BlendLightenf',
		'#define BlendDarken					BlendDarkenf',
		'#define BlendMultiply(base, blend)		(base * blend)',
		'#define BlendAverage(base, blend)		((base + blend) / 2.0)',
		'#define BlendAdd(base, blend)			min(base + blend, vec3(1.0))',
		'#define BlendSubstract(base, blend)	max(base + blend - vec3(1.0), vec3(0.0))',
		'#define BlendDifference(base, blend)	abs(base - blend)',
		'#define BlendNegation(base, blend)		(vec3(1.0) - abs(vec3(1.0) - base - blend))',
		'#define BlendExclusion(base, blend)	(base + blend - 2.0 * base * blend)',
		'#define BlendScreen(base, blend)		Blend(base, blend, BlendScreenf)',
		'#define BlendOverlay(base, blend)		Blend(base, blend, BlendOverlayf)',
		'#define BlendSoftLight(base, blend)	Blend(base, blend, BlendSoftLightf)',
		'#define BlendHardLight(base, blend)	BlendOverlay(blend, base)',
		'#define BlendColorDodge(base, blend)	Blend(base, blend, BlendColorDodgef)',
		'#define BlendColorBurn(base, blend)	Blend(base, blend, BlendColorBurnf)',
		'#define BlendLinearDodge				BlendAdd',
		'#define BlendLinearBurn				BlendSubstract',
		'#define BlendLinearLight(base, blend)	Blend(base, blend, BlendLinearLightf)',
		'#define BlendVividLight(base, blend)	Blend(base, blend, BlendVividLightf)',
		'#define BlendPinLight(base, blend)		Blend(base, blend, BlendPinLightf)',
		'#define BlendHardMix(base, blend)		Blend(base, blend, BlendHardMixf)',
		'#define BlendReflect(base, blend)		Blend(base, blend, BlendReflectf)',
		'#define BlendGlow(base, blend)			BlendReflect(blend, base)',
		'#define BlendPhoenix(base, blend)		(min(base, blend) - max(base, blend) + vec3(1.0))',
		'#define GammaCorrection(color, gamma)											pow(color, vec3(1.0 / gamma))',
		'#define LevelsControlInputRange(color, minInput, maxInput)						min(max(color - vec3(minInput), vec3(0.0)) / (vec3(maxInput) - vec3(minInput)), vec3(1.0))',
		'#define LevelsControlInput(color, minInput, gamma, maxInput)					GammaCorrection(LevelsControlInputRange(color, minInput, maxInput), gamma)',
		'#define LevelsControlOutputRange(color, minOutput, maxOutput)					mix(vec3(minOutput), vec3(maxOutput), color)',
		'#define LevelsControl(color, minInput, gamma, maxInput, minOutput, maxOutput)	LevelsControlOutputRange(LevelsControlInput(color, minInput, gamma, maxInput), minOutput, maxOutput)'
	].join('\n');

	return ShaderFragment;
})();
goo.Light = (function (
	Vector3
) {
	'use strict';

	/**
	 * A plain light source in the scene, to be handled by shaders<br>
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/light/Lights-vtest.html Working example
	 * @param {Vector3} [color=(1, 1, 1)] The color of the light
	 */
	function Light(color) {
		/**
		 * The light's translation in world space
		 * @type {Vector3}
		 */
		this.translation = new Vector3();

		/**
		 * The color of the light
		 * @type {Vector3}
		 */
		this.color = color ? color.clone() : new Vector3(1, 1, 1);

		/**
		 * The intensity of the light (typically between 0 and 1)
		 * @type {number}
		 */
		this.intensity = 1;

		/**
		 * The specular intensity of the light (typically between 0 and 1)
		 * @type {number}
		 */
		this.specularIntensity = 1;

		/**
		 * Dictates wether this light will 'cast' shadows or not
		 * @type {boolean}
		 * @default
		 */
		this.shadowCaster = false;

		/**
		 * By default lights shine a single color on surfaces. If however this parameter is used then the light will project a texture (called 'light cookie') on surfaces. The light cookie will be multiplied with the color of the light
		 * @type {null}
		 */
		this.lightCookie = null;

		/**
		 * @type {Object}
		 * @property {number} size 2000
		 * @property {number} near 1
		 * @property {number} far 1000
		 * @property {Array<number>} resolution 512x512
		 * @property {Vector3} upVector UNIT_Y
		 * @property {number} darkness Shadow contribution
		 * @property {string} shadowType Possible values 'VSM' = Variance Shadow Maps, 'PCF' = Percentage Closer Filtering, 'Basic' = No filtering
		 */
		this.shadowSettings = {
			size: 100,
			near: 1,
			far: 1000,
			resolution: [512, 512],
			upVector: Vector3.UNIT_Y.clone(),
			darkness: 1.0,
			shadowType: 'VSM'
		};
		//! AT: please extract this in its own class

		this.changedProperties = false;
		this.changedColor = false;
	}

	Light.prototype.destroy = function (renderer) {
		var shadowSettings = this.shadowSettings;
		if (shadowSettings.shadowData) {
			if (shadowSettings.shadowData.shadowTarget) {
				shadowSettings.shadowData.shadowTarget.destroy(renderer.context);
			}
			if (shadowSettings.shadowData.shadowTargetDown) {
				shadowSettings.shadowData.shadowTargetDown.destroy(renderer.context);
			}
			if (shadowSettings.shadowData.shadowBlurred) {
				shadowSettings.shadowData.shadowBlurred.destroy(renderer.context);
			}
		}
		delete shadowSettings.shadowData;
	};

	// should be overridable by light type (some may have more/less allocated resources)
	Light.prototype.invalidateHandles = function (renderer) {
		var shadowSettings = this.shadowSettings;
		if (shadowSettings.shadowData) {
			if (shadowSettings.shadowData.shadowTarget) {
				renderer.invalidateRenderTarget(shadowSettings.shadowData.shadowTarget);
			}
			if (shadowSettings.shadowData.shadowTargetDown) {
				renderer.invalidateRenderTarget(shadowSettings.shadowData.shadowTargetDown);
			}
			if (shadowSettings.shadowData.shadowBlurred) {
				renderer.invalidateRenderTarget(shadowSettings.shadowData.shadowBlurred);
			}
		}
	};

	Light.prototype.copy = function (source) {
		this.translation.copy(source.translation);
		this.color.copy(source.color);
		this.intensity = source.intensity;
		this.specularIntensity = source.specularIntensity;
		this.shadowCaster = source.shadowCaster;

		if (source.lightCookie) {
			this.lightCookie = source.lightCookie.clone();
		}

		this.shadowSettings.size = source.shadowSettings.size;
		this.shadowSettings.near = source.shadowSettings.near;
		this.shadowSettings.far = source.shadowSettings.far;
		this.shadowSettings.resolution[0] = source.shadowSettings.resolution[0];
		this.shadowSettings.resolution[1] = source.shadowSettings.resolution[1];
		this.shadowSettings.upVector.copy(source.shadowSettings.upVector);
		this.shadowSettings.darkness = source.shadowSettings.darkness;
		this.shadowSettings.shadowType = source.shadowSettings.shadowType;

		// since these are brand new they should probably be whatever value they are set in the constructor
		this.changedProperties = source.changedProperties; // false?
		this.changedColor = source.changedColor; // false?

		return this;
	};

	return Light;
})(goo.Vector3);
goo.PointLight = (function (
	Light
) {
	'use strict';

	/**
	 * A omni-directional source of light. So far it has the same effect as {@link Light}<br>
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/light/Lights-vtest.html Working example
	 * @extends Light
	 * @param {Vector3} [color=(1, 1, 1)] The color of the light
	 */
	function PointLight(color) {
		Light.call(this, color);

		/**
		 * The range of the light (default is 1000)
		 * @type {number}
		 */
		this.range = 1000;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	PointLight.prototype = Object.create(Light.prototype);
	PointLight.prototype.constructor = PointLight;

	/**
	 * Updates the light's translation
	 * @private
	 * @param {Transform} transform
	 */
	PointLight.prototype.update = function (transform) {
		transform.matrix.getTranslation(this.translation);
	};

	PointLight.prototype.copy = function (source) {
		Light.prototype.copy.call(this, source);

		this.range = source.range;

		return this;
	};

	PointLight.prototype.clone = function () {
		var clone = new PointLight(this.color.clone());
		clone.copy(this);
		return clone;
	};

	return PointLight;
})(goo.Light);
goo.DirectionalLight = (function (
	Vector3,
	Light
) {
	'use strict';

	/**
	 * A directional light
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/light/Lights-vtest.html Working example
	 * @extends Light
	 * @param {Vector3} [color=(1, 1, 1)] The color of the light
	 */
	function DirectionalLight(color) {
		Light.call(this, color);

		/**
		 * The direction vector of the light
		 * @readonly
		 * @type {Vector3}
		 */
		this.direction = new Vector3();

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	DirectionalLight.prototype = Object.create(Light.prototype);
	DirectionalLight.prototype.constructor = DirectionalLight;

	/**
	 * Updates the light's translation and orientation
	 * @hidden
	 * @param {Transform} transform
	 */
	DirectionalLight.prototype.update = function (transform) {
		transform.matrix.getTranslation(this.translation);
		this.direction.setDirect(0.0, 0.0, -1.0);
		this.direction.applyPostVector(transform.matrix);
	};

	DirectionalLight.prototype.copy = function (source) {
		Light.prototype.copy.call(this, source);

		this.direction.copy(source.direction);

		return this;
	};

	DirectionalLight.prototype.clone = function () {
		var clone = new DirectionalLight(this.color.clone());
		clone.copy(this);
		return clone;
	};

	return DirectionalLight;
})(goo.Vector3,goo.Light);
goo.SpotLight = (function (
	Vector3,
	Light
) {
	'use strict';

	/**
	 * The SpotLight can be viewed as two cones with their apexes located at the light's location.
	 * The properties angle sets the angle (in degrees) for which the outer cone
	 * deviates from the light's direction. The exponent property sets the angle for the inner cone.
	 * The angle property is also known as the outer angle or falloff. The exponent property is also known as
	 * the inner angle or hotspot.
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/light/Lights-vtest.html Working example
	 * @extends Light
	 * @param {Vector3} [color=(1, 1, 1)] The color of the light
	 */
	function SpotLight(color) {
		Light.call(this, color);

		/**
		 * The direction vector of the light
		 * @readonly
		 * @type {Vector3}
		 */
		this.direction = new Vector3();

		/**
		 * The range of the light (default is 1000)
		 * @type {number}
		 */
		this.range = 1000;

		/**
		 * The angle (in degrees) of the cone of light that this spotlight projects (default is 45)
		 * @type {number}
		 */
		this.angle = 45;

		/**
		 * The angle to where light is full strength. Then it falls off linearly to the angle-value; penumbra is always smaller than angle. Set to null if the penumbra should be the same as the angle.
		 * @type {number}
		 */
		this.penumbra = null;

		/** @type {number} */
		this.exponent = 16.0;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	SpotLight.prototype = Object.create(Light.prototype);
	SpotLight.prototype.constructor = SpotLight;

	/**
	 * Updates the light's translation and orientation
	 * @hidden
	 * @param {Transform} transform
	 */
	SpotLight.prototype.update = function (transform) {
		transform.matrix.getTranslation(this.translation);

		this.direction.setDirect(0.0, 0.0, -1.0);
		this.direction.applyPostVector(transform.matrix);
	};

	SpotLight.prototype.copy = function (source) {
		Light.prototype.copy.call(this, source);

		source.direction.copy(this.direction);
		this.range = source.range;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.exponent = source.exponent;

		return this;
	};

	SpotLight.prototype.clone = function () {
		var clone = new SpotLight(this.color.clone());
		clone.copy(this);
		return clone;
	};

	return SpotLight;
})(goo.Vector3,goo.Light);
goo.TangentGenerator = (function (
	Vector2,
	Vector3,
	MeshData
) {
	'use strict';

	/**
	 * The TangentGenerator can generate and add a buffer with tangent information to a MeshData
	 */
	function TangentGenerator() {}

	/**
	 * Generates and adds a buffer with tangent information to a MeshData object
	 * @param {MeshData} meshData MeshData object to use for generating tangent coords
	 * @param {number} [uvUnit=0] Texture coord index to use as base for tangent generation
	 */
	TangentGenerator.addTangentBuffer = function (meshData, uvUnit) {
		uvUnit = uvUnit || 0;

		var vertexBuffer = meshData.getAttributeBuffer(MeshData.POSITION);
		if (!vertexBuffer) {
			return;
		}

		var normalBuffer = meshData.getAttributeBuffer(MeshData.NORMAL);
		if (!normalBuffer) {
			return;
		}

		var textureBuffer = meshData.getAttributeBuffer('TEXCOORD' + uvUnit);
		if (!textureBuffer && uvUnit !== 0) {
			textureBuffer = meshData.getAttributeBuffer(MeshData.TEXCOORD0);
		}
		if (!textureBuffer) {
			return;
		}

		var indexBuffer = meshData.getIndexBuffer();
		if (!indexBuffer) {
			return;
		}

		var vertexCount = meshData.vertexCount;
		var triangleCount = meshData.indexCount / 3; // TODO: Handle other primitives than triangles

		var tan1 = [];
		var tan2 = [];
		for (var i = 0; i < vertexCount; i++) {
			tan1[i] = new Vector3();
			tan2[i] = new Vector3();
		}

		function getVector2Array(buf) {
			var arr = [];
			for (var i = 0; i < buf.length; i += 2) {
				arr.push(new Vector2(buf[i + 0], buf[i + 1]));
			}
			return arr;
		}

		function getVector3Array(buf) {
			var arr = [];
			for (var i = 0; i < buf.length; i += 3) {
				arr.push(new Vector3(buf[i + 0], buf[i + 1], buf[i + 2]));
			}
			return arr;
		}

		var vertex = getVector3Array(vertexBuffer);
		var normal = getVector3Array(normalBuffer);
		var texcoord = getVector2Array(textureBuffer);

		for (var a = 0; a < triangleCount; a++) {
			var i1 = indexBuffer[a * 3];
			var i2 = indexBuffer[a * 3 + 1];
			var i3 = indexBuffer[a * 3 + 2];

			var v1 = vertex[i1];
			var v2 = vertex[i2];
			var v3 = vertex[i3];

			var w1 = texcoord[i1];
			var w2 = texcoord[i2];
			var w3 = texcoord[i3];

			var x1 = v2.x - v1.x;
			var x2 = v3.x - v1.x;
			var y1 = v2.y - v1.y;
			var y2 = v3.y - v1.y;
			var z1 = v2.z - v1.z;
			var z2 = v3.z - v1.z;

			var s1 = w2.x - w1.x;
			var s2 = w3.x - w1.x;
			var t1 = w2.y - w1.y;
			var t2 = w3.y - w1.y;

			var r = 1.0 / (s1 * t2 - s2 * t1);
			if (isFinite(r) === false) {
				continue;
			}
			var sdir = new Vector3((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
			var tdir = new Vector3((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);

			tan1[i1].add(sdir);
			tan1[i2].add(sdir);
			tan1[i3].add(sdir);

			tan2[i1].add(tdir);
			tan2[i2].add(tdir);
			tan2[i3].add(tdir);
		}

		meshData.attributeMap[MeshData.TANGENT] = MeshData.createAttribute(4, 'Float');
		meshData.rebuildData(meshData.vertexCount, meshData.indexCount, true);
		var tangentBuffer = meshData.getAttributeBuffer(MeshData.TANGENT);

		var calc1 = new Vector3();
		var calc2 = new Vector3();
		for (var a = 0; a < vertexCount; a++) {
			var n = normal[a];
			var t = tan1[a];

			// Gram-Schmidt orthogonalize
			var dot = n.dot(t);
			calc1.copy(t).sub(calc2.copy(n).scale(dot)).normalize();
			tangentBuffer[a * 4 + 0] = calc1.x;
			tangentBuffer[a * 4 + 1] = calc1.y;
			tangentBuffer[a * 4 + 2] = calc1.z;

			// Calculate handedness
			dot = calc1.copy(n).cross(t).dot(tan2[a]);
			var w = dot < 0.0 ? -1.0 : 1.0;
			tangentBuffer[a * 4 + 3] = w;
		}

		return tangentBuffer;
	};

	return TangentGenerator;
})(goo.Vector2,goo.Vector3,goo.MeshData);
goo.ShaderBuilder = (function (
	Capabilities,
	MeshData,
	PointLight,
	DirectionalLight,
	SpotLight,
	Texture,
	MathUtils,
	TangentGenerator
) {
	'use strict';

	/**
	 * Builds shaders
	 */
	function ShaderBuilder() {}

	var defaultLight = new DirectionalLight();
	defaultLight.translation.setDirect(10, 10, 10);
	defaultLight.direction.setDirect(1, 1, 1).normalize();
	ShaderBuilder.defaultLight = defaultLight;

	ShaderBuilder.SKYBOX = null;
	ShaderBuilder.SKYSPHERE = null;
	ShaderBuilder.ENVIRONMENT_TYPE = 0;
	ShaderBuilder.GLOBAL_AMBIENT = [0, 0, 0];
	ShaderBuilder.CLEAR_COLOR = [0.3, 0.3, 0.3, 1];
	ShaderBuilder.USE_FOG = false;
	ShaderBuilder.FOG_SETTINGS = [0, 10000];
	ShaderBuilder.FOG_COLOR = [1, 1, 1];

	ShaderBuilder.uber = {
		defines: function (shader, attributeMap) {
			var keys = Object.keys(attributeMap);
			for (var i = 0, l = keys.length; i < l; i++) {
				shader.setDefine(keys[i], true);
			}
		},

		txMaps: function (shader, textureMaps) {
			var keys = Object.keys(textureMaps);
			for (var i = 0, l = keys.length; i < l; i++) {
				var type = keys[i];
				if (textureMaps[type] === undefined || textureMaps[type] === null) {
					continue;
				}

				if (type === 'SHADOW_MAP') {
					continue;
				}

				shader.setDefine(type, true);
			}
		},

		reflectivity: function (shader, material) {
			if (material.uniforms.reflectivity || material.uniforms.refractivity) {
				shader.setDefine('REFLECTIVE', true);
			} else {
				shader.removeDefine('REFLECTIVE');
			}
			shader.setDefine('REFLECTION_TYPE', material.uniforms.reflectionType !== undefined ? material.uniforms.reflectionType : 0);
		},

		sky: function (shader, material) {
			if (material.getTexture('LOCAL_ENVIRONMENT')) {
				material.setTexture('ENVIRONMENT_SPHERE', material.getTexture('LOCAL_ENVIRONMENT'));
				shader.setDefine('ENVIRONMENT_TYPE', 0);
				if (material.getTexture('ENVIRONMENT_CUBE')) {
					material.removeTexture('ENVIRONMENT_CUBE');
				}
			} else {
				if (ShaderBuilder.SKYBOX && (material.uniforms.reflectivity || material.uniforms.refractivity)) {
					material.setTexture('ENVIRONMENT_CUBE', ShaderBuilder.SKYBOX);
				} else if (material.getTexture('ENVIRONMENT_CUBE')) {
					material.removeTexture('ENVIRONMENT_CUBE');
				}
				if (ShaderBuilder.SKYSPHERE && (material.uniforms.reflectivity || material.uniforms.refractivity)) {
					material.setTexture('ENVIRONMENT_SPHERE', ShaderBuilder.SKYSPHERE);
					shader.setDefine('ENVIRONMENT_TYPE', ShaderBuilder.ENVIRONMENT_TYPE);
				} else if (material.getTexture('ENVIRONMENT_SPHERE')) {
					material.removeTexture('ENVIRONMENT_SPHERE');
				}
			}
		},

		uniforms: function (shader, textureMaps) {
			if (textureMaps.DIFFUSE_MAP) {
				var offset = textureMaps.DIFFUSE_MAP.offset;
				var repeat = textureMaps.DIFFUSE_MAP.repeat;
				shader.uniforms.offsetRepeat[0] = offset.x;
				shader.uniforms.offsetRepeat[1] = offset.y;
				shader.uniforms.offsetRepeat[2] = repeat.x;
				shader.uniforms.offsetRepeat[3] = repeat.y;
				shader.uniforms.lodBias = textureMaps.DIFFUSE_MAP.lodBias;
			} else {
				shader.uniforms.offsetRepeat[0] = 0;
				shader.uniforms.offsetRepeat[1] = 0;
				shader.uniforms.offsetRepeat[2] = 1;
				shader.uniforms.offsetRepeat[3] = 1;
				shader.uniforms.lodBias = 0;
			}
		},

		attributes: function (shader, attributeMap, textureMaps) {
			// Exclude in a nicer way
			var keys = Object.keys(shader.defines);
			for (var i = 0, l = keys.length; i < l; i++) {
				var attribute = keys[i];
				if (attribute === 'SHADOW_TYPE' ||
					attribute === 'JOINT_COUNT' ||
					attribute === 'WEIGHTS' ||
					attribute === 'PHYSICALLY_BASED_SHADING' ||
					attribute === 'ENVIRONMENT_TYPE' ||
					attribute === 'REFLECTIVE' ||
					attribute === 'DISCARD' ||
					attribute === 'OPACITY' ||
					attribute === 'FOG' ||
					attribute === 'REFLECTION_TYPE' ||
					attribute === 'SKIP_SPECULAR' ||
					attribute === 'LIGHT' ||
					attribute === 'COOKIE' ||
					attribute === 'TRANSPARENCY_BW' ||
					attribute === 'WRAP_AROUND') {
					continue;
				}
				if (!attributeMap[attribute] && !textureMaps[attribute]) {
					shader.removeDefine(attribute);
				}
			}
		},

		discard: function (shader, material) {
			// discard
			if (material.uniforms.discardThreshold >= 0.0) {
				shader.setDefine('DISCARD', true);
			} else {
				shader.removeDefine('DISCARD');
			}
		},

		opacity: function (shader, material) {
			// opacity
			var opacity = material.uniforms.opacity;
			if (opacity !== undefined && opacity < 1.0) {
				shader.setDefine('OPACITY', true);
			} else {
				shader.removeDefine('OPACITY');
			}

			// Alpha or "Black and white" transparency
			if (material.uniforms.useBWTransparency === true) {
				shader.setDefine('TRANSPARENCY_BW', true);
			} else {
				shader.removeDefine('TRANSPARENCY_BW');
			}
		},

		fog: function (shader) {
			// fog
			if (ShaderBuilder.USE_FOG) {
				shader.setDefine('FOG', true);
				shader.uniforms.fogSettings = ShaderBuilder.FOG_SETTINGS;
				shader.uniforms.fogColor = ShaderBuilder.FOG_COLOR;
			} else {
				shader.removeDefine('FOG');
			}
		},

		normalTangents: function (shader, shaderInfo) {
			//TODO: Hacky?
			if (shader.hasDefine('NORMAL') && shader.hasDefine('NORMAL_MAP') && !shaderInfo.meshData.getAttributeBuffer(MeshData.TANGENT)) {
				TangentGenerator.addTangentBuffer(shaderInfo.meshData);
			}
		},

		processor: function (shader, shaderInfo) {
			var attributeMap = shaderInfo.meshData.attributeMap;
			var material = shaderInfo.material;
			var textureMaps = material._textureMaps;

			shader.uniforms.clearColor = ShaderBuilder.CLEAR_COLOR;

			ShaderBuilder.uber.reflectivity(shader, material);
			ShaderBuilder.uber.sky(shader, material);


			ShaderBuilder.uber.defines(shader, attributeMap);
			ShaderBuilder.uber.txMaps(shader, textureMaps);


			ShaderBuilder.uber.uniforms(shader, textureMaps);
			ShaderBuilder.uber.attributes(shader, attributeMap, textureMaps);

			ShaderBuilder.uber.discard(shader, material);
			ShaderBuilder.uber.opacity(shader, material);

			ShaderBuilder.uber.fog(shader);

			shader.setDefine('SKIP_SPECULAR', true);
			ShaderBuilder.uber.normalTangents(shader, shaderInfo);
		}
	};

	var lightDefines = [];

	ShaderBuilder.light = {
		pointLight: function (light, uniforms, pointIndex) {
			var uniform = uniforms.pointLights = uniforms.pointLights || [];

			var ind = pointIndex * 8; // 2 vec4 = 8 floats

			var translation = light.translation;
			uniform[ind + 0] = translation.x;
			uniform[ind + 1] = translation.y;
			uniform[ind + 2] = translation.z;
			uniform[ind + 3] = light.range;

			var color = light.color;
			uniform[ind + 4] = color.x * light.intensity;
			uniform[ind + 5] = color.y * light.intensity;
			uniform[ind + 6] = color.z * light.intensity;
			uniform[ind + 7] = light.specularIntensity;

			lightDefines.push('P');
		},
		directionalLight: function (light, uniforms, directionalIndex) {
			var uniform = uniforms.directionalLights = uniforms.directionalLights || [];

			var ind = directionalIndex * 8; // 2 vec4 = 8 floats

			var direction = light.direction;
			uniform[ind + 0] = direction.x;
			uniform[ind + 1] = direction.y;
			uniform[ind + 2] = direction.z;
			uniform[ind + 3] = 0; // padding

			var color = light.color;
			uniform[ind + 4] = color.x * light.intensity;
			uniform[ind + 5] = color.y * light.intensity;
			uniform[ind + 6] = color.z * light.intensity;
			uniform[ind + 7] = light.specularIntensity;

			lightDefines.push('D');
		},
		spotLight: function (light, uniforms, spotIndex) {
			var uniform = uniforms.spotLights = uniforms.spotLights || [];

			var ind = spotIndex * 16; // 4 vec4 = 16 floats
			uniform[ind + 0] = light.translation.x;
			uniform[ind + 1] = light.translation.y;
			uniform[ind + 2] = light.translation.z;
			uniform[ind + 3] = light.range;

			uniform[ind + 4] = light.color.x * light.intensity;
			uniform[ind + 5] = light.color.y * light.intensity;
			uniform[ind + 6] = light.color.z * light.intensity;
			uniform[ind + 7] = light.specularIntensity;

			uniform[ind + 8] = light.direction.x;
			uniform[ind + 9] = light.direction.y;
			uniform[ind + 10] = light.direction.z;
			uniform[ind + 11] = 0; // padding

			uniform[ind + 12] = Math.cos(light.angle * MathUtils.DEG_TO_RAD / 2);
			uniform[ind + 13] = light.penumbra !== undefined ? Math.sin(light.penumbra * MathUtils.DEG_TO_RAD / 4) : 0;
			uniform[ind + 14] = 0; // padding
			uniform[ind + 15] = 0; // padding

			lightDefines.push('S');
		},
		shadows: function (light, uniforms, i, shader, shaderInfo, shadowIndex) {
			var useLightCookie = light.lightCookie instanceof Texture;
			if ((useLightCookie || (light.shadowCaster && shaderInfo.renderable.meshRendererComponent &&
				shaderInfo.renderable.meshRendererComponent.receiveShadows)) && light.shadowSettings.shadowData) {
				var shadowData = light.shadowSettings.shadowData;

				if (light.shadowCaster) {
					uniforms['shadowMaps' + i] = 'SHADOW_MAP' + i;
					shaderInfo.material.setTexture('SHADOW_MAP' + i, shadowData.shadowResult);



					var uniform = uniforms.shadowData = uniforms.shadowData || [];

					var ind = shadowIndex * 8;

					var translationData = shadowData.lightCamera.translation;
					uniform[ind + 0] = translationData.x;
					uniform[ind + 1] = translationData.y;
					uniform[ind + 2] = translationData.z;
					uniform[ind + 3] = 0; // padding

					uniform[ind + 4] = shadowData.cameraScale;
					uniform[ind + 5] = light.shadowSettings.darkness;
					if (light.shadowSettings.shadowType === 'PCF') {
						uniform[ind + 6] = light.shadowSettings.resolution[0];
						uniform[ind + 7] = light.shadowSettings.resolution[1];
					} else {
						uniform[ind + 6] = 0;
						uniform[ind + 7] = 0;
					}

					shadowIndex++;

					lightDefines.push('H', light.shadowSettings.shadowType === 'PCF' ? 1 : light.shadowSettings.shadowType === 'VSM' ? 2 : 0);
				}

				if (useLightCookie) {
					uniforms['lightCookie' + i] = 'LIGHT_COOKIE' + i;
					shaderInfo.material.setTexture('LIGHT_COOKIE' + i, light.lightCookie);
					lightDefines.push('C');
					shader.setDefine('COOKIE', true);
				} else {
					shader.removeDefine('COOKIE');
				}

				uniforms['shadowLightMatrices' + i] = shadowData.vpm;
			}

			return shadowIndex;
		},
		processor: function (shader, shaderInfo) {
			var uniforms = shader.uniforms;
			uniforms.totalAmbient = uniforms.totalAmbient || [0.1, 0.1, 0.1];
			shaderInfo.material.uniforms.totalAmbient = shaderInfo.material.uniforms.totalAmbient || [0.1, 0.1, 0.1];
			var materialAmbient = shaderInfo.material.uniforms.materialAmbient || uniforms.materialAmbient || [0.1, 0.1, 0.1, 1.0];
			var totalAmbient = shaderInfo.material.uniforms.totalAmbient;
			if (shaderInfo.material.multiplyAmbient) {
				totalAmbient[0] = materialAmbient[0] * ShaderBuilder.GLOBAL_AMBIENT[0];
				totalAmbient[1] = materialAmbient[1] * ShaderBuilder.GLOBAL_AMBIENT[1];
				totalAmbient[2] = materialAmbient[2] * ShaderBuilder.GLOBAL_AMBIENT[2];
			} else {
				totalAmbient[0] = materialAmbient[0] + ShaderBuilder.GLOBAL_AMBIENT[0];
				totalAmbient[1] = materialAmbient[1] + ShaderBuilder.GLOBAL_AMBIENT[1];
				totalAmbient[2] = materialAmbient[2] + ShaderBuilder.GLOBAL_AMBIENT[2];
			}

			if (!shader.frameStart) {
				var lights = shaderInfo.lights;
				for (var i = 0; i < lights.length; i++) {
					var light = lights[i];
					var useLightCookie = light.lightCookie instanceof Texture;
					if ((useLightCookie || (light.shadowCaster && shaderInfo.renderable.meshRendererComponent &&
						shaderInfo.renderable.meshRendererComponent.receiveShadows)) && light.shadowSettings.shadowData) {
						var shadowData = light.shadowSettings.shadowData;

						if (light.shadowCaster) {
							shaderInfo.material.setTexture('SHADOW_MAP' + i, shadowData.shadowResult);
						}
						if (useLightCookie) {
							shaderInfo.material.setTexture('LIGHT_COOKIE' + i, light.lightCookie);
						}
					} else {
						shaderInfo.material.removeTexture('SHADOW_MAP' + i);
					}
				}

				return;
			}

			// code below only has to be once per frame
			uniforms.materialEmissive = uniforms.materialEmissive || 'EMISSIVE';
			uniforms.materialDiffuse = uniforms.materialDiffuse || 'DIFFUSE';
			uniforms.materialSpecular = uniforms.materialSpecular || 'SPECULAR';

			var pointIndex = 0;
			var directionalIndex = 0;
			var spotIndex = 0;
			var shadowIndex = 0;

			var lights = shaderInfo.lights;
			if (lights.length > 0) {
				for (var i = 0; i < lights.length; i++) {
					var light = lights[i];

					if (light instanceof PointLight) {
						ShaderBuilder.light.pointLight(light, uniforms, pointIndex);
						pointIndex++;
					} else if (light instanceof DirectionalLight) {
						ShaderBuilder.light.directionalLight(light, uniforms, directionalIndex);
						directionalIndex++;
					} else if (light instanceof SpotLight) {
						ShaderBuilder.light.spotLight(light, uniforms, spotIndex);
						spotIndex++;
					}

					shadowIndex = ShaderBuilder.light.shadows(light, uniforms, i, shader, shaderInfo, shadowIndex);
				}

				var lightStr = lightDefines.join('');
				shader.setDefine('LIGHT', lightStr);
				lightDefines.length = 0;
			} else {
				shader.removeDefine('LIGHT');
			}
		},
		builder: function (shader, shaderInfo) {
			var prevertex = [];
			var vertex = [];
			var prefragment = [];
			var fragment = [];

			prevertex.push(
				'const mat4 ScaleMatrix = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);'
			);

			prefragment.push(
				// 'uniform vec4 materialAmbient;',
				// 'uniform vec3 globalAmbient;',
				'uniform vec3 totalAmbient;',

				'uniform vec4 materialEmissive;',
				'uniform vec4 materialDiffuse;',
				'uniform vec4 materialSpecular;',
				// 'uniform float materialSpecularPower;',
				'uniform vec2 wrapSettings;',

				// 'float VsmFixLightBleed(in float pMax, in float amount) {',
					// 'return clamp((pMax - amount) / (1.0 - amount), 0.0, 1.0);',
				// '}',

				'float ChebychevInequality(in vec2 moments, in float t) {',
					'if ( t <= moments.x ) return 1.0;',
					'float variance = moments.y - (moments.x * moments.x);',
					'variance = max(variance, 0.02);',
					'float d = t - moments.x;',
					'return variance / (variance + d * d);',
				'}'
			);

			fragment.push(
				'#if defined(SPECULAR_MAP) && defined(TEXCOORD0)',
					'float specularStrength = texture2D(specularMap, texCoord0).x;',
				'#else',
					'float specularStrength = 1.0;',
				'#endif',

				'vec3 totalDiffuse = vec3(0.0);',
				'vec3 totalSpecular = vec3(0.0);'
			);

			var lights = shaderInfo.lights;
			if (lights.length > 0) {
				fragment.push(
					'vec3 normalizedViewPosition = normalize(viewPosition);'
				);

				var pointIndex = 0;
				var directionalIndex = 0;
				var spotIndex = 0;
				var shadowIndex = 0;

				for (var i = 0; i < lights.length; i++) {
					var light = lights[i];
					if (light instanceof PointLight) {
						pointIndex++;
					} else if (light instanceof DirectionalLight) {
						directionalIndex++;
					} else if (light instanceof SpotLight) {
						spotIndex++;
					}

					var useLightCookie = light.lightCookie instanceof Texture;
					if ((useLightCookie || (light.shadowCaster &&
						shaderInfo.renderable.meshRendererComponent &&
						shaderInfo.renderable.meshRendererComponent.receiveShadows))
					) {
						shadowIndex++;
					}
				}
				if (pointIndex > 0) {
					prefragment.push(
						'uniform vec4 pointLights[' + (pointIndex * 2) + '];'
					);
				}
				if (directionalIndex > 0) {
					prefragment.push(
						'uniform vec4 directionalLights[' + (directionalIndex * 2) + '];'
					);
				}
				if (spotIndex > 0) {
					prefragment.push(
						'uniform vec4 spotLights[' + (spotIndex * 4) + '];'
					);
				}
				if (shadowIndex > 0) {
					prefragment.push(
						'uniform vec4 shadowData[' + (shadowIndex * 2) + '];'
					);
				}

				pointIndex = 0;
				directionalIndex = 0;
				spotIndex = 0;
				shadowIndex = 0;

				for (var i = 0; i < lights.length; i++) {
					var light = lights[i];

					fragment.push(
						'{',
							'float shadow = 1.0;'
					);

					var useLightCookie = light.lightCookie instanceof Texture;
					if ((useLightCookie || (light.shadowCaster &&
						shaderInfo.renderable.meshRendererComponent &&
						shaderInfo.renderable.meshRendererComponent.receiveShadows))
					) {
						prevertex.push(
							'uniform mat4 shadowLightMatrices' + i + ';',
							'varying vec4 shadowLightDepths' + i + ';'
						);

						vertex.push(
							'shadowLightDepths' + i + ' = ScaleMatrix * shadowLightMatrices' + i + ' * worldPos;'
						);

						if (light.shadowCaster) {
							prefragment.push(
								'uniform sampler2D shadowMaps' + i + ';'
								// 'uniform vec3 shadowLightPositions' + i + ';',
								// 'uniform float cameraScales' + i + ';',
								// 'uniform float shadowDarkness' + i + ';'
							);
							fragment.push(
								'vec3 shadowLightPositions' + i + ' = shadowData[' + (shadowIndex * 2 + 0) + '].xyz;',
								'float cameraScales' + i + ' = shadowData[' + (shadowIndex * 2 + 1) + '].x;',
								'float shadowDarkness' + i + ' = shadowData[' + (shadowIndex * 2 + 1) + '].y;'
							);
						}
						if (useLightCookie) {
							prefragment.push(
								'uniform sampler2D lightCookie' + i + ';'
							);
						}
						//TODO!!!

						prefragment.push(
							'varying vec4 shadowLightDepths' + i + ';'
						);

						if (light.shadowCaster && light.shadowSettings.shadowType === 'PCF') {
							// prefragment.push(
							// 	'uniform vec2 shadowMapSizes' + i + ';'
							// );
							fragment.push(
								'vec2 shadowMapSizes' + i + ' = shadowData[' + (shadowIndex * 2 + 1) + '].zw;'
							);
						}

						fragment.push(
							'vec3 depth = shadowLightDepths' + i + '.xyz / shadowLightDepths' + i + '.w;'
						);

						if (light.shadowCaster) {
							shadowIndex++;
							fragment.push(
								'depth.z = length(vWorldPos.xyz - shadowLightPositions' + i + ') * cameraScales' + i + ';',

								'if (depth.x >= 0.0 && depth.x <= 1.0 && depth.y >= 0.0 && depth.y <= 1.0 && shadowLightDepths' + i + '.z >= 0.0 && depth.z <= 1.0) {'
							);
							if (light.shadowSettings.shadowType === 'PCF') {
								fragment.push(
									'depth.z *= 0.96;',
									'float shadowPcf = 0.0;',
									'const float shadowDelta = 1.0 / 9.0;',
									'float xPixelOffset = 1.0 / shadowMapSizes' + i + '.x;',
									'float yPixelOffset = 1.0 / shadowMapSizes' + i + '.y;',

									'float dx0 = -1.25 * xPixelOffset;',
									'float dy0 = -1.25 * yPixelOffset;',
									'float dx1 = 1.25 * xPixelOffset;',
									'float dy1 = 1.25 * yPixelOffset;',

									'float fDepth = 0.0;',

									'fDepth = texture2D(shadowMaps' + i + ', depth.xy + vec2(dx0, dy0)).r;',
									'if (fDepth < depth.z) shadowPcf += shadowDelta;',
									'fDepth = texture2D(shadowMaps' + i + ', depth.xy + vec2(0.0, dy0)).r;',
									'if (fDepth < depth.z) shadowPcf += shadowDelta;',
									'fDepth = texture2D(shadowMaps' + i + ', depth.xy + vec2(dx1, dy0)).r;',
									'if (fDepth < depth.z) shadowPcf += shadowDelta;',
									'fDepth = texture2D(shadowMaps' + i + ', depth.xy + vec2(dx0, 0.0)).r;',
									'if (fDepth < depth.z) shadowPcf += shadowDelta;',
									'fDepth =  texture2D(shadowMaps' + i + ', depth.xy).r;',
									'if (fDepth < depth.z) shadowPcf += shadowDelta;',
									'fDepth = texture2D(shadowMaps' + i + ', depth.xy + vec2(dx1, 0.0)).r;',
									'if (fDepth < depth.z) shadowPcf += shadowDelta;',
									'fDepth = texture2D(shadowMaps' + i + ', depth.xy + vec2(dx0, dy1)).r;',
									'if (fDepth < depth.z) shadowPcf += shadowDelta;',
									'fDepth = texture2D(shadowMaps' + i + ', depth.xy + vec2(0.0, dy1)).r;',
									'if (fDepth < depth.z) shadowPcf += shadowDelta;',
									'fDepth = texture2D(shadowMaps' + i + ', depth.xy + vec2(dx1, dy1)).r;',
									'if (fDepth < depth.z) shadowPcf += shadowDelta;',
									'shadow = mix(1.0, 1.0 - shadowPcf, shadowDarkness' + i + ');'
									//'shadow = (1.0 - shadowPcf) * (1.0 - shadowDarkness' + i + ') + shadowDarkness' + i + ';'
								);
							} else if (light.shadowSettings.shadowType === 'VSM') {
								fragment.push(
									'vec4 texel = texture2D(shadowMaps' + i + ', depth.xy);',
									'vec2 moments = vec2(texel.x, texel.y);',
									'shadow = ChebychevInequality(moments, depth.z);',
									// 'shadow = VsmFixLightBleed(shadow, 0.5);',
									'shadow = pow(shadow, shadowDarkness' + i + ' * 8.0);'
								);
							} else {
								fragment.push(
									'depth.z *= 0.96;',
									'float shadowDepth = texture2D(shadowMaps' + i + ', depth.xy).x;',
									'if ( depth.z > shadowDepth ) shadow = 1.0 - shadowDarkness' + i + ';'
								);
							}
							fragment.push(
								'}',
								'shadow = clamp(shadow, 0.0, 1.0);'
							);
						}
					}

					if (light instanceof PointLight) {
						fragment.push(
							'vec4 pointLight' + i + ' = pointLights[' + (pointIndex * 2 + 0) + '];',
							'vec4 pointLightColor' + i + ' = pointLights[' + (pointIndex * 2 + 1) + '];'
						);

						fragment.push(
							'vec3 lVector = normalize(pointLight' + i + '.xyz - vWorldPos.xyz);',
							'float lDistance = 1.0 - min((length(pointLight' + i + '.xyz - vWorldPos.xyz) / pointLight' + i + '.w), 1.0);',

							'float dotProduct = dot(N, lVector);',

							'float pointDiffuseWeightFull = max(dotProduct, 0.0);',
							'float pointDiffuseWeightHalf = max(mix(dotProduct, 1.0, wrapSettings.x), 0.0);',
							'vec3 pointDiffuseWeight = mix(vec3(pointDiffuseWeightFull), vec3(pointDiffuseWeightHalf), wrapSettings.y);',

							'totalDiffuse += materialDiffuse.rgb * pointLightColor' + i + '.rgb * pointDiffuseWeight * lDistance * shadow;',

							'vec3 pointHalfVector = normalize(lVector + normalizedViewPosition);',
							'float pointDotNormalHalf = max(dot(N, pointHalfVector), 0.0);',
							'float pointSpecularWeight = pointLightColor' + i + '.a * specularStrength * max(pow(pointDotNormalHalf, materialSpecular.a), 0.0);',

							'#ifdef PHYSICALLY_BASED_SHADING',
								'float specularNormalization = (materialSpecular.a + 2.0001 ) / 8.0;',
								'vec3 schlick = materialSpecular.rgb + vec3(1.0 - materialSpecular.rgb) * pow(1.0 - dot(lVector, pointHalfVector), 5.0);',
								'totalSpecular += schlick * pointLightColor' + i + '.rgb * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization * shadow;',
							'#else',
								'totalSpecular += materialSpecular.rgb * pointLightColor' + i + '.rgb * pointSpecularWeight * pointDiffuseWeight * lDistance * shadow;',
							'#endif'
						);

						pointIndex++;
					} else if (light instanceof DirectionalLight) {
						fragment.push(
							'vec3 directionalLightDirection' + i + ' = directionalLights[' + (directionalIndex * 2 + 0) + '].xyz;',
							'vec4 directionalLightColor' + i + ' = directionalLights[' + (directionalIndex * 2 + 1) + '];'
						);

						fragment.push(
							'vec3 dirVector = normalize(-directionalLightDirection' + i + ');',
							'float dotProduct = dot(N, dirVector);',

							'float dirDiffuseWeightFull = max(dotProduct, 0.0);',
							'float dirDiffuseWeightHalf = max(mix(dotProduct, 1.0, wrapSettings.x), 0.0);',
							'vec3 dirDiffuseWeight = mix(vec3(dirDiffuseWeightFull), vec3(dirDiffuseWeightHalf), wrapSettings.y);',

							'vec3 cookie = vec3(1.0);'
						);
						if (useLightCookie) {
							fragment.push(
								'vec4 cookieTex = texture2D(lightCookie' + i + ', depth.xy);',
								'cookie = cookieTex.rgb * cookieTex.a;'
							);
						}
						fragment.push(
							'totalDiffuse += materialDiffuse.rgb * directionalLightColor' + i + '.rgb * dirDiffuseWeight * shadow * cookie;',

							'vec3 dirHalfVector = normalize(dirVector + normalizedViewPosition);',
							'float dirDotNormalHalf = max(dot(N, dirHalfVector), 0.0);',
							'float dirSpecularWeight = directionalLightColor' + i + '.a * specularStrength * max(pow(dirDotNormalHalf, materialSpecular.a), 0.0);',

							'#ifdef PHYSICALLY_BASED_SHADING',
								'float specularNormalization = (materialSpecular.a + 2.0001) / 8.0;',
								'vec3 schlick = materialSpecular.rgb + vec3(1.0 - materialSpecular.rgb) * pow(1.0 - dot(dirVector, dirHalfVector), 5.0);',
								'totalSpecular += schlick * directionalLightColor' + i + '.rgb * dirSpecularWeight * dirDiffuseWeight * specularNormalization * shadow * cookie;',
							'#else',
								'totalSpecular += materialSpecular.rgb * directionalLightColor' + i + '.rgb * dirSpecularWeight * dirDiffuseWeight * shadow * cookie;',
							'#endif'
						);

						directionalIndex++;
					} else if (light instanceof SpotLight) {
						fragment.push(
							'vec4 spotLight' + i + ' = spotLights[' + (spotIndex * 4 + 0) + '];',
							'vec4 spotLightColor' + i + ' = spotLights[' + (spotIndex * 4 + 1) + '];',
							'vec3 spotLightDirection' + i + ' = spotLights[' + (spotIndex * 4 + 2) + '].xyz;',
							'float spotLightAngle' + i + ' = spotLights[' + (spotIndex * 4 + 3) + '].x;',
							'float spotLightPenumbra' + i + ' = spotLights[' + (spotIndex * 4 + 3) + '].y;'
						);

						fragment.push(
							'vec3 lVector = normalize(spotLight' + i + '.xyz - vWorldPos.xyz);',
							'float lDistance = 1.0 - min((length(spotLight' + i + '.xyz - vWorldPos.xyz) / spotLight' + i + '.w), 1.0);',

							'float spotEffect = dot(normalize(-spotLightDirection' + i + '), lVector);',

							'if (spotEffect > spotLightAngle' + i + ') {',
								'if (spotLightPenumbra' + i + ' > 0.0) {',
									'spotEffect = (spotEffect - spotLightAngle' + i + ') / spotLightPenumbra' + i + ';',
									'spotEffect = clamp(spotEffect, 0.0, 1.0);',
								'} else {',
									'spotEffect = 1.0;',
								'}',

								'float dotProduct = dot(N, lVector);',

								'float spotDiffuseWeightFull = max(dotProduct, 0.0);',
								'float spotDiffuseWeightHalf = max(mix(dotProduct, 1.0, wrapSettings.x), 0.0);',
								'vec3 spotDiffuseWeight = mix(vec3(spotDiffuseWeightFull), vec3(spotDiffuseWeightHalf), wrapSettings.y);',

								'vec3 cookie = vec3(1.0);'
						);
						if (useLightCookie) {
							fragment.push(
								'cookie = texture2D(lightCookie' + i + ', depth.xy).rgb;'
							);
						}
						fragment.push(
								'totalDiffuse += materialDiffuse.rgb * spotLightColor' + i + '.rgb * spotDiffuseWeight * lDistance * spotEffect * shadow * cookie;',

								'vec3 spotHalfVector = normalize(lVector + normalizedViewPosition);',
								'float spotDotNormalHalf = max(dot(N, spotHalfVector), 0.0);',
								'float spotSpecularWeight = spotLightColor' + i + '.a * specularStrength * max(pow(spotDotNormalHalf, materialSpecular.a), 0.0);',

								'#ifdef PHYSICALLY_BASED_SHADING',
									'float specularNormalization = (materialSpecular.a + 2.0001) / 8.0;',
									'vec3 schlick = materialSpecular.rgb + vec3(1.0 - materialSpecular.rgb) * pow(1.0 - dot(lVector, spotHalfVector), 5.0);',
									'totalSpecular += schlick * spotLightColor' + i + '.rgb * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect * shadow * cookie;',
								'#else',
									'totalSpecular += materialSpecular.rgb * spotLightColor' + i + '.rgb * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect * shadow * cookie;',
								'#endif',
							'}'
						);

						spotIndex++;
					}

					fragment.push(
						'}'
					);
				}
			}

			fragment.push(
				'#if defined(EMISSIVE_MAP) && defined(TEXCOORD0)',
					'vec3 emissive = vec3(0.0);',
				'#else',
					'vec3 emissive = materialEmissive.rgb;',
				'#endif',

				// '#if defined(MULTIPLY_AMBIENT)',
				// 	'vec3 ambient = globalAmbient * materialAmbient.rgb;',
				// '#else',
				// 	'vec3 ambient = globalAmbient + materialAmbient.rgb;',
				// '#endif',

				'#ifdef SKIP_SPECULAR',
					'final_color.xyz = final_color.xyz * (emissive + totalDiffuse + totalAmbient);',
				'#else',
					'final_color.xyz = final_color.xyz * (emissive + totalDiffuse + totalAmbient) + totalSpecular;',
				'#endif',

				'#if defined(EMISSIVE_MAP) && defined(TEXCOORD0)',
					'final_color.rgb += texture2D(emissiveMap, texCoord0).rgb * materialEmissive.rgb;',
				'#endif'
			);

			ShaderBuilder.light.prevertex = prevertex.join('\n');
			ShaderBuilder.light.vertex = vertex.join('\n');
			ShaderBuilder.light.prefragment = prefragment.join('\n');
			ShaderBuilder.light.fragment = fragment.join('\n');
		}
	};

	ShaderBuilder.animation = {
		processor: function (shader, shaderInfo) {
			var pose = shaderInfo.currentPose;
			if (pose) {
				if (!shader.uniforms.jointPalette) {
					shader.uniforms.jointPalette = ShaderBuilder.animation.jointPalette;
				}
				// var maxUniforms = Math.floor(Math.max(Capabilities.maxVertexUniformVectors - 10, 0)); // Just estimate available
				// shader.setDefine('JOINT_COUNT', Math.min(shaderInfo.meshData.paletteMap.length * 3, maxUniforms));
				shader.setDefine('JOINT_COUNT', shaderInfo.meshData.paletteMap.length * 3);
			} else {
				shader.removeDefine('JOINT_COUNT');
			}
		},
		jointPalette: function (shaderInfo) {
			var skMesh = shaderInfo.meshData;
			var pose = shaderInfo.currentPose;
			if (pose) {
				var palette = pose._matrixPalette;
				var store = skMesh.store;
				if (!store) {
					store = new Float32Array(skMesh.paletteMap.length * 12);
					skMesh.store = store;
				}
				var refMat;
				for (var index = 0; index < skMesh.paletteMap.length; index++) {
					refMat = palette[skMesh.paletteMap[index]];
					for (var i = 0; i < 12; i++) {
						store[index * 12 + i] = refMat.data[ShaderBuilder.animation.order[i]];
					}
					/*
					for (var row = 0; row < 3; row++) {
						for (var col = 0; col < 4; col++) {
							// Transposed, so we can pad with translation
							store[index * 12 + row * 4 + col] = refMat.data[col * 4 + row];
						}
					}*/
				}
				return store;
			}
		},
		order: [
			0, 4, 8, 12,
			1, 5, 9, 13,
			2, 6, 10, 14
		],
		prevertex: [
			'#ifdef JOINTIDS',
			'attribute vec4 vertexJointIDs;',
			'#endif',
			'#ifdef WEIGHTS',
			'attribute vec4 vertexWeights;',
			'#endif',
			'#ifdef JOINT_COUNT',
			'uniform vec4 jointPalette[JOINT_COUNT];',
			'#endif'
		].join('\n'),
		vertex: [
			'#if defined(JOINT_COUNT) && defined(WEIGHTS) && defined(JOINTIDS)',

			'int x = 3*int(vertexJointIDs.x);',
			'int y = 3*int(vertexJointIDs.y);',
			'int z = 3*int(vertexJointIDs.z);',
			'int w = 3*int(vertexJointIDs.w);',

			'mat4 mat = mat4(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);',

			'mat += mat4(',
			'	jointPalette[x+0].x, jointPalette[x+1].x, jointPalette[x+2].x, 0,',
			'	jointPalette[x+0].y, jointPalette[x+1].y, jointPalette[x+2].y, 0,',
			'	jointPalette[x+0].z, jointPalette[x+1].z, jointPalette[x+2].z, 0,',
			'	jointPalette[x+0].w, jointPalette[x+1].w, jointPalette[x+2].w, 1',
			') * vertexWeights.x;',
			'mat += mat4(',
			'	jointPalette[y+0].x, jointPalette[y+1].x, jointPalette[y+2].x, 0,',
			'	jointPalette[y+0].y, jointPalette[y+1].y, jointPalette[y+2].y, 0,',
			'	jointPalette[y+0].z, jointPalette[y+1].z, jointPalette[y+2].z, 0,',
			'	jointPalette[y+0].w, jointPalette[y+1].w, jointPalette[y+2].w, 1',
			') * vertexWeights.y;',
			'mat += mat4(',
			'	jointPalette[z+0].x, jointPalette[z+1].x, jointPalette[z+2].x, 0,',
			'	jointPalette[z+0].y, jointPalette[z+1].y, jointPalette[z+2].y, 0,',
			'	jointPalette[z+0].z, jointPalette[z+1].z, jointPalette[z+2].z, 0,',
			'	jointPalette[z+0].w, jointPalette[z+1].w, jointPalette[z+2].w, 1',
			') * vertexWeights.z;',
			'mat += mat4(',
			'	jointPalette[w+0].x, jointPalette[w+1].x, jointPalette[w+2].x, 0,',
			'	jointPalette[w+0].y, jointPalette[w+1].y, jointPalette[w+2].y, 0,',
			'	jointPalette[w+0].z, jointPalette[w+1].z, jointPalette[w+2].z, 0,',
			'	jointPalette[w+0].w, jointPalette[w+1].w, jointPalette[w+2].w, 1',
			') * vertexWeights.w;',

			'wMatrix = wMatrix * mat / mat[3][3];',
			'#ifdef NORMAL',
				'nMatrix = nMatrix * mat3(mat) / mat[3][3];',
			'#endif',
			'#endif'
		].join('\n')
	};
	return ShaderBuilder;
})(goo.Capabilities,goo.MeshData,goo.PointLight,goo.DirectionalLight,goo.SpotLight,goo.Texture,goo.MathUtils,goo.TangentGenerator);
goo.ShaderLib = (function (
	MeshData,
	Shader,
	ShaderFragment,
	ShaderBuilder
) {
	'use strict';

	/**
	 * Collection of useful shaders<br>
	 * Details of each can be printed like this for example: console.log(ShaderLib.texturedLit).<br>
	 * There are more special purpose shaders in {@link ShaderLibExtra}
	 */
	function ShaderLib() {}

	/**
	 * The uber shader is the default Goo shader supporting the most common realistic render features.
	 * It supports lights, animations, reflective materials, normal, diffuse, AO and light textures, transparency, fog and shadows.
	 */
	ShaderLib.uber = {
		processors: [
			ShaderBuilder.uber.processor,
			ShaderBuilder.light.processor,
			ShaderBuilder.animation.processor
		],
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexNormal: MeshData.NORMAL,
			vertexTangent: MeshData.TANGENT,
			vertexColor: MeshData.COLOR,
			vertexUV0: MeshData.TEXCOORD0,
			vertexUV1: MeshData.TEXCOORD1,
			vertexJointIDs: MeshData.JOINTIDS,
			vertexWeights: MeshData.WEIGHTS
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			normalMatrix: Shader.NORMAL_MATRIX,
			cameraPosition: Shader.CAMERA,
			diffuseMap: Shader.DIFFUSE_MAP,
			offsetRepeat: [0, 0, 1, 1],
			normalMap: Shader.NORMAL_MAP,
			normalMultiplier: 1.0,
			specularMap: Shader.SPECULAR_MAP,
			emissiveMap: Shader.EMISSIVE_MAP,
			aoMap: Shader.AO_MAP,
			lightMap: Shader.LIGHT_MAP,
			environmentCube: 'ENVIRONMENT_CUBE',
			environmentSphere: 'ENVIRONMENT_SPHERE',
			reflectionMap: 'REFLECTION_MAP',
			transparencyMap: 'TRANSPARENCY_MAP',
			opacity: 1.0,
			reflectivity: 0.0,
			refractivity: 0.0,
			etaRatio: -0.5,
			fresnel: 0.0,
			discardThreshold: -0.01,
			fogSettings: [0, 10000],
			fogColor: [1, 1, 1],
			shadowDarkness: 0.5,
			vertexColorAmount: 1.0,
			lodBias: 0.0,
			wrapSettings: [0.5, 0.0]
		},
		builder: function (shader, shaderInfo) {
			ShaderBuilder.light.builder(shader, shaderInfo);
		},
		vshader: function () {
			return [
			'attribute vec3 vertexPosition;',

			'#ifdef NORMAL',
				'attribute vec3 vertexNormal;',
			'#endif',
			'#ifdef TANGENT',
				'attribute vec4 vertexTangent;',
			'#endif',
			'#ifdef COLOR',
				'attribute vec4 vertexColor;',
			'#endif',
			'#ifdef TEXCOORD0',
				'attribute vec2 vertexUV0;',
				'uniform vec4 offsetRepeat;',
				'varying vec2 texCoord0;',
			'#endif',
			'#ifdef TEXCOORD1',
				'attribute vec2 vertexUV1;',
				'varying vec2 texCoord1;',
			'#endif',

			'uniform mat4 viewProjectionMatrix;',
			'uniform mat4 worldMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',

			'varying vec3 vWorldPos;',
			'varying vec3 viewPosition;',
			'#ifdef NORMAL',
			'varying vec3 normal;',
			'#endif',
			'#ifdef TANGENT',
			'varying vec3 binormal;',
			'varying vec3 tangent;',
			'#endif',
			'#ifdef COLOR',
			'varying vec4 color;',
			'#endif',

			ShaderBuilder.light.prevertex,

			ShaderBuilder.animation.prevertex,

			'void main(void) {',
				'mat4 wMatrix = worldMatrix;',
				'#ifdef NORMAL',
					'mat3 nMatrix = normalMatrix;',
				'#endif',
				ShaderBuilder.animation.vertex,
				'vec4 worldPos = wMatrix * vec4(vertexPosition, 1.0);',
				'vWorldPos = worldPos.xyz;',
				'gl_Position = viewProjectionMatrix * worldPos;',

				'viewPosition = cameraPosition - worldPos.xyz;',

				'#ifdef NORMAL',
				'	normal = normalize(nMatrix * vertexNormal);',
				'#endif',
				'#ifdef TANGENT',
				'	tangent = normalize(nMatrix * vertexTangent.xyz);',
				'	binormal = cross(normal, tangent) * vec3(vertexTangent.w);',
				'#endif',
				'#ifdef COLOR',
				'	color = vertexColor;',
				'#endif',
				'#ifdef TEXCOORD0',
				'	texCoord0 = vertexUV0 * offsetRepeat.zw + offsetRepeat.xy;',
				'#endif',
				'#ifdef TEXCOORD1',
				'	texCoord1 = vertexUV1;',
				'#endif',

				ShaderBuilder.light.vertex,
			'}'
		].join('\n');
		},
		fshader: function () {
			return [
			'uniform float lodBias;',
			'#ifdef DIFFUSE_MAP',
				'uniform sampler2D diffuseMap;',
			'#endif',
			'#ifdef NORMAL_MAP',
				'uniform sampler2D normalMap;',
				'uniform float normalMultiplier;',
			'#endif',
			'#ifdef SPECULAR_MAP',
				'uniform sampler2D specularMap;',
			'#endif',
			'#ifdef EMISSIVE_MAP',
				'uniform sampler2D emissiveMap;',
			'#endif',
			'#ifdef AO_MAP',
				'uniform sampler2D aoMap;',
			'#endif',
			'#ifdef LIGHT_MAP',
				'uniform sampler2D lightMap;',
			'#endif',
			'#ifdef TRANSPARENCY_MAP',
				'uniform sampler2D transparencyMap;',
			'#endif',
			'#ifdef REFLECTIVE',
				'#ifdef ENVIRONMENT_CUBE',
					'uniform samplerCube environmentCube;',
				'#elif defined(ENVIRONMENT_SPHERE)',
					'uniform sampler2D environmentSphere;',
				'#endif',
				'uniform vec4 clearColor;',
				'uniform float reflectivity;',
				'uniform float fresnel;',
				'uniform float refractivity;',
				'uniform float etaRatio;',
				'#ifdef REFLECTION_MAP',
					'uniform sampler2D reflectionMap;',
				'#endif',
			'#endif',

			'#ifdef OPACITY',
				'uniform float opacity;',
			'#endif',
			'#ifdef DISCARD',
				'uniform float discardThreshold;',
			'#endif',

			'#ifdef FOG',
				'uniform vec2 fogSettings;',
				'uniform vec3 fogColor;',
			'#endif',

			'varying vec3 vWorldPos;',
			'varying vec3 viewPosition;',
			'#ifdef NORMAL',
				'varying vec3 normal;',
			'#endif',
			'#ifdef TANGENT',
				'varying vec3 binormal;',
				'varying vec3 tangent;',
			'#endif',
			'#ifdef COLOR',
				'varying vec4 color;',
				'uniform float vertexColorAmount;',
			'#endif',
			'#ifdef TEXCOORD0',
				'varying vec2 texCoord0;',
			'#endif',
			'#ifdef TEXCOORD1',
				'varying vec2 texCoord1;',
			'#endif',

			'#define M_PI 3.14159265358979323846264338328',

			ShaderBuilder.light.prefragment,

			'void main(void)',
			'{',
				'vec4 final_color = vec4(1.0);',

				'#if defined(DIFFUSE_MAP) && defined(TEXCOORD0)',
					'final_color *= texture2D(diffuseMap, texCoord0, lodBias);',
				'#endif',

				'#ifdef COLOR',
					'final_color *= mix(vec4(1.0), color, vertexColorAmount);',
				'#endif',

				'#if defined(TRANSPARENCY_MAP) && defined(TEXCOORD0)',
					'#ifdef TRANSPARENCY_BW',
						'final_color.a = texture2D(transparencyMap, texCoord0).r;',
					'#else',
						'final_color.a = texture2D(transparencyMap, texCoord0).a;',
					'#endif',
				'#endif',
				'#ifdef OPACITY',
					'final_color.a *= opacity;',
				'#endif',

				'#ifdef DISCARD',
					'if (final_color.a < discardThreshold) discard;',
				'#endif',

				'#ifdef AO_MAP',
					'#ifdef TEXCOORD1',
						'final_color.rgb *= texture2D(aoMap, texCoord1).rgb;',
					'#elif defined(TEXCOORD0)',
						'final_color.rgb *= texture2D(aoMap, texCoord0).rgb;',
					'#endif',
				'#endif',

				'#ifdef LIGHT_MAP',
					'#ifdef TEXCOORD1',
						'final_color.rgb *= texture2D(lightMap, texCoord1).rgb * 2.0;',
					'#elif defined(TEXCOORD0)',
						'final_color.rgb *= texture2D(lightMap, texCoord0).rgb * 2.0;',
					'#endif',
				'#else',
					'vec3 N = vec3(0.0, 1.0, 0.0);',
					'#if defined(NORMAL)', // Do nasty doublework for IE compliance
						'N = normalize(normal);',
					'#endif',
					'#if defined(TANGENT) && defined(NORMAL_MAP) && defined(TEXCOORD0)',
						'mat3 tangentToWorld = mat3(tangent, binormal, normal);',
						'vec3 tangentNormal = texture2D(normalMap, texCoord0, lodBias).xyz * vec3(2.0) - vec3(1.0);',
						'tangentNormal.xy *= normalMultiplier;',
						'vec3 worldNormal = (tangentToWorld * tangentNormal);',
						'N = normalize(worldNormal);',
					// '#elif defined(NORMAL)',
						// 'N = normalize(normal);',
					// '#endif',
					'#endif',

					ShaderBuilder.light.fragment,
				'#endif',

				'#ifdef REFLECTIVE',
					'if (refractivity > 0.0) {',
						'vec4 environment = vec4(0.0);',
						'#ifdef ENVIRONMENT_CUBE',
							'vec3 refractionVector = refract(normalize(viewPosition), N, etaRatio);',
							'refractionVector.x = -refractionVector.x;',
							'environment = textureCube(environmentCube, refractionVector);',
						'#elif defined(ENVIRONMENT_SPHERE)',
							'vec3 refractionVector = refract(normalize(viewPosition), N, etaRatio);',
							'refractionVector = -refractionVector;',
							'float xx = (atan(refractionVector.z, refractionVector.x) + M_PI) / (2.0 * M_PI);',
							'float yy = refractionVector.y * 0.5 + 0.5;',
							'environment = texture2D(environmentSphere, vec2(xx, yy));',
						'#endif',
						'environment.rgb = mix(clearColor.rgb, environment.rgb, environment.a);',

						'final_color.rgb = mix(final_color.rgb, environment.rgb, refractivity);',
					'}',

					'if (reflectivity > 0.0) {',
						'vec4 environment = vec4(0.0);',
						'#ifdef ENVIRONMENT_CUBE',
							'vec3 reflectionVector = reflect(normalize(viewPosition), N);',
							'reflectionVector.yz = -reflectionVector.yz;',
							'environment = textureCube(environmentCube, reflectionVector);',
						'#elif defined(ENVIRONMENT_SPHERE)',
							'vec3 reflectionVector = reflect(normalize(viewPosition), N);',
							'float xx = (atan(reflectionVector.z, reflectionVector.x) + M_PI) / (2.0 * M_PI);',
							'float yy = reflectionVector.y * 0.5 + 0.5;',
							'environment = texture2D(environmentSphere, vec2(xx, yy));',
						'#endif',
						'environment.rgb = mix(clearColor.rgb, environment.rgb, environment.a);',

						'float reflectionAmount = reflectivity;',
						'#if defined(REFLECTION_MAP) && defined(TEXCOORD0)',
							'reflectionAmount *= texture2D(reflectionMap, texCoord0).r;',
						'#endif',

						'float fresnelVal = pow(1.0 - abs(dot(normalize(viewPosition), N)), fresnel * 4.0);',
						'reflectionAmount *= fresnelVal;',

						'#if REFLECTION_TYPE == 0',
							'final_color.rgb = mix(final_color.rgb, environment.rgb, reflectionAmount);',
						'#elif REFLECTION_TYPE == 1',
							'final_color.rgb += environment.rgb * reflectionAmount;',
						'#elif REFLECTION_TYPE == 2',
							'final_color.rgb *= environment.rgb * reflectionAmount;',
						'#endif',
						'final_color.a = min(final_color.a + reflectionAmount, 1.0);',
					'}',
				'#endif',

				'#ifndef LIGHT_MAP',
					'final_color.rgb += totalSpecular;',
					'final_color.a = min(final_color.a + length(totalSpecular) / 3.0, 1.0);',
				'#endif',

				'#ifdef FOG',
					'float d = pow(smoothstep(fogSettings.x, fogSettings.y, length(viewPosition)), 1.0);',
					'final_color.rgb = mix(final_color.rgb, fogColor, d);',
				'#endif',

				'gl_FragColor = final_color;',
			'}'
		].join('\n');
		}
	};

	// only terrain depends on this
	ShaderLib.screenCopy = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec2 vertexUV0;',

		'varying vec2 texCoord0;',

		'void main(void) {',
			'texCoord0 = vertexUV0;',
			'gl_Position = vec4(vertexPosition, 1.0);',
		'}'
		].join('\n'),
		fshader: [
		'uniform sampler2D diffuseMap;',

		'varying vec2 texCoord0;',

		'void main(void)',
		'{',
			'gl_FragColor = texture2D(diffuseMap, texCoord0);',
		'}'
		].join('\n')
	};

	ShaderLib.copy = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			opacity: 1.0,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec2 vertexUV0;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'varying vec2 texCoord0;',

		'void main(void) {',
			'texCoord0 = vertexUV0;',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'uniform sampler2D diffuseMap;',
		'uniform float opacity;',

		'varying vec2 texCoord0;',

		'void main(void)',
		'{',
			'gl_FragColor = vec4(texture2D(diffuseMap, texCoord0).rgb, opacity);',
		'}'
		].join('\n')
	};

	ShaderLib.copyPure = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			opacity: 1.0,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec2 vertexUV0;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'varying vec2 texCoord0;',

		'void main(void) {',
			'texCoord0 = vertexUV0;',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'uniform sampler2D diffuseMap;',
		'uniform float opacity;',

		'varying vec2 texCoord0;',

		'void main(void)',
		'{',
			'vec4 col = texture2D(diffuseMap, texCoord0);',
			'gl_FragColor = vec4(col.rgb, col.a * opacity);',
		'}'
		].join('\n')
	};

	ShaderLib.simple = {
		attributes: {
			vertexPosition: MeshData.POSITION
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX
		},
		vshader: [
		'attribute vec3 vertexPosition;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'void main(void) {',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'void main(void)',
		'{',
			'gl_FragColor = vec4(1.0);',
		'}'
		].join('\n')
	};

	ShaderLib.simpleColored = {
		attributes: {
			vertexPosition: MeshData.POSITION
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			color: [1.0, 1.0, 1.0],
			opacity: 1.0
		},
		vshader: [
		'attribute vec3 vertexPosition;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'void main(void) {',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'uniform vec3 color;',
		'uniform float opacity;',

		'void main(void)',
		'{',
			'if (opacity == 0.0) {',
				'discard;',
			'}',
			'gl_FragColor = vec4(color, opacity);',
		'}'
		].join('\n')
	};

	ShaderLib.simpleLit = {
		processors: [
			ShaderBuilder.light.processor
		],
		defines: {
			NORMAL: true
		},
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexNormal: MeshData.NORMAL
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			cameraPosition: Shader.CAMERA,
			opacity: 1.0
		},
		builder: function (shader, shaderInfo) {
			ShaderBuilder.light.builder(shader, shaderInfo);
		},
		vshader: function () {
			return [
		'attribute vec3 vertexPosition;',
		'attribute vec3 vertexNormal;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',
		'uniform vec3 cameraPosition;',

		ShaderBuilder.light.prevertex,
		'varying vec3 normal;',
		'varying vec3 vWorldPos;',
		'varying vec3 viewPosition;',

		'void main(void) {',
			'vec4 worldPos = worldMatrix * vec4(vertexPosition, 1.0);',
			'vWorldPos = worldPos.xyz;',
			'gl_Position = viewProjectionMatrix * worldPos;',

			ShaderBuilder.light.vertex,

			'normal = (worldMatrix * vec4(vertexNormal, 0.0)).xyz;',
			'viewPosition = cameraPosition - worldPos.xyz;',
		'}'
		].join('\n');
		},
		fshader: function () {
			return [
		'#ifdef SPECULAR_MAP',
			'uniform sampler2D specularMap;',
		'#ifdef TEXCOORD0',
			'varying vec2 texCoord0;',
		'#endif',
		'#endif',

		'uniform float opacity;',

		ShaderBuilder.light.prefragment,

		'#ifdef NORMAL',
		'varying vec3 normal;',
		'#endif',
		'varying vec3 vWorldPos;',
		'varying vec3 viewPosition;',

		'void main(void)',
		'{',
			'if (opacity == 0.0) {',
				'discard;',
		// 'return;',
			'}',
		'#ifdef NORMAL',
			'vec3 N = normalize(normal);',
		'#else',
			'vec3 N = vec3(0,0,1);',
		'#endif',
			'vec4 final_color = vec4(1.0);',

			ShaderBuilder.light.fragment,

			'final_color.a = opacity;',
			'gl_FragColor = final_color;',
		'}'
		].join('\n');
		}
	};

	ShaderLib.textured = {
		defines: {
			TEXCOORD0: true,
			DIFFUSE_MAP: true
		},
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec2 vertexUV0;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'varying vec2 texCoord0;',

		'void main(void) {',
			'texCoord0 = vertexUV0;',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'#if defined(TEXCOORD0) && defined(DIFFUSE_MAP)',
		'uniform sampler2D diffuseMap;',

		'varying vec2 texCoord0;',
		'#endif',

		'void main(void)',
		'{',
		'#if defined(TEXCOORD0) && defined(DIFFUSE_MAP)',
			'gl_FragColor = texture2D(diffuseMap, texCoord0);',
		'#else',
			'gl_FragColor = vec4(1.0);',
		'#endif',
		'}'
		].join('\n')
	};

	ShaderLib.texturedLit = {
		processors: [
			ShaderBuilder.light.processor
		],
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexNormal: MeshData.NORMAL,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			cameraPosition: Shader.CAMERA,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		builder: function (shader, shaderInfo) {
			ShaderBuilder.light.builder(shader, shaderInfo);
		},
		vshader: function () {
			return [
		'attribute vec3 vertexPosition;',
		'attribute vec3 vertexNormal;',
		'attribute vec2 vertexUV0;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',
		'uniform vec3 cameraPosition;',

		ShaderBuilder.light.prevertex,

		'varying vec3 normal;',
		'varying vec3 vWorldPos;',
		'varying vec3 viewPosition;',
		'varying vec2 texCoord0;',

		'void main(void) {',
			'vec4 worldPos = worldMatrix * vec4(vertexPosition, 1.0);',
			'vWorldPos = worldPos.xyz;',
			'gl_Position = viewProjectionMatrix * worldPos;',

			ShaderBuilder.light.vertex,

			'normal = (worldMatrix * vec4(vertexNormal, 0.0)).xyz;',
			'texCoord0 = vertexUV0;',
			'viewPosition = cameraPosition - worldPos.xyz;',
		'}'
		].join('\n');
		},
		fshader: function () {
			return [
		'uniform sampler2D diffuseMap;',

		ShaderBuilder.light.prefragment,

		'varying vec3 normal;',
		'varying vec3 vWorldPos;',
		'varying vec3 viewPosition;',
		'varying vec2 texCoord0;',

		'void main(void)',
		'{',
			'vec3 N = normalize(normal);',
			'vec4 final_color = texture2D(diffuseMap, texCoord0);',

			ShaderBuilder.light.fragment,

			'gl_FragColor = final_color;',
		'}'
		].join('\n');
		}
	};

	ShaderLib.convolution = {
		defines: {
			KERNEL_SIZE_FLOAT: '25.0',
			KERNEL_SIZE_INT: '25'
		},
		attributes: {
			position: MeshData.POSITION,
			uv: MeshData.TEXCOORD0
		},
		uniforms: {
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			tDiffuse: Shader.DIFFUSE_MAP,
			uImageIncrement: [0.001953125, 0.0],
			cKernel: [],
			size: 1.0
		},
		vshader: [
		'attribute vec3 position;',
		'attribute vec2 uv;',

		'uniform mat4 viewMatrix;',
		'uniform mat4 projectionMatrix;',
		'uniform mat4 worldMatrix;',
		'uniform float size;',

		'uniform vec2 uImageIncrement;',

		'varying vec2 vUv;',

		'void main() {',
			'vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * size * uImageIncrement;',
			'gl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4( position, 1.0 );',
		'}'
		].join('\n'),
		fshader: [
		'uniform float cKernel[ KERNEL_SIZE_INT ];',
		'uniform sampler2D tDiffuse;',
		'uniform vec2 uImageIncrement;',
		'uniform float size;',

		'varying vec2 vUv;',

		'void main() {',
			'vec2 imageCoord = vUv;',
			'vec4 sum = vec4( 0.0 );',

			// 'for ( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {',
				// 'sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];',
				// 'imageCoord += uImageIncrement * size;',
			// '}',
			// Hack for Android, who seems to crash on int looping
			'for(float i = 0.0; i < KERNEL_SIZE_FLOAT; i++) {',
				'sum += texture2D( tDiffuse, imageCoord ) * cKernel[int(i)];',
				'imageCoord += uImageIncrement * size;',
			'}',

			'gl_FragColor = sum;',
		'}'
		].join('\n'),
		buildKernel: function (sigma) {
			// Ensure no negative values are used; otherwise we get an invalid
			// kernel size.
			sigma = Math.abs(sigma);

			// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.
			function gauss(x, sigma) {
				return Math.exp(-(x * x) / (2.0 * sigma * sigma));
			}

			var i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;

			if (kernelSize > kMaxKernelSize) {
				kernelSize = kMaxKernelSize;
			}
			halfWidth = (kernelSize - 1) * 0.5;
			values = new Array(kernelSize);
			sum = 0.0;
			for (i = 0; i < kernelSize; ++i) {
				values[i] = gauss(i - halfWidth, sigma);
				sum += values[i];
			}

			// normalize the kernel
			for (i = 0; i < kernelSize; ++i) {
				values[i] /= sum;
			}
			return values;
		}
	};

	ShaderLib.showNormals = {
		defines: {
			NORMAL: true
		},
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexNormal: MeshData.NORMAL
		},
		uniforms: {
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			opacity: 1.0
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec3 vertexNormal;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'varying vec3 normal;',

		'void main() {',
			'normal = vec3(worldMatrix * vec4(vertexNormal, 0.0));',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'uniform float opacity;',
		'#ifdef NORMAL',
		'varying vec3 normal;',
		'#else',
		'vec3 normal = vec3(0,0,1);',
		'#endif',

		'void main() {',
			'gl_FragColor = vec4( 0.5 * normalize( normal ) + 0.5, opacity );',
		'}'
		].join('\n')
	};

	ShaderLib.particles = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexColor: MeshData.COLOR,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec4 vertexColor;',
		'attribute vec2 vertexUV0;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',

		'varying vec2 texCoord0;',
		'varying vec4 color;',

		'void main(void) {',
			'texCoord0 = vertexUV0;',
			'color = vertexColor;',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
		'}'
		].join('\n'),
		fshader: [
		'uniform sampler2D diffuseMap;',

		'varying vec2 texCoord0;',
		'varying vec4 color;',

		'void main(void)',
		'{',
			'vec4 texCol = texture2D(diffuseMap, texCoord0);',
			'if (color.a == 0.0 || texCol.a == 0.0) discard;',
			'else gl_FragColor = texCol * color;',
		'}'
		].join('\n')
	};

	ShaderLib.normalmap = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			heightMap: Shader.DIFFUSE_MAP,
			resolution: [512, 512],
			height: 0.05
		},
		vshader: [
			'attribute vec3 vertexPosition;',
			'attribute vec2 vertexUV0;',

			'uniform mat4 viewProjectionMatrix;',
			'uniform mat4 worldMatrix;',

			'varying vec2 vUv;',
			'void main() {',
				'vUv = vertexUV0;',
				'gl_Position = viewProjectionMatrix * (worldMatrix * vec4( vertexPosition, 1.0 ));',
			'}'
		].join('\n'),
		fshader: [
			'uniform float height;',
			'uniform vec2 resolution;',
			'uniform sampler2D heightMap;',

			'varying vec2 vUv;',

			'void main() {',
				'float val = texture2D( heightMap, vUv ).x;',
				'float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;',
				'float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;',

				'gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );',
			'}'
		].join('\n')
	};

	ShaderLib.point = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexColor: MeshData.COLOR
		},
		uniforms: {
			viewProjectionMatrix: Shader.VIEW_PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			pointSize: 2.0
		},
		vshader: [
		'attribute vec3 vertexPosition;',
		'attribute vec4 vertexColor;',

		'uniform mat4 viewProjectionMatrix;',
		'uniform mat4 worldMatrix;',
		'uniform float pointSize;',

		'varying vec4 color;',

		'void main(void) {',
			'color = vertexColor;',
			'gl_Position = viewProjectionMatrix * (worldMatrix * vec4(vertexPosition, 1.0));',
			'gl_PointSize = pointSize;',
		'}'
		].join('\n'),
		fshader: [
		'varying vec4 color;',

		'void main(void)',
		'{',
			'gl_FragColor = color;',
		'}'
		].join('\n')
	};

	ShaderLib.downsample = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			tDiffuse: Shader.DIFFUSE_MAP
		},
		vshader: [
			'attribute vec3 vertexPosition;',
			'attribute vec2 vertexUV0;',

			'uniform mat4 viewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 worldMatrix;',

			'varying vec2 vUv;',
			'void main() {',
				'vUv = vertexUV0;',
				'gl_Position = projectionMatrix * viewMatrix * worldMatrix * vec4( vertexPosition, 1.0 );',
			'}'
		].join('\n'),
		fshader: [
			'uniform sampler2D tDiffuse;',

			'varying vec2 vUv;',

			'void main() {',
				'gl_FragColor = texture2D( tDiffuse, vUv );',
			'}'
		].join('\n')
	};

	ShaderLib.lightDepth = {
		processors: [
			ShaderBuilder.animation.processor
		],
		defines: {
			SHADOW_TYPE: 0,
			WEIGHTS: true,
			JOINTIDS: true
		},
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexJointIDs: MeshData.JOINTIDS,
			vertexWeights: MeshData.WEIGHTS
		},
		uniforms: {
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			cameraScale: Shader.MAIN_DEPTH_SCALE
		},
		vshader: [
		'attribute vec3 vertexPosition;',

		'uniform mat4 viewMatrix;',
		'uniform mat4 projectionMatrix;',
		'uniform mat4 worldMatrix;',

		'varying vec4 worldPosition;',
		ShaderBuilder.animation.prevertex,

		'void main(void) {',
			'mat4 wMatrix = worldMatrix;',
			ShaderBuilder.animation.vertex,
			'worldPosition = viewMatrix * (wMatrix * vec4(vertexPosition, 1.0));',
			'gl_Position = projectionMatrix * worldPosition;',
		'}'
		].join('\n'),
		fshader: [
		'uniform float cameraScale;',

		'varying vec4 worldPosition;',

		'void main(void)',
		'{',
			'float linearDepth = length(worldPosition) * cameraScale;',
			'#if SHADOW_TYPE == 0',
				'gl_FragColor = vec4(linearDepth);',
			'#elif SHADOW_TYPE == 1',
				'gl_FragColor = vec4(linearDepth);',
			'#elif SHADOW_TYPE == 2',
				'gl_FragColor = vec4(linearDepth, linearDepth * linearDepth, 0.0, 0.0);',
			'#endif',
		'}'
		].join('\n')
	};

	ShaderLib.pickingShader = {
		defines: {
			WEIGHTS: true,
			JOINTIDS: true
		},
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexJointIDs: MeshData.JOINTIDS,
			vertexWeights: MeshData.WEIGHTS,
			vertexNormal: MeshData.NORMAL
		},
		uniforms: {
			normalMatrix: Shader.NORMAL_MATRIX,
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			cameraFar: Shader.FAR_PLANE,
			thickness: 0.0,
			id: function (shaderInfo) {
				return shaderInfo.renderable._index != null ? shaderInfo.renderable._index + 1 : shaderInfo.renderable.id + 1;
			}
		},
		processors: [
			// ShaderBuilder.uber.processor,
			ShaderBuilder.animation.processor,

			function (shader) {
				shader.setDefine('NORMAL', true);
			}
		],
		vshader: [
		'attribute vec3 vertexPosition;',

		'#ifdef NORMAL',
			'attribute vec3 vertexNormal;',
		'#endif',

		'uniform mat4 viewMatrix;',
		'uniform mat4 projectionMatrix;',
		'uniform mat4 worldMatrix;',
		'uniform float cameraFar;',
		'uniform float thickness;',
		'uniform mat3 normalMatrix;',

		ShaderBuilder.animation.prevertex,

		'varying float depth;',

		'void main() {',

			'#ifdef NORMAL',
				'mat3 nMatrix = normalMatrix;',
			'#endif',

			'mat4 wMatrix = worldMatrix;',
			ShaderBuilder.animation.vertex,

			'#ifdef NORMAL',
				'vec4 mvPosition = viewMatrix * (wMatrix * vec4( vertexPosition + vertexNormal * thickness, 1.0 ));',
			'#else',
				'vec4 mvPosition = viewMatrix * (wMatrix * vec4( vertexPosition, 1.0 ));',
			'#endif',

			'depth = -mvPosition.z / cameraFar;',
			'gl_Position = projectionMatrix * mvPosition;',
		'}'
		].join('\n'),
		fshader: [
		'uniform float id;',

		'varying float depth;',

		ShaderFragment.methods.packDepth16,

		'void main() {',
			'vec2 packedId = vec2(floor(id/255.0), mod(id, 255.0)) * vec2(1.0/255.0);',
			'vec2 packedDepth = packDepth16(depth);',
			'gl_FragColor = vec4(packedId, packedDepth);',
		'}'
		].join('\n')
	};

	return ShaderLib;
})(goo.MeshData,goo.Shader,goo.ShaderFragment,goo.ShaderBuilder);
goo.Quad = (function (
	MeshData,
	_
) {
	'use strict';

	/**
	 * A rectangular, two dimensional shape. The local height of the Quad defines it's size about the y-axis,
	 * while the width defines the x-axis. The z-axis will always be 0.
	 * @extends MeshData
	 * @param {number} [width=1] Total width of quad.
	 * @param {number} [height=1] Total height of quad.
	 * @param {number} [tileX=1] Number of texture repetitions in the texture's x direction.
	 * @param {number} [tileY=1] Number of texture repetitions in the texture's y direction.
	 */
	function Quad(width, height, tileX, tileY) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			width = props.width;
			height = props.height;
			tileX = props.tileX;
			tileY = props.tileY;
		}

		/** Half-extent along the local x axis.
		 * @type {number}
		 * @default 0.5
		 */
		this.xExtent = width !== undefined ? width * 0.5 : 0.5;

		/** Half-extent along the local y axis.
		 * @type {number}
		 * @default 0.5
		 */
		this.yExtent = height !== undefined ? height * 0.5 : 0.5;

		/** Number of texture repetitions in the texture's x direction.
		 * @type {number}
		 * @default 1
		 */
		this.tileX = tileX || 1;

		/** Number of texture repetitions in the texture's y direction.
		 * @type {number}
		 * @default 1
		 */
		this.tileY = tileY || 1;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		MeshData.call(this, attributeMap, 4, 6);

		this.rebuild();
	}

	Quad.prototype = Object.create(MeshData.prototype);
	Quad.prototype.constructor = Quad;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Quad} Self for chaining.
	 */
	Quad.prototype.rebuild = function () {
		var xExtent = this.xExtent;
		var yExtent = this.yExtent;
		var tileX = this.tileX;
		var tileY = this.tileY;

		this.getAttributeBuffer(MeshData.POSITION).set([-xExtent, -yExtent, 0, -xExtent, yExtent, 0, xExtent, yExtent, 0, xExtent, -yExtent, 0]);
		this.getAttributeBuffer(MeshData.NORMAL).set([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
		this.getAttributeBuffer(MeshData.TEXCOORD0).set([0, 0, 0, tileY, tileX, tileY, tileX, 0]);

		this.getIndexBuffer().set([0, 3, 1, 1, 3, 2]);

		return this;
	};

	/**
	 * Returns a clone of this quad
	 * @returns {Quad}
	 */
	Quad.prototype.clone = function () {
		var options = _.shallowSelectiveClone(this, ['xExtent', 'yExtent', 'tileX', 'tileY']);

		return new Quad(options);
	};

	return Quad;
})(goo.MeshData,goo.ObjectUtils);
goo.Plane = (function (
	Vector3
) {
	'use strict';

	/**
	 * A representation of a mathematical plane using a normal vector and a plane constant (d) whose absolute value represents the distance
	 *        from the origin to the plane. It is generally calculated by taking a point (X) on the plane and finding its dot-product with the plane's
	 *        normal vector. In other words: d = N dot X
	 * @param {Vector3} normal Normal of the plane.
	 * @param {number} constant The plane offset along the normal.
	 */
	function Plane(normal, constant) {
		this.normal = normal ? normal.clone() : Vector3.UNIT_Y.clone();
		this.constant = isNaN(constant) ? 0 : constant;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	// TODO: add Object.freeze? - Object.freeze is still too slow unfortunately
	Plane.XZ = new Plane(Vector3.UNIT_Y, 0);
	Plane.XY = new Plane(Vector3.UNIT_Z, 0);
	Plane.YZ = new Plane(Vector3.UNIT_X, 0);

	/**
	 * @param {Vector3} point
	 * @returns {number} The distance from this plane to a provided point. If the point is on the negative side of the plane the distance returned is negative,
	 *         otherwise it is positive. If the point is on the plane, it is zero.
	 */
	Plane.prototype.pseudoDistance = function (point) {
		return this.normal.dot(point) - this.constant;
	};

	/**
	 * Sets this plane to the plane defined by the given three points.
	 * @param {Vector3} pointA
	 * @param {Vector3} pointB
	 * @param {Vector3} pointC
	 * @returns {Plane} Self for chaining.
	 */
	Plane.prototype.setPlanePoints = function (pointA, pointB, pointC) {
		this.normal.set(pointB).sub(pointA);
		this.normal.cross(new Vector3(pointC.x - pointA.x, pointC.y - pointA.y, pointC.z - pointA.z)).normalize();
		this.constant = this.normal.dot(pointA);
		return this;
	};

	/**
	 * Reflects an incoming vector across the normal of this Plane.
	 * @param {Vector3} unitVector the incoming vector. Must be a unit vector.
	 * @param {Vector3} [store] Vector to store the result in. May be the same as the unitVector.
	 * @returns {Vector3} The reflected vector.
	 */
	Plane.prototype.reflectVector = function (unitVector, store) {
		var result = store;
		if (typeof result === 'undefined') {
			result = new Vector3();
		}

		var dotProd = this.normal.dot(unitVector) * 2;
		result.set(unitVector).sub(new Vector3(this.normal.x * dotProd, this.normal.y * dotProd, this.normal.z * dotProd));
		return result;
	};

	var p0 = new Vector3();

	/**
	 * Get the intersection of a ray with a plane.
	 * @param {Ray} ray
	 * @param {Vector3} [store]
	 * @param {boolean} [suppressWarnings=false]
	 * @param {boolean} [precision=1e-8]
	 * @returns {Vector3} The store, or new Vector3 if no store was given. In the case where the ray is parallel with the plane, null is returned (and a warning is printed to console).
	 */
	Plane.prototype.rayIntersect = function (ray, store, suppressWarnings, precision) {
		//! AT: the only function with a suppressWarnings
		precision = typeof precision === 'undefined' ? 1e-7 : precision;
		store = store || new Vector3();

		var lDotN = ray.direction.dot(this.normal);
		if (Math.abs(lDotN) < precision) {
			//! AT: this is the only function where we have this suppressWarnings mechanism
			if (!suppressWarnings) {
				console.warn('Ray parallel with plane');
			}
			return null;
		}

		var pMinusL0DotN = p0.set(this.normal)
			.scale(this.constant)
			.sub(ray.origin)
			.dot(this.normal);

		return store.set(ray.direction)
			.scale(pMinusL0DotN / lDotN)
			.add(ray.origin);
	};

	/**
	 * Copies data from another plane
	 * @param source {Plane} Source plane to copy from
	 * @returns {Plane} Returns self to allow chaining
	 */
	Plane.prototype.copy = function (source) {
		this.normal.copy(source.normal);
		this.constant = source.constant;
		return this;
	};

	/**
	 * Returns a clone of this plane
	 * @returns {Plane}
	 */
	Plane.prototype.clone = function () {
		return new Plane(this.normal.clone(), this.constant);
	};

	return Plane;
})(goo.Vector3);
goo.Ray = (function (
	Vector3,
	MathUtils
) {
	'use strict';

	/**
	 * Constructs a new ray with an origin at (0, 0, 0) and a direction of (0, 0, 1).
	 */
	function Ray(origin, direction) {
		this.origin = origin ? origin.clone() : new Vector3();
		this.direction = direction ? direction.clone() : Vector3.UNIT_Z.clone();

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	var tmpVec1 = new Vector3();
	var tmpVec2 = new Vector3();
	var tmpVec3 = new Vector3();
	var tmpVec4 = new Vector3();
	var tmpVec5 = new Vector3();

	/**
	 * Check for intersection of this ray and and a quad or triangle, either just inside the shape or for the plane defined by the shape (doPlanar == true)
	 *
	 * @param polygonVertices 3 or 4 vector3s defining a triangle or quad
	 * @param [doPlanar]
	 * @param locationStore Vector3 to store our intersection point in.
	 * @returns true if this ray intersects a polygon described by the given vertices.
	 */
	Ray.prototype.intersects = function (polygonVertices, doPlanar, locationStore, skipBackSide) {
		if (polygonVertices.length === 3) {
			return this.intersectsTriangle(polygonVertices[0], polygonVertices[1], polygonVertices[2], doPlanar, locationStore, skipBackSide);
		} else if (polygonVertices.length === 4) {
			return this.intersectsTriangle(polygonVertices[0], polygonVertices[1], polygonVertices[2], doPlanar, locationStore, skipBackSide)
				|| this.intersectsTriangle(polygonVertices[0], polygonVertices[2], polygonVertices[3], doPlanar, locationStore, skipBackSide);
		}
		return false;
	};

	/**
	 * Ray vs triangle implementation.
	 *
	 * @param pointA First
	 * @param pointB
	 * @param pointC
	 * @param [doPlanar]
	 * @param [locationStore]
	 * @returns true if this ray intersects a triangle formed by the given three points.
	 */
	Ray.prototype.intersectsTriangle = function (pointA, pointB, pointC, doPlanar, locationStore, skipBackSide) {
		var edge1 = tmpVec2.set(pointB).sub(pointA);
		var edge2 = tmpVec3.set(pointC).sub(pointA);
		var norm = tmpVec4.set(edge1).cross(edge2);

		var dirDotNorm = this.direction.dot(norm);
		var sign;
		if (dirDotNorm > MathUtils.EPSILON) {
			sign = 1.0;
		} else if (dirDotNorm < -MathUtils.EPSILON) {
			if (skipBackSide) {
				return false;
			}
			sign = -1.0;
			dirDotNorm = -dirDotNorm;
		} else {
			// ray and triangle/quad are parallel
			return false;
		}

		var diff = tmpVec1.set(this.origin).sub(pointA);

		var dirDotDiffxEdge2 = sign * this.direction.dot(tmpVec5.copy(diff).cross(edge2));
		var result = false;
		if (dirDotDiffxEdge2 >= 0.0) {
			var dirDotEdge1xDiff = sign * this.direction.dot(edge1.cross(diff));
			if (dirDotEdge1xDiff >= 0.0) {
				if (dirDotDiffxEdge2 + dirDotEdge1xDiff <= dirDotNorm) {
					var diffDotNorm = -sign * diff.dot(norm);
					if (diffDotNorm >= 0.0) {
						// ray intersects triangle
						// if storage vector is null, just return true,
						if (!locationStore) {
							return true;
						}
						// else fill in.
						var inv = 1.0 / dirDotNorm;
						var t = diffDotNorm * inv;
						if (!doPlanar) {
							locationStore.set(this.origin).addDirect(this.direction.x * t, this.direction.y * t, this.direction.z * t);
						} else {
							// these weights can be used to determine
							// interpolated values, such as texture coord.
							// eg. texcoord s, t at intersection point:
							// s = w0 * s0 + w1 * s1 + w2 * s2;
							// t = w0 * t0 + w1 * t1 + w2 * t2;
							var w1 = dirDotDiffxEdge2 * inv;
							var w2 = dirDotEdge1xDiff * inv;
							// float w0 = 1.0 - w1 - w2;
							locationStore.setDirect(t, w1, w2);
						}
						result = true;
					}
				}
			}
		}
		return result;
	};

	/**
	 * @param worldVertices an array (size 3 or 4) of vectors describing a polygon
	 * @returns the distance from our origin to the primitive or Infinity if we do not intersect.
	 */
	Ray.prototype.getDistanceToPrimitive = function (worldVertices) {
		// Intersection test
		var intersect = tmpVec1;
		if (this.intersects(worldVertices, false, intersect)) {
			return this.origin.distance(intersect.x, intersect.y, intersect.z);
		}
		return Infinity;
	};

	/**
	 * @param plane
	 * @param locationStore if not null, and this ray intersects the plane, the world location of the point of intersection is stored in this vector.
	 * @returns true if the ray collides with the given Plane
	 */
	Ray.prototype.intersectsPlane = function (plane, locationStore) {
		var normal = plane.normal;
		var denominator = normal.dot(this.direction);

		if (Math.abs(denominator) < 0.00001) {
			return false; // coplanar
		}

		var numerator = -normal.dot(this.origin) + plane.constant;
		var ratio = numerator / denominator;

		if (ratio < 0.00001) {
			return false; // intersects behind origin
		}

		if (locationStore) {
			locationStore.set(this.direction).scale(ratio).add(this.origin);
		}

		return true;
	};

	/**
	 * @param {Vector3} point
	 * @param {Vector3} [store] if not null, the closest point is stored in this param
	 * @returns the squared distance from this ray to the given point.
	 */
	Ray.prototype.distanceSquared = function (point, store) {
		var vectorA = tmpVec1;

		vectorA.set(point).sub(this.origin);
		var t0 = this.direction.dot(vectorA);
		if (t0 > 0) {
			// d = |P - (O + t * D)|
			vectorA.set(this.direction).scale(t0);
			vectorA.add(this.origin);
		} else {
			// ray is closest to origin point
			vectorA.set(this.origin);
		}

		// Save away the closest point if requested
		if (store) {
			store.set(vectorA);
		}

		vectorA.sub(point);
		return vectorA.lengthSquared();
	};

	Ray.prototype.copy = function (source) {
		this.origin.copy(source.origin);
		this.direction.copy(source.direction);
	};

	Ray.prototype.clone = function () {
		return new Ray(this.origin.clone(), this.direction.clone());
	};

	return Ray;
})(goo.Vector3,goo.MathUtils);
goo.Camera = (function (
	Vector2,
	Vector3,
	Vector4,
	Matrix4,
	Plane,
	MathUtils,
	Ray,
	BoundingBox,
	BoundingSphere,
	BoundingVolume
) {
	'use strict';

	/**
	 * This class represents a view into a 3D scene and how that view should map to a 2D rendering surface.
	 * @param {number} [fov=45] The full vertical angle of view, in degrees.
	 * @param {number} [aspect=1] Aspect ratio of the 3D canvas used.
	 * @param {number} [near=1] Near plane clip distance.
	 * @param {number} [far=1000] Far plane clip distance.
	 */

	function Camera(fov, aspect, near, far) {
		fov = typeof fov !== 'undefined' ? fov : 45;
		aspect = typeof aspect !== 'undefined' ? aspect : 1;
		near = typeof near !== 'undefined' ? near : 1;
		far = typeof far !== 'undefined' ? far : 1000;

		// These need an onFrameChange() after being modified
		this.translation = new Vector3(0, 0, 0);
		this._left = new Vector3(-1, 0, 0);
		this._up = new Vector3(0, 1, 0);
		this._direction = new Vector3(0, 0, -1);

		// These need an onFrustumChange() after being modified
		this._frustumNear = this.near = 1.0;
		this._frustumFar = this.far = 2.0;
		this._frustumLeft = this.left = -0.5;
		this._frustumRight = this.right = 0.5;
		this._frustumTop = this.top = 0.5;
		this._frustumBottom = this.bottom = -0.5;

		// Used to speed up world-plane normal calculation in onFrameChange. Only calculated when frustum values are changed
		this._coeffLeft = new Vector2();
		this._coeffRight = new Vector2();
		this._coeffBottom = new Vector2();
		this._coeffTop = new Vector2();

		// These need an onViewPortChange() after being modified
		this._viewPortLeft = 0.0;
		this._viewPortRight = 1.0;
		this._viewPortTop = 1.0;
		this._viewPortBottom = 0.0;

		this._worldPlane = [];
		for (var i = 0; i < Camera.FRUSTUM_PLANES; i++) {
			this._worldPlane[i] = new Plane();
		}

		this.projectionMode = Camera.Perspective;
		this.lockedRatio = false;
		this.aspect = aspect;

		this._updateMVMatrix = true;
		this._updateInverseMVMatrix = true;
		this._updatePMatrix = true;
		this._updateMVPMatrix = true;
		this._updateInverseMVPMatrix = true;

		// NB: These matrices are column-major.
		this.modelView = new Matrix4();
		this.modelViewInverse = new Matrix4();
		this.projection = new Matrix4();
		this.modelViewProjection = new Matrix4();
		this.modelViewProjectionInverse = new Matrix4();

		//! AT: unused?
		this._planeState = 0;
		this._clipPlane = new Vector4();
		this._qCalc = new Vector4();

		this._corners = [];
		for (var i = 0; i < 8; i++) {
			this._corners.push(new Vector3());
		}
		this._extents = new Vector3();

		// Temp decl
		this.vNearPlaneCenter = new Vector3();
		this.vFarPlaneCenter = new Vector3();

		this.calcLeft = new Vector3();
		this.calcUp = new Vector3();

		this.changedProperties = true;

		this.setFrustumPerspective(fov, aspect, near, far);
		this.onFrameChange();

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	var newDirection = new Vector3(); // tmp

	// Planes of the frustum
	Camera.LEFT_PLANE = 0;
	Camera.RIGHT_PLANE = 1;
	Camera.BOTTOM_PLANE = 2;
	Camera.TOP_PLANE = 3;
	Camera.FAR_PLANE = 4;
	Camera.NEAR_PLANE = 5;
	Camera.FRUSTUM_PLANES = 6;

	//! schteppe: Why not capital letters for the following?

	/**
	 * Projection mode for perspective frustum
	 */
	Camera.Perspective = 0;
	/**
	 * Projection mode for parallel/ortographic frustum
	 */
	Camera.Parallel = 1;
	Camera.Custom = 2;

	/**
	 * Intersection response from camera.intersect
	 */
	Camera.Outside = 0;
	/**
	 * Intersection response from camera.intersect
	 */
	Camera.Inside = 1;
	/**
	 * Intersection response from camera.intersect
	 */
	Camera.Intersects = 2;

	/**
	 * Ensure our up, left and direction are unit-length vectors.
	 */
	Camera.prototype.normalize = function () {
		this._left.normalize();
		this._up.normalize();
		this._direction.normalize();
		this.onFrameChange();
	};

	/**
	 * Sets the projection mode of the camera. (Camera.Perspective / Camera.Parallel)
	 *
	 * @param {ProjectionMode} projectionMode The new projection mode - Camera.Perspective or Camera.Parallel
	 */
	Camera.prototype.setProjectionMode = function (projectionMode) {
		this.projectionMode = projectionMode;
		this.update();
	};

	/**
	 * Sets the frustum plane values of this camera using the given perspective values.
	 *
	 * @param {number} fov The full angle of view on the Y axis, in degrees.
	 * @param {number} aspect The aspect ratio of our view (generally in [0, 1]). Often this is canvas width / canvas height.
	 * @param {number} near Near plane value
	 * @param {number} far Far plane value
	 */
	Camera.prototype.setFrustumPerspective = function (fov, aspect, near, far) {
		if (fov !== undefined && fov !== null) {
			this.fov = fov;
		}
		if (aspect !== undefined && aspect !== null) {
			this.aspect = aspect;
		}
		if (near !== undefined && near !== null) {
			this.near = near;
		}
		if (far !== undefined && far !== null) {
			this.far = far;
		}

		if (this.fov !== undefined) {
			var h = Math.tan(this.fov * MathUtils.DEG_TO_RAD * 0.5) * this.near;
			var w = h * this.aspect;
			this._frustumLeft = -w;
			this._frustumRight = w;
			this._frustumBottom = -h;
			this._frustumTop = h;
			this._frustumNear = this.near;
			this._frustumFar = this.far;

			// handle invalid frustum-far
			if (this._frustumFar - this._frustumNear < MathUtils.EPSILON) {
				this._frustumFar = this._frustumNear + MathUtils.EPSILON;
			}

			this.onFrustumChange();
		}
	};

	/**
	 * Sets the frustum plane values of this camera using the given values.
	 *
	 * @param {number} near
	 * @param {number} far
	 * @param {number} left
	 * @param {number} right
	 * @param {number} top
	 * @param {number} bottom
	 */
	Camera.prototype.setFrustum = function (near, far, left, right, top, bottom, aspect) {
		if (near !== undefined && near !== null) {
			this.near = near;
		}
		if (far !== undefined && far !== null) {
			this.far = far;
		}

		if (left !== undefined && left !== null) {
			this.left = left;
		}
		if (right !== undefined && right !== null) {
			this.right = right;
		}
		if (top !== undefined && top !== null) {
			this.top = top;
		}
		if (bottom !== undefined && bottom !== null) {
			this.bottom = bottom;
		}
		if (aspect !== undefined && aspect !== null) {
			this.aspect = aspect;
		}

		this._frustumNear = this.near;
		this._frustumFar = this.far;
		this._frustumLeft = this.left * this.aspect;
		this._frustumRight = this.right * this.aspect;
		this._frustumTop = this.top;
		this._frustumBottom = this.bottom;

		// handle invalid frustum-far
		if (this._frustumFar - this._frustumNear < MathUtils.EPSILON) {
			this._frustumFar = this._frustumNear + MathUtils.EPSILON;
		}

		this.onFrustumChange();
	};

	/**
	 * Copy the settings of a source camera to this camera.
	 *
	 * @param {Camera} source
	 */
	Camera.prototype.copy = function (source) {
		this.translation.set(source.translation);
		this._left.set(source._left);
		this._up.set(source._up);
		this._direction.set(source._direction);

		this.fov = source.fov;
		this.aspect = source.aspect;

		this.near = source.near;
		this.far = source.far;
		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;

		this._frustumLeft = source._frustumLeft;
		this._frustumRight = source._frustumRight;
		this._frustumBottom = source._frustumBottom;
		this._frustumTop = source._frustumTop;
		this._frustumNear = source._frustumNear;
		this._frustumFar = source._frustumFar;

		this.projectionMode = source.projectionMode;

		this.onFrustumChange();
		this.onFrameChange();

		return this;
	};

	/**
	 * Sets the location and the left, up and direction axes of the camera.
	 *
	 * @param {Vector3} location
	 * @param {Vector3} left
	 * @param {Vector3} up
	 * @param {Vector3} direction
	 */
	Camera.prototype.setFrame = function (location, left, up, direction) {
		this._left.set(left);
		this._up.set(up);
		this._direction.set(direction);
		this.translation.set(location);

		this.onFrameChange();
	};

	/**
	 * A convenience method for auto-setting the frame based on a world position the user desires the camera to look at. It points the camera towards
	 * the given position using the difference between that position and the current camera location as a direction vector and the general
	 * worldUpVector to compute up and left camera vectors.
	 *
	 * @param {Vector3} pos Where to look at in terms of world coordinates.
	 * @param {Vector3} worldUpVector A vector indicating the up direction of the world. (often Vector3.UNIT_Y or Vector3.UNIT_Z).
	 */
	Camera.prototype.lookAt = function (pos, worldUpVector) {
		newDirection.set(pos).sub(this.translation).normalize();

		// check to see if we haven't really updated camera -- no need to call
		// sets.
		if (newDirection.equals(this._direction)) {
			return;
		}
		this._direction.set(newDirection);

		this._up.set(worldUpVector).normalize();
		if (this._up.equals(Vector3.ZERO)) {
			this._up.set(Vector3.UNIT_Y);
		}
		this._left.set(this._up).cross(this._direction).normalize();
		if (this._left.equals(Vector3.ZERO)) {
			if (this._direction.x !== 0.0) {
				this._left.setDirect(this._direction.y, -this._direction.x, 0);
			} else {
				this._left.setDirect(0, this._direction.z, -this._direction.y);
			}
		}
		this._up.set(this._direction).cross(this._left).normalize();

		this.onFrameChange();
	};

	/**
	 * Forces all aspect of the camera to be updated from internal values, and sets all dirty flags to true so that the next apply() call will fully
	 * set this camera to the render context.
	 */
	Camera.prototype.update = function () {
		this.onFrustumChange();
		this.onFrameChange();
	};

	/**
	 * Checks a bounding volume against the planes of this camera's frustum and returns if it is completely inside of, outside of, or intersecting.
	 * Example returns are Camera.Inside, Camera.Outside or Camera.Intersects.
	 *
	 * @param {BoundingVolume} bound The BoundingVolume to check for culling.
	 * @returns {number} Intersection type.
	 */
	Camera.prototype.contains = function (bound) {
		if (!bound) {
			return Camera.Inside;
		}

		var rVal = Camera.Inside;

		for (var planeCounter = Camera.FRUSTUM_PLANES - 1; planeCounter >= 0; planeCounter--) {
			switch (bound.whichSide(this._worldPlane[planeCounter])) {
				case BoundingVolume.Inside:
					return Camera.Outside;
				case BoundingVolume.Outside:
					break;
				case BoundingVolume.Intersects:
					rVal = Camera.Intersects;
					break;
			}
		}

		return rVal;
	};

	/**
	 * Updates internal frustum coefficient values to reflect the current frustum plane values.
	 * This is an optimization to move normalization/rotation of plane normals out to be done
	 * only when the frustum values change.
	 */
	Camera.prototype.onFrustumChange = function () {
		if (this.projectionMode === Camera.Perspective) {
			this._coeffLeft.setDirect(-this._frustumNear, -this._frustumLeft).normalize();
			this._coeffRight.setDirect(this._frustumNear, this._frustumRight).normalize();
			this._coeffBottom.setDirect(this._frustumNear, -this._frustumBottom).normalize();
			this._coeffTop.setDirect(-this._frustumNear, this._frustumTop).normalize();
		} else if (this.projectionMode === Camera.Parallel) {
			if (this._frustumRight > this._frustumLeft) {
				this._coeffLeft.setDirect(-1, 0);
				this._coeffRight.setDirect(1, 0);
			} else {
				this._coeffLeft.setDirect(1, 0);
				this._coeffRight.setDirect(-1, 0);
			}

			if (this._frustumTop > this._frustumBottom) {
				this._coeffBottom.setDirect(-1, 0);
				this._coeffTop.setDirect(1, 0);
			} else {
				this._coeffBottom.setDirect(1, 0);
				this._coeffTop.setDirect(-1, 0);
			}
		}

		this._updatePMatrix = true;
		this._updateMVPMatrix = true;
		this._updateInverseMVMatrix = true;
		this._updateInverseMVPMatrix = true;

		this.changedProperties = true;
	};

	/**
	 * Updates the values of the world planes associated with this camera.
	 */
	Camera.prototype.onFrameChange = function () {
		var plane;

		// left plane
		plane = this._worldPlane[Camera.LEFT_PLANE];

		plane.normal.x = this._left.x * this._coeffLeft.x + this._direction.x * this._coeffLeft.y;
		plane.normal.y = this._left.y * this._coeffLeft.x + this._direction.y * this._coeffLeft.y;
		plane.normal.z = this._left.z * this._coeffLeft.x + this._direction.z * this._coeffLeft.y;
		plane.constant = this.translation.dot(plane.normal);

		// right plane
		plane = this._worldPlane[Camera.RIGHT_PLANE];
		plane.normal.x = this._left.x * this._coeffRight.x + this._direction.x * this._coeffRight.y;
		plane.normal.y = this._left.y * this._coeffRight.x + this._direction.y * this._coeffRight.y;
		plane.normal.z = this._left.z * this._coeffRight.x + this._direction.z * this._coeffRight.y;
		plane.constant = this.translation.dot(plane.normal);

		// bottom plane
		plane = this._worldPlane[Camera.BOTTOM_PLANE];
		plane.normal.x = this._up.x * this._coeffBottom.x + this._direction.x * this._coeffBottom.y;
		plane.normal.y = this._up.y * this._coeffBottom.x + this._direction.y * this._coeffBottom.y;
		plane.normal.z = this._up.z * this._coeffBottom.x + this._direction.z * this._coeffBottom.y;
		plane.constant = this.translation.dot(plane.normal);

		// top plane
		plane = this._worldPlane[Camera.TOP_PLANE];
		plane.normal.x = this._up.x * this._coeffTop.x + this._direction.x * this._coeffTop.y;
		plane.normal.y = this._up.y * this._coeffTop.x + this._direction.y * this._coeffTop.y;
		plane.normal.z = this._up.z * this._coeffTop.x + this._direction.z * this._coeffTop.y;
		plane.constant = this.translation.dot(plane.normal);

		if (this.projectionMode === Camera.Parallel) {
			if (this._frustumRight > this._frustumLeft) {
				this._worldPlane[Camera.LEFT_PLANE].constant += this._frustumLeft;
				this._worldPlane[Camera.RIGHT_PLANE].constant -= this._frustumRight;
			} else {
				this._worldPlane[Camera.LEFT_PLANE].constant -= this._frustumLeft;
				this._worldPlane[Camera.RIGHT_PLANE].constant += this._frustumRight;
			}

			if (this._frustumBottom > this._frustumTop) {
				this._worldPlane[Camera.TOP_PLANE].constant += this._frustumTop;
				this._worldPlane[Camera.BOTTOM_PLANE].constant -= this._frustumBottom;
			} else {
				this._worldPlane[Camera.TOP_PLANE].constant -= this._frustumTop;
				this._worldPlane[Camera.BOTTOM_PLANE].constant += this._frustumBottom;
			}
		}

		var dirDotLocation = this._direction.dot(this.translation);

		// far plane
		plane = this._worldPlane[Camera.FAR_PLANE];
		plane.normal.x = -this._direction.x;
		plane.normal.y = -this._direction.y;
		plane.normal.z = -this._direction.z;
		plane.constant = -(dirDotLocation + this._frustumFar);

		// near plane
		plane = this._worldPlane[Camera.NEAR_PLANE];
		plane.normal.x = this._direction.x;
		plane.normal.y = this._direction.y;
		plane.normal.z = this._direction.z;
		plane.constant = dirDotLocation + this._frustumNear;

		this._updateMVMatrix = true;
		this._updateMVPMatrix = true;
		this._updateInverseMVMatrix = true;
		this._updateInverseMVPMatrix = true;
	};

	/**
	 * Updates the value of our projection matrix.
	 */
	Camera.prototype.updateProjectionMatrix = function () {
		if (this.projectionMode === Camera.Parallel) {
			this.projection.setIdentity();

			var d = this.projection.data;
			d[0] = 2.0 / (this._frustumRight - this._frustumLeft);
			d[5] = 2.0 / (this._frustumTop - this._frustumBottom);
			d[10] = -2.0 / (this._frustumFar - this._frustumNear);
			d[12] = -(this._frustumRight + this._frustumLeft) / (this._frustumRight - this._frustumLeft);
			d[13] = -(this._frustumTop + this._frustumBottom) / (this._frustumTop - this._frustumBottom);
			d[14] = -(this._frustumFar + this._frustumNear) / (this._frustumFar - this._frustumNear);
		} else if (this.projectionMode === Camera.Perspective) {
			this.projection.setIdentity();

			var d = this.projection.data;
			d[0] = 2.0 * this._frustumNear / (this._frustumRight - this._frustumLeft);
			d[5] = 2.0 * this._frustumNear / (this._frustumTop - this._frustumBottom);
			d[8] = (this._frustumRight + this._frustumLeft) / (this._frustumRight - this._frustumLeft);
			d[9] = (this._frustumTop + this._frustumBottom) / (this._frustumTop - this._frustumBottom);
			d[10] = -(this._frustumFar + this._frustumNear) / (this._frustumFar - this._frustumNear);
			d[11] = -1.0;
			d[14] = -(2.0 * this._frustumFar * this._frustumNear) / (this._frustumFar - this._frustumNear);
			d[15] = -0.0;
		}
	};

	/**
	 * Updates the value of our model view matrix.
	 */
	Camera.prototype.updateModelViewMatrix = function () {
		this.modelView.setIdentity();

		var d = this.modelView.data;

		d[0] = -this._left.x;
		d[4] = -this._left.y;
		d[8] = -this._left.z;

		d[1] = this._up.x;
		d[5] = this._up.y;
		d[9] = this._up.z;

		d[2] = -this._direction.x;
		d[6] = -this._direction.y;
		d[10] = -this._direction.z;

		d[12] = this._left.dot(this.translation);
		d[13] = -this._up.dot(this.translation);
		d[14] = this._direction.dot(this.translation);
	};

	/**
	 * Calculate a Pick Ray using the given screen position at the near plane of this camera and the camera's position in space.
	 *
	 * @param {number} screenX The screen x position.
	 * @param {number} screenY The screen y position.
	 * @param {number} screenWidth The screen width.
	 * @param {number} screenHeight The screen height.
	 * @param {Ray} [store] The Ray to store the result in. If null, a new Ray is created and returned.
	 * @returns {Ray} The resulting Ray.
	 */
	Camera.prototype.getPickRay = function (screenX, screenY, screenWidth, screenHeight, store) {
		if (!store) {
			store = new Ray();
		}
		this.getWorldCoordinates(screenX, screenY, screenWidth, screenHeight, 0, store.origin);
		this.getWorldCoordinates(screenX, screenY, screenWidth, screenHeight, 0.3, store.direction).sub(store.origin).normalize();
		return store;
	};

	/**
	 * Converts a local x, y screen position and depth value to world coordinates based on the current settings of this camera.
	 * This function calls getWorldCoordinates after converting zDepth to screen space.
	 *
	 * @param {number} screenX The screen x position.
	 * @param {number} screenY The screen y position.
	 * @param {number} screenWidth The screen width.
	 * @param {number} screenHeight The screen height.
	 * @param {number} zDepth The depth into the camera view in world distance.
	 * @param {Vector3} [store] Use to avoid object creation. if not null, the results are stored in the given vector and returned. Otherwise, a new vector is
	 *            created.
	 * @returns {Vector3} Vector containing the world coordinates.
	 */
	Camera.prototype.getWorldPosition = function (screenX, screenY, screenWidth, screenHeight, zDepth, store) {
		if (this.projectionMode === Camera.Parallel) {
			zDepth = ((zDepth - this.near) / (this.far - this.near));
		} else {
			// http://www.sjbaker.org/steve/omniv/love_your_z_buffer.html
			zDepth = (this.far / (this.far - this.near)) + ((this.far * this.near / (this.near - this.far)) / zDepth);
		}
		return this.getWorldCoordinates(screenX, screenY, screenWidth, screenHeight, zDepth, store);
	};

	/**
	 * Converts a local x, y screen position and depth value to world coordinates based on the current settings of this camera.
	 *
	 * @param {number} screenX The screen x position (x=0 is the leftmost coordinate of the screen).
	 * @param {number} screenY The screen y position (y=0 is the top of the screen).
	 * @param {number} screenWidth The screen width.
	 * @param {number} screenHeight The screen height.
	 * @param {number} zDepth The {@link http://www.sjbaker.org/steve/omniv/love_your_z_buffer.html non linear depth} between 0 and 1 into the camera view. 0 indicates the near plane of the camera and 1 indicates the far plane.
	 * @param {Vector3} [store] Use to avoid object creation. If not null, the results are stored in the given vector and returned. Otherwise, a new vector is
	 *            created.
	 * @returns {Vector3} Vector containing the world coordinates.
	 */
	Camera.prototype.getWorldCoordinates = function (screenX, screenY, screenWidth, screenHeight, zDepth, store) {
		if (!store) {
			store = new Vector3();
		}
		this.checkInverseModelViewProjection();
		var position = new Vector4();

		var x = (screenX / screenWidth - this._viewPortLeft) / (this._viewPortRight - this._viewPortLeft) * 2 - 1;
		var y = ((screenHeight - screenY) / screenHeight - this._viewPortBottom) / (this._viewPortTop - this._viewPortBottom) * 2 - 1;

		/*
		var aspect = this.aspect / (screenWidth / screenHeight);
		if (aspect > 1) {
			y *= aspect;
		} else if (aspect < 1) {
			x /= aspect;
		}
		*/

		position.setDirect(x, y, zDepth * 2 - 1, 1);
		position.applyPost(this.modelViewProjectionInverse);
		if (position.w !== 0.0) {
			position.scale(1.0 / position.w);
		}
		store.x = position.x;
		store.y = position.y;
		store.z = position.z;

		return store;
	};

	/**
	 * Converts a position in world coordinate space to an x, y screen position and non linear depth value using the current settings of this camera.
	 *
	 * @param {Vector3} worldPos The position in world space to retrieve screen coordinates for.
	 * @param {number} screenWidth The screen width.
	 * @param {number} screenHeight The screen height.
	 * @param {Vector3} [store] Use to avoid object creation. if not null, the results are stored in the given vector and returned. Otherwise, a new vector is
	 *            created.
	 * @returns {Vector3} Vector containing the screen coordinates as x and y and the distance as a non linear value between the near (0) and far (1) planes.
	 */
	Camera.prototype.getScreenCoordinates = function (worldPosition, screenWidth, screenHeight, store) {
		store = this.getNormalizedDeviceCoordinates(worldPosition, store);

		/*
		var aspect = this.aspect / (screenWidth / screenHeight);
		if (aspect > 1) {
			store.y /= aspect;
		} else if (aspect < 1) {
			store.x *= aspect;
		}
		*/

		store.x = (store.x + 1) * (this._viewPortRight - this._viewPortLeft) / 2 * screenWidth;
		store.y = (1 - store.y) * (this._viewPortTop - this._viewPortBottom) / 2 * screenHeight;
		store.z = (store.z + 1) / 2;

		return store;
	};

	/**
	 * Converts a position in world coordinate space to a x, y, z frustum position using the current settings of this camera.
	 *
	 * @param {Vector3} worldPos the position in space to retrieve frustum coordinates for.
	 * @param {Vector3} [store] Use to avoid object creation. if not null, the results are stored in the given vector and returned.
	 *        Otherwise, a new vector is created.
	 * @returns {Vector3} Vector containing the x, y and z frustum position.
	 */
	Camera.prototype.getFrustumCoordinates = function (worldPosition, store) {
		store = this.getNormalizedDeviceCoordinates(worldPosition, store);

		store.x = (store.x + 1) * (this._frustumRight - this._frustumLeft) / 2 + this._frustumLeft;
		store.y = (store.y + 1) * (this._frustumTop - this._frustumBottom) / 2 + this._frustumBottom;
		store.z = (store.z + 1) * (this._frustumFar - this._frustumNear) / 2 + this._frustumNear;

		return store;
	};

	/**
	 * Converts a position in world coordinate space to normalized device coordinates by applying the modelViewProjection from this camera.
	 *
	 * @param {Vector3} worldPos The position in space to retrieve coordinates for.
	 * @param {Vector3} [store] Use to avoid object creation. If not null, the results are stored in the given vector and returned.
	 *        Otherwise, a new vector is created.
	 * @returns {Vector3} Vector containing the x, y and z normalized device coordinates.
	 */
	Camera.prototype.getNormalizedDeviceCoordinates = function (worldPosition, store) {
		if (!store) {
			store = new Vector3();
		}
		this.checkModelViewProjection();
		var position = new Vector4();
		position.setDirect(worldPosition.x, worldPosition.y, worldPosition.z, 1);
		position.applyPost(this.modelViewProjection);
		if (position.w !== 0.0) {
			position.scale(1.0 / position.w);
		}
		store.x = position.x;
		store.y = position.y;
		store.z = position.z;

		return store;
	};

	/**
	 * Update the modelView matrix if necessary.
	 */
	Camera.prototype.checkModelView = function () {
		if (this._updateMVMatrix) {
			this.updateModelViewMatrix();
			this._updateMVMatrix = false;
		}
	};

	/**
	 * Update the projection matrix if necessary.
	 */
	Camera.prototype.checkProjection = function () {
		if (this._updatePMatrix) {
			this.updateProjectionMatrix();
			this._updatePMatrix = false;
		}
	};

	/**
	 * Update the modelViewProjection matrix if necessary.
	 */
	Camera.prototype.checkModelViewProjection = function () {
		if (this._updateMVPMatrix) {
			this.checkModelView();
			this.checkProjection();
			// because these are transposed, we need to flip order
			this.modelViewProjection.mul2(this.getProjectionMatrix(), this.getViewMatrix());
			this._updateMVPMatrix = false;
		}
	};

	/**
	 * Update the inverse modelView matrix if necessary.
	 */
	Camera.prototype.checkInverseModelView = function () {
		if (this._updateInverseMVMatrix) {
			this.checkModelView();
			this.modelViewInverse.copy(this.modelView).invert();
			//Matrix4.invert(this.modelView, this.modelViewInverse);
			this._updateInverseMVMatrix = false;
		}
	};

	/**
	 * Update the inverse modelViewProjection matrix if necessary.
	 */
	Camera.prototype.checkInverseModelViewProjection = function () {
		if (this._updateInverseMVPMatrix) {
			this.checkModelViewProjection();
			this.modelViewProjectionInverse.copy(this.modelViewProjection).invert();
			//Matrix4.invert(this.modelViewProjection, this.modelViewProjectionInverse);
			this._updateInverseMVPMatrix = false;
		}
	};

	/**
	 * @returns {Matrix4} The modelView matrix.
	 */
	Camera.prototype.getViewMatrix = function () {
		this.checkModelView();
		return this.modelView;
	};

	/**
	 * @returns {Matrix4} The projection matrix.
	 */
	Camera.prototype.getProjectionMatrix = function () {
		this.checkProjection();
		return this.projection;
	};

	/**
	 * @returns {Matrix4} The modelViewProjection matrix.
	 */
	Camera.prototype.getViewProjectionMatrix = function () {
		this.checkModelViewProjection();
		return this.modelViewProjection;
	};

	/**
	 * @returns {Matrix4} The modelViewInverse matrix.
	 */
	Camera.prototype.getViewInverseMatrix = function () {
		this.checkInverseModelView();
		return this.modelViewInverse;
	};

	/**
	 * @returns {Matrix4} The modelViewProjectionInverse matrix.
	 */
	Camera.prototype.getViewProjectionInverseMatrix = function () {
		this.checkInverseModelViewProjection();
		return this.modelViewProjectionInverse;
	};

	/**
	 * Compress this camera's near and far frustum planes to be smaller if possible,
	 * using the given bounds as a measure.
	 * @param {BoundingVolume} sceneBounds The scene bounds.
	 */
	Camera.prototype.pack = function (sceneBounds) {
		var center = sceneBounds.center;
		var corners = this._corners;
		var extents = this._extents;

		for (var i = 0; i < corners.length; i++) {
			corners[i].set(center);
		}

		if (sceneBounds instanceof BoundingBox) {
			extents.setDirect(sceneBounds.xExtent, sceneBounds.yExtent, sceneBounds.zExtent);
		} else if (sceneBounds instanceof BoundingSphere) {
			extents.setDirect(sceneBounds.radius, sceneBounds.radius, sceneBounds.radius);
		}

		corners[0].addDirect(extents.x, extents.y, extents.z);
		corners[1].addDirect(extents.x, -extents.y, extents.z);
		corners[2].addDirect(extents.x, extents.y, -extents.z);
		corners[3].addDirect(extents.x, -extents.y, -extents.z);
		corners[4].addDirect(-extents.x, extents.y, extents.z);
		corners[5].addDirect(-extents.x, -extents.y, extents.z);
		corners[6].addDirect(-extents.x, extents.y, -extents.z);
		corners[7].addDirect(-extents.x, -extents.y, -extents.z);

		var mvMatrix = this.getViewMatrix();
		var optimalCameraNear = Number.MAX_VALUE;
		var optimalCameraFar = -Number.MAX_VALUE;
		var position = new Vector4();
		for (var i = 0; i < corners.length; i++) {
			position.setDirect(corners[i].x, corners[i].y, corners[i].z, 1);
			position.applyPre(mvMatrix);

			optimalCameraNear = Math.min(-position.z, optimalCameraNear);
			optimalCameraFar = Math.max(-position.z, optimalCameraFar);
		}

		optimalCameraNear = Math.min(Math.max(this._frustumNear, optimalCameraNear), this._frustumFar);
		optimalCameraFar = Math.max(optimalCameraNear, Math.min(this._frustumFar, optimalCameraFar));

		var change = optimalCameraNear / this._frustumNear;
		this._frustumLeft = this._frustumLeft * change;
		this._frustumRight = this._frustumRight * change;
		this._frustumTop = this._frustumTop * change;
		this._frustumBottom = this._frustumBottom * change;

		this._frustumNear = optimalCameraNear;
		this._frustumFar = optimalCameraFar;
	};

	Camera.prototype.calculateFrustumCorners = function (fNear, fFar) {
		fNear = fNear !== undefined ? fNear : this._frustumNear;
		fFar = fFar !== undefined ? fFar : this._frustumFar;

		var fNearPlaneHeight = (this._frustumTop - this._frustumBottom) * fNear * 0.5 / this._frustumNear;
		var fNearPlaneWidth = (this._frustumRight - this._frustumLeft) * fNear * 0.5 / this._frustumNear;

		var fFarPlaneHeight = (this._frustumTop - this._frustumBottom) * fFar * 0.5 / this._frustumNear;
		var fFarPlaneWidth = (this._frustumRight - this._frustumLeft) * fFar * 0.5 / this._frustumNear;

		if (this.projectionMode === Camera.Parallel) {
			fNearPlaneHeight = (this._frustumTop - this._frustumBottom) * 0.5;
			fNearPlaneWidth = (this._frustumRight - this._frustumLeft) * 0.5;

			fFarPlaneHeight = (this._frustumTop - this._frustumBottom) * 0.5;
			fFarPlaneWidth = (this._frustumRight - this._frustumLeft) * 0.5;
		}

		var vNearPlaneCenter = this.vNearPlaneCenter;
		var vFarPlaneCenter = this.vFarPlaneCenter;

		var direction = this.calcLeft;

		direction.set(this._direction).scale(fNear);
		vNearPlaneCenter.set(this.translation).add(direction);
		direction.set(this._direction).scale(fFar);
		vFarPlaneCenter.set(this.translation).add(direction);

		var left = this.calcLeft;
		var up = this.calcUp;

		left.set(this._left).scale(fNearPlaneWidth);
		up.set(this._up).scale(fNearPlaneHeight);
		this._corners[0].set(vNearPlaneCenter).sub(left).sub(up);
		this._corners[1].set(vNearPlaneCenter).add(left).sub(up);
		this._corners[2].set(vNearPlaneCenter).add(left).add(up);
		this._corners[3].set(vNearPlaneCenter).sub(left).add(up);

		left.set(this._left).scale(fFarPlaneWidth);
		up.set(this._up).scale(fFarPlaneHeight);
		this._corners[4].set(vFarPlaneCenter).sub(left).sub(up);
		this._corners[5].set(vFarPlaneCenter).add(left).sub(up);
		this._corners[6].set(vFarPlaneCenter).add(left).add(up);
		this._corners[7].set(vFarPlaneCenter).sub(left).add(up);

		return this._corners;
	};

	/**
	 * Clip using an oblique frustum different from the the view frustum
	 * @param {Vector4} clipPlane Clipping plane. (nx, ny, nz, constant)
	 */
	Camera.prototype.setToObliqueMatrix = function (clipPlane) {
		var transformedClipPlane = this._clipPlane.set(clipPlane);

		// bring the clip-plane into camera space which is needed for the calculation
		transformedClipPlane.w = 0;
		transformedClipPlane.applyPost(this.getViewMatrix());
		transformedClipPlane.w = this.translation.y * clipPlane.y - clipPlane.w;

		// calculate oblique camera projection matrix
		this._updatePMatrix = true;
		var projection = this.getProjectionMatrix();

		this._qCalc.setDirect(
			(MathUtils.sign(transformedClipPlane.x) + projection[8]) / projection[0],
			(MathUtils.sign(transformedClipPlane.y) + projection[9]) / projection[5],
			-1,
			(1.0 + projection[10]) / projection[14]
		);

		transformedClipPlane.scale(2.0 / transformedClipPlane.dot(this._qCalc));

		projection[2] = transformedClipPlane.x;
		projection[6] = transformedClipPlane.y;
		projection[10] = transformedClipPlane.z + 1.0;
		projection[14] = transformedClipPlane.w;

		this._updateMVPMatrix = true;
		this._updateInverseMVPMatrix = true;
	};

	Camera.prototype.clone = function () {
		var clone = new Camera(this.fov, this.aspect, this.near, this.far);
		clone.copy(this);
		return clone;
	};

	return Camera;
})(goo.Vector2,goo.Vector3,goo.Vector4,goo.Matrix4,goo.Plane,goo.MathUtils,goo.Ray,goo.BoundingBox,goo.BoundingSphere,goo.BoundingVolume);
goo.FullscreenUtils = (function (
	Quad,
	Camera,
	Vector3
) {
	'use strict';

	/**
	 * Utility class with a default setup parallel camera and fullscreen quad for fullscreen pass usage
	 */
	function FullscreenUtils() {}

	var camera = new Camera();
	camera.projectionMode = Camera.Parallel;
	camera.setFrustum(0, 1, -1, 1, 1, -1);
	camera._left.copy(Vector3.UNIT_X).negate();
	camera._up.copy(Vector3.UNIT_Y);
	camera._direction.copy(Vector3.UNIT_Z);
	camera.onFrameChange();
	FullscreenUtils.camera = camera;

	FullscreenUtils.quad = new Quad(2, 2);

	return FullscreenUtils;
})(goo.Quad,goo.Camera,goo.Vector3);
goo.Pass = (function () {
	'use strict';

	/**
	 * Base pass class
	 */
	function Pass() {}

	Pass.prototype.destroy = function (/* renderer */) {};

	Pass.prototype.render = function (/* renderer, writeBuffer, readBuffer, delta, maskActive, camera, lights, clearColor */) {};

	Pass.prototype.updateSize = function (/* size, renderer */) {};

	Pass.prototype.invalidateHandles = function (/* renderer */) {};

	return Pass;
})();
goo.FullscreenPass = (function (
	Material,
	FullscreenUtils,
	ShaderLib,
	Pass
) {
	'use strict';

	/**
	 * Fullscreen pass
	 * @param shader
	 */
	function FullscreenPass(shader) {
		this.material = new Material(shader || ShaderLib.simple);
		this.useReadBuffer = true;

		this.renderToScreen = false;

		this.renderable = {
			meshData: FullscreenUtils.quad,
			materials: [this.material]
		};

		this.enabled = true;
		this.clear = false;
		this.needsSwap = true;
		this.viewportSize = undefined;
	}

	FullscreenPass.prototype = Object.create(Pass.prototype);
	FullscreenPass.prototype.constructor = FullscreenPass;

	FullscreenPass.prototype.render = function (renderer, writeBuffer, readBuffer) {
		if (this.useReadBuffer) {
			this.material.setTexture('DIFFUSE_MAP', readBuffer);
		}

		if (this.renderToScreen) {
			renderer.render(this.renderable, FullscreenUtils.camera, [], null, this.clear);
		} else {
			renderer.render(this.renderable, FullscreenUtils.camera, [], writeBuffer, this.clear);
		}
	};

	FullscreenPass.prototype.destroy = function (/* renderer */) {
		this.material.shader.destroy();
	};

	FullscreenPass.prototype.invalidateHandles = function (renderer) {
		renderer.invalidateMaterial(this.renderable.materials[0]);
		renderer.invalidateMeshData(this.renderable.meshData);
	};

	return FullscreenPass;
})(goo.Material,goo.FullscreenUtils,goo.ShaderLib,goo.Pass);
goo.ShadowHandler = (function (
	Capabilities,
	Vector3,
	FullscreenPass,
	Camera,
	Material,
	ShaderLib,
	RenderTarget,
	Vector4,
	PointLight,
	DirectionalLight,
	SpotLight
) {
	'use strict';

	/**
	 * Handles shadow techniques
	 */
	function ShadowHandler() {
		this.depthMaterial = new Material(ShaderLib.lightDepth, 'depthMaterial');
		this.depthMaterial.cullState.cullFace = 'Back';
		this.depthMaterial.fullOverride = true;
		this.fullscreenPass = new FullscreenPass();
		this.downsample = Material.createShader(ShaderLib.downsample, 'downsample');

		var sigma = 2;
		this.blurfilter = Material.createShader(ShaderLib.convolution, 'blurfilter');
		var kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;
		this.blurfilter.defines = {
			KERNEL_SIZE_FLOAT: kernelSize.toFixed(1),
			KERNEL_SIZE_INT: kernelSize.toFixed(0)
		};
		this.blurfilter.uniforms.cKernel = ShaderLib.convolution.buildKernel(sigma);

		this.oldClearColor = new Vector4(0, 0, 0, 0);
		this.shadowClearColor = new Vector4(1, 1, 1, 1);

		this.renderList = [];
		this.shadowList = [];

		this.first = true;
	}

	var tmpVec = new Vector3();

	ShadowHandler.prototype._createShadowData = function (shadowSettings, renderer) {
		var shadowX = shadowSettings.resolution[0];
		var shadowY = shadowSettings.resolution[1];

		var linearFloat = !!Capabilities.TextureFloatLinear;

		if (shadowSettings.shadowData.shadowTarget) {
			renderer._deallocateRenderTarget(shadowSettings.shadowData.shadowTarget);
		}

		shadowSettings.shadowData.shadowTarget = new RenderTarget(shadowX, shadowY, {
				type: 'Float',
				magFilter: 'NearestNeighbor',
				minFilter: 'NearestNeighborNoMipMaps'
			});
		shadowSettings.shadowData.shadowResult = null;

		if (shadowSettings.shadowType === 'VSM') {
			var type = {
				type: 'Float'
			};
			if (!linearFloat) {
				type.magFilter = 'NearestNeighbor';
				type.minFilter = 'NearestNeighborNoMipMaps';
			}
			if (shadowSettings.shadowData.shadowTargetDown) {
				renderer._deallocateRenderTarget(shadowSettings.shadowData.shadowTargetDown);
			}
			shadowSettings.shadowData.shadowTargetDown = new RenderTarget(shadowX / 2, shadowY / 2, type);
			if (shadowSettings.shadowData.shadowBlurred) {
				renderer._deallocateRenderTarget(shadowSettings.shadowData.shadowBlurred);
			}
			shadowSettings.shadowData.shadowBlurred = new RenderTarget(shadowX / 2, shadowY / 2, type);
		}

		shadowSettings.shadowRecord.resolution = shadowSettings.shadowRecord.resolution || [];
		shadowSettings.shadowRecord.resolution[0] = shadowX;
		shadowSettings.shadowRecord.shadowType = shadowSettings.shadowType;
	};

	ShadowHandler.prototype.checkShadowRendering = function (renderer, partitioner, entities, lights) {
		if (this.first === true) {
			this.first = false;
			return;
		}
		for (var i = 0; i < lights.length; i++) {
			var light = lights[i];

			if (light.shadowCaster || light.lightCookie) {
				var shadowSettings = light.shadowSettings;

				if (!shadowSettings.shadowData) {
					shadowSettings.shadowData = {};
					shadowSettings.shadowRecord = {};
					shadowSettings.shadowData.lightCamera = new Camera(55, 1, 1, 1000);
				}

				var record = shadowSettings.shadowRecord;
				var lightCamera = shadowSettings.shadowData.lightCamera;

				// Update transformation
				lightCamera.translation.copy(light.translation);
				if (light.direction) {
					tmpVec.set(light.translation).add(light.direction);
					lightCamera.lookAt(tmpVec, shadowSettings.upVector);
				} else {
					lightCamera.lookAt(Vector3.ZERO, shadowSettings.upVector);
				}

				// Update settings
				if (!shadowSettings.shadowData.shadowTarget ||
					record.angle !== light.angle ||
					!record.resolution ||
					record.resolution[0] !== shadowSettings.resolution[0] ||
					record.resolution[1] !== shadowSettings.resolution[1] ||
					record.near !== shadowSettings.near ||
					record.far !== shadowSettings.far ||
					record.size !== shadowSettings.size
				) {
					if (!record.resolution ||
						record.resolution[0] !== shadowSettings.resolution[0] ||
						record.resolution[1] !== shadowSettings.resolution[1]) {
						this._createShadowData(shadowSettings, renderer);
					}

					if (light instanceof SpotLight) {
						lightCamera.setFrustumPerspective(light.angle, shadowSettings.resolution[0] / shadowSettings.resolution[1], shadowSettings.near, shadowSettings.far);
					} else if (light instanceof PointLight) {
						lightCamera.setFrustumPerspective(90, shadowSettings.resolution[0] / shadowSettings.resolution[1], shadowSettings.near, shadowSettings.far);
					} else {
						var radius = shadowSettings.size;
						lightCamera.setFrustum(shadowSettings.near, shadowSettings.far, -radius, radius, radius, -radius);
						lightCamera.projectionMode = Camera.Parallel;
					}

					lightCamera.update();

					record.resolution = record.resolution || [];
					record.resolution[0] = shadowSettings.resolution[0];
					record.resolution[1] = shadowSettings.resolution[1];
					record.angle = light.angle;
					record.near = shadowSettings.near;
					record.far = shadowSettings.far;
					record.size = shadowSettings.size;
				}

				if (shadowSettings.shadowType === 'VSM' && record.shadowType !== shadowSettings.shadowType) {
					this._createShadowData(shadowSettings, renderer);

					record.shadowType = shadowSettings.shadowType;
				}
				lightCamera.onFrameChange();

				var matrix = lightCamera.getViewProjectionMatrix().data;
				var vpm = shadowSettings.shadowData.vpm = shadowSettings.shadowData.vpm || [];
				for (var j = 0; j < 16; j++) {
					vpm[j] = matrix[j];
				}

				if (light.shadowCaster) {
					this.depthMaterial.shader.setDefine('SHADOW_TYPE', shadowSettings.shadowType === 'VSM' ? 2 : 0);
					this.depthMaterial.uniforms.cameraScale = 1.0 / (lightCamera.far - lightCamera.near);
					shadowSettings.shadowData.cameraScale = this.depthMaterial.uniforms.cameraScale;

					this.oldClearColor.copy(renderer.clearColor);
					renderer.setClearColor(this.shadowClearColor.r, this.shadowClearColor.g, this.shadowClearColor.b, this.shadowClearColor.a);

					this.shadowList.length = 0;
					for (var j = 0; j < entities.length; j++) {
						var entity = entities[j];
						if (entity.meshRendererComponent && entity.meshRendererComponent.castShadows && !entity.isSkybox) {
							this.shadowList.push(entity);
						}
					}
					partitioner.process(lightCamera, this.shadowList, this.renderList);
					renderer.render(this.renderList, lightCamera, [], shadowSettings.shadowData.shadowTarget, true, this.depthMaterial);

					switch (shadowSettings.shadowType) {
					case 'VSM':
						this.fullscreenPass.material.shader = this.downsample;
						this.fullscreenPass.render(renderer, shadowSettings.shadowData.shadowTargetDown, shadowSettings.shadowData.shadowTarget);

						this.fullscreenPass.material.shader = this.blurfilter;
						this.fullscreenPass.material.uniforms.uImageIncrement = [2 / shadowSettings.resolution[0], 0.0];
						this.fullscreenPass.render(renderer, shadowSettings.shadowData.shadowBlurred, shadowSettings.shadowData.shadowTargetDown);
						this.fullscreenPass.material.uniforms.uImageIncrement = [0.0, 2 / shadowSettings.resolution[1]];
						this.fullscreenPass.render(renderer, shadowSettings.shadowData.shadowTargetDown, shadowSettings.shadowData.shadowBlurred);

						shadowSettings.shadowData.shadowResult = shadowSettings.shadowData.shadowTargetDown;
						break;
					case 'PCF':
						shadowSettings.shadowData.shadowResult = shadowSettings.shadowData.shadowTarget;
						break;
					case 'Basic':
						shadowSettings.shadowData.shadowResult = shadowSettings.shadowData.shadowTarget;
						break;
					default:
						shadowSettings.shadowData.shadowResult = shadowSettings.shadowData.shadowTarget;
						break;
					}

					renderer.setClearColor(this.oldClearColor.r, this.oldClearColor.g, this.oldClearColor.b, this.oldClearColor.a);
				}
			}
		}
	};

	ShadowHandler.prototype.invalidateHandles = function (renderer) {
		this.fullscreenPass.invalidateHandles(renderer);
		renderer.invalidateMaterial(this.depthMaterial);
		renderer.invalidateShader(this.downsample);
		renderer.invalidateShader(this.blurfilter);
	};

	return ShadowHandler;
})(goo.Capabilities,goo.Vector3,goo.FullscreenPass,goo.Camera,goo.Material,goo.ShaderLib,goo.RenderTarget,goo.Vector4,goo.PointLight,goo.DirectionalLight,goo.SpotLight);
goo.RenderStats = (function () {
	'use strict';

	function RenderStats() {
		this.reset();
	}

	RenderStats.prototype.reset = function () {
		this.calls = 0;
		this.vertices = 0;
		this.indices = 0;
	};

	RenderStats.prototype.toString = function () {
		return 'Calls: ' + this.calls +
			'<br/>Vertices: ' + this.vertices +
			'<br/>Indices: ' + this.indices;
	};

	return RenderStats;
})();
goo.TaskScheduler = (function (
	PromiseUtils
	) {
	'use strict';

	(function performanceShim() {
		window.performance = window.performance || {};
		performance.now = (function () {
			return performance.now ||
				performance.mozNow ||
				performance.msNow ||
				performance.oNow ||
				performance.webkitNow ||
				function () {
					return Date.now();
				};
		})();
	})();

	function TaskScheduler() {}

	TaskScheduler.maxTimePerFrame = 50;

	// Engine loop must be disabled while running this
	TaskScheduler.each = function (queue) {
		return PromiseUtils.createPromise(function (resolve, reject) {
			var i = 0;

			function process() {
				var startTime = performance.now();
				while (i < queue.length && performance.now() - startTime < TaskScheduler.maxTimePerFrame) {
					queue[i]();
					i++;
				}

				if (i < queue.length) {
					// REVIEW: 4ms is 'lagom'? Should this number be hard-coded?
					//! AT: 4 ms is the minimum amount as specified by the HTML standard
					setTimeout(process, 4);
				} else {
					resolve();
				}
			}

			process();
		});
	};

	return TaskScheduler;
})(goo.PromiseUtils);
goo.RenderInfo = (function (
	Entity,
	Transform
) {

	'use strict';

	/**
	 * Holds configuration data for renderable objects.
	 */

	function RenderInfo() {
		this.reset();

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	/**
	 * Reset for switching renderable
	 */

	RenderInfo.prototype.reset = function () {
		this.renderable = null;
		this.lights = null;
		this.materials = null;
		this.meshData = null;
		this.camera = null;
		this.mainCamera = null;
		this.lights = null;
		this.shadowHandler = null;
		this.renderer = null;
		this.material = null;
		this.transform = null;
		this.currentPose = null;
	};

	/**
	 * Populates data from renderable
	 */

	RenderInfo.prototype.fill = function (renderable) {
		if (renderable instanceof Entity) {
			this.meshData = renderable.meshDataComponent.meshData;
			this.materials = renderable.meshRendererComponent.materials;
			this.transform = renderable.particleComponent ? Transform.IDENTITY : renderable.transformComponent.worldTransform;
			if (renderable.meshDataComponent.currentPose) {
				this.currentPose = renderable.meshDataComponent.currentPose;
			} else {
				this.currentPose = null;
			}
		} else {
			this.meshData = renderable.meshData;
			this.materials = renderable.materials;
			this.transform = renderable.transform;
			if (renderable.currentPose) {
				this.currentPose = renderable.currentPose;
			} else {
				this.currentPose = null;
			}
		}

		this.renderable = renderable;
	};

	return RenderInfo;
})(goo.Entity,goo.Transform);
goo.Renderer = (function (
	Capabilities,
	RendererRecord,
	RendererUtils,
	TextureCreator,
	RenderTarget,
	Vector4,
	Entity,
	Texture,
	DdsLoader,
	DdsUtils,
	Material,
	Transform,
	RenderQueue,
	ShaderLib,
	ShadowHandler,
	RenderStats,
	SystemBus,
	TaskScheduler,
	RenderInfo,
	MathUtils
) {
	'use strict';

	var STUB_METHOD = function () {};

	/**
	 * The renderer handles displaying of graphics data to a render context.
	 * It accepts an object containing the settings for the renderer.
	 *
	 * @param {Object} parameters Renderer settings.
	 * @param {boolean} [parameters.alpha=false] Enables the possibility to render non-opaque pixels.
	 * @param {boolean} [parameters.premultipliedAlpha=true] Whether the colors are premultiplied with the alpha channel.
	 * @param {boolean} [parameters.antialias=true] Enables antialiasing.
	 * @param {boolean} [parameters.stencil=false] Enables the stencil buffer.
	 * @param {boolean} [parameters.preserveDrawingBuffer=false]
	 * @param {boolean} [parameters.useDevicePixelRatio=false] Take into account the device pixel ratio (for retina screens etc).
	 * @param {canvas} [parameters.canvas] If not supplied, Renderer will create a new canvas.
	 * @param {function(string)} [parameters.onError] Called with message when error occurs.
	 */
	function Renderer(parameters) {
		parameters = parameters || {};

		var _canvas = parameters.canvas;
		if (_canvas === undefined) {
			_canvas = document.createElement('canvas');
			_canvas.width = 500;
			_canvas.height = 500;
		}
		_canvas.screencanvas = true; // CocoonJS support
		this.domElement = _canvas;

		this._alpha = parameters.alpha !== undefined ? parameters.alpha : false;
		this._premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true;
		this._antialias = parameters.antialias !== undefined ? parameters.antialias : true;
		this._stencil = parameters.stencil !== undefined ? parameters.stencil : false;
		this._preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
		this._useDevicePixelRatio = parameters.useDevicePixelRatio !== undefined ? parameters.useDevicePixelRatio : false;
		this._onError = parameters.onError;

		this._contextSettings = {
			alpha: this._alpha,
			premultipliedAlpha: this._premultipliedAlpha,
			antialias: this._antialias,
			stencil: this._stencil,
			preserveDrawingBuffer: this._preserveDrawingBuffer
		};

		/** @type {WebGLRenderingContext} */
		this.context = null;
		this.establishContext();

		this._setupContextLost();

		if (parameters.debug) {
			this.setupDebugging(parameters);
		}

		/** @type {RendererRecord} */
		this.rendererRecord = new RendererRecord();

		this.maxTextureSize = !isNaN(parameters.maxTextureSize) ? Math.min(parameters.maxTextureSize, Capabilities.maxTexureSize) : Capabilities.maxTexureSize;
		this.maxCubemapSize = !isNaN(parameters.maxTextureSize) ? Math.min(parameters.maxTextureSize, Capabilities.maxCubemapSize) : Capabilities.maxCubemapSize;

		/** Can be one of: <ul><li>lowp</li><li>mediump</li><li>highp</li></ul>
		 * If the shader doesn't specify a precision, a string declaring this precision will be added.
		 * @type {string}
		 */
		this.shaderPrecision = parameters.shaderPrecision || 'highp';
		if (this.shaderPrecision === 'highp' && Capabilities.vertexShaderHighpFloat.precision > 0 && Capabilities.fragmentShaderHighpFloat.precision > 0) {
			this.shaderPrecision = 'highp';
		} else if (this.shaderPrecision !== 'lowp' && Capabilities.vertexShaderMediumpFloat.precision > 0 && Capabilities.fragmentShaderMediumpFloat.precision > 0) {
			this.shaderPrecision = 'mediump';
		} else {
			this.shaderPrecision = 'lowp';
		}
		//console.log('Shader precision: ' + this.shaderPrecision);

		this.downScale = parameters.downScale || 1;

		//! AT: why are there 2 clear colors?
		// Default setup
		this.clearColor = new Vector4();
		// You need 64 bits for number equality
		this._clearColor = new Vector4();
		this.setClearColor(0.3, 0.3, 0.3, 1.0);


		/** @type {number} */
		this.viewportX = 0;
		/** @type {number} */
		this.viewportY = 0;
		/** @type {number} */
		this.viewportWidth = 0;
		/** @type {number} */
		this.viewportHeight = 0;
		/** @type {number} */
		this.currentWidth = 0;
		/** @type {number} */
		this.currentHeight = 0;
		/**
		 * @type {number}
		 * @readonly
		 */
		this.devicePixelRatio = 1;

		//this.overrideMaterial = null;
		this._overrideMaterials = [];
		this._mergedMaterial = new Material('Merged Material');

		this.renderQueue = new RenderQueue();

		this.info = new RenderStats();

		this.shadowHandler = new ShadowHandler();

		// Hardware picking
		this.hardwarePicking = null;

		SystemBus.addListener('goo.setClearColor', function (color) {
			this.setClearColor.apply(this, color);
		}.bind(this));

		// ---
		//! AT: ugly fix for the resizing style-less canvas to 1 px for desktop
		// apparently this is the only way to find out the user zoom level

		if (document.createElementNS) {
			this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			this.svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
			this.svg.setAttribute('version', '1.1');
			this.svg.style.position = 'absolute';
			this.svg.style.display = 'none';
			document.body.appendChild(this.svg);
		} else {
			//! AT: placeholder to avoid another conditional below in checkResize
			this.svg = { currentScale: 1 };
		}

		// Dan: Since GooRunner.clear() wipes all listeners from SystemBus,
		//      this needs to be re-added here again for each new GooRunner/Renderer
		//      cycle.
		SystemBus.addListener('goo.setCurrentCamera', function (newCam) {
			Renderer.mainCamera = newCam.camera;
			this.checkResize(Renderer.mainCamera);
		}.bind(this));

		this._definesIndices = [];

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	/**
	 *Enables debug mode on the webgl context for easier development.
	 *
	 * @param {Object} parameters
	 * @param {boolean} parameters.validate
	 */
	Renderer.prototype.setupDebugging = function (parameters) {
		// XXX: This is a temporary solution to easily enable webgl debugging during development...
		var request = new XMLHttpRequest();
		request.open('GET', '/js/goo/lib/webgl-debug.js', false);
		request.onreadystatechange = function () {
			if (request.readyState === 4) {
				if (request.status >= 200 && request.status <= 299) {
					// Yes, eval is intended, sorry checkstyle
					// jshint evil:true
					window['eval'].call(window, request.responseText);
				}
			}
		};
		request.send(null);

		if (typeof (window.WebGLDebugUtils) === 'undefined') {
			console.warn('You need to include webgl-debug.js in your script definition to run in debug mode.');
		} else {
			console.log('Running in webgl debug mode.');
			if (parameters.validate) {
				console.log('Running with "undefined arguments" validation.');
				this.context = window.WebGLDebugUtils.makeDebugContext(this.context, this.onDebugError.bind(this), validateNoneOfTheArgsAreUndefined);
			} else {
				this.context = window.WebGLDebugUtils.makeDebugContext(this.context, this.onDebugError.bind(this));
			}
		}
	};

	/**
	 *Fetches a working webgl context element and sets it to the Renderer.
	 *
	 */
	Renderer.prototype.establishContext = function () {
		if (!!window.WebGLRenderingContext) {
			//! AT: this list may require cleanup
			var contextNames = ['experimental-webgl', 'webgl', 'moz-webgl', 'webkit-3d'];
			for (var i = 0; i < contextNames.length; i++) {
				try {
					this.context = this.domElement.getContext(contextNames[i], this._contextSettings);
					if (this.context && typeof this.context.getParameter === 'function') {
						// WebGL is supported & enabled
						break;
					}
				} catch (e) {}
			}
			if (!this.context) {
				// WebGL is supported but disabled
				throw {
					name: 'GooWebGLError',
					message: 'WebGL is supported but disabled',
					supported: true,
					enabled: false
				};
			}
		}

		var context = this.context;

		context.clearDepth(1);
		context.clearStencil(0);
		context.stencilMask(0);

		context.enable(context.DEPTH_TEST);
		context.depthFunc(context.LEQUAL);

		//! AT: is this still necessary?
		if (context.getShaderPrecisionFormat === undefined) {
			this.context.getShaderPrecisionFormat = function () {
				return {
					rangeMin: 1,
					rangeMax: 1,
					precision: 1
				};
			};
		}

		Capabilities.init(this.context);
	};

	/**
	 * Sets up handlers for context lost/restore.
	 * @private
	 */
	Renderer.prototype._setupContextLost = function () {
		this.domElement.addEventListener('webglcontextlost', function (event) {
			event.preventDefault();
			SystemBus.emit('goo.contextLost');
		}, false);

		this.domElement.addEventListener('webglcontextrestored', function () {
			this._restoreContext();
			SystemBus.emit('goo.contextRestored');
		}.bind(this), false);
	};

	/**
	 * Restores the webgl context.
	 * @private
	 */
	Renderer.prototype._restoreContext = STUB_METHOD; // will be overriden

	function validateNoneOfTheArgsAreUndefined(functionName, args) {
		for (var ii = 0; ii < args.length; ++ii) {
			if (args[ii] === undefined) {
				console.error('undefined passed to gl.' + functionName + '('
					+ window.WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ')');
			}
		}
	}

	/**
	 * Outputs the webgl errors with the respective erroring function name and arguments using console.error.
	 * @param {Object} err
	 * @param {string} functionName
	 * @param {Array} args
	 */
	Renderer.prototype.onDebugError = function (err, functionName, args) {
		// Based on the default error handler in WebGLDebugUtils
		// apparently we can't do args.join(',');
		var message = 'WebGL error ' + window.WebGLDebugUtils.glEnumToString(err) + ' in ' + functionName + '(';
		for (var ii = 0; ii < args.length; ++ii) {
			message += ((ii === 0) ? '' : ', ') +
				window.WebGLDebugUtils.glFunctionArgToString(functionName, ii, args[ii]);
		}
		message += ')';
		console.error(message);
		if (this._onError) {
			this._onError(message);
		}
	};

	Renderer.mainCamera = null;

	/**
	 * Checks if this.domElement.offsetWidth or Height / this.downScale is unequal to this.domElement.width or height.
	 * If that is the case it will call this.setSize.
	 * Also checks if the camera aspect changed and updates it by calling camera.setFrustumPerspective().
	 *
	 * @param {Camera} [camera] optional camera argument.
	 */
	Renderer.prototype.checkResize = function (camera) {
		var devicePixelRatio = this.devicePixelRatio = this._useDevicePixelRatio && window.devicePixelRatio ? window.devicePixelRatio / this.svg.currentScale : 1;

		var adjustWidth, adjustHeight;
		if (navigator.isCocoonJS) {
			adjustWidth = window.innerWidth;
			adjustHeight = window.innerHeight;
		} else {
			adjustWidth = this.domElement.offsetWidth;
			adjustHeight = this.domElement.offsetHeight;
		}
		adjustWidth = Math.max(adjustWidth * devicePixelRatio / this.downScale, 1);
		adjustHeight = Math.max(adjustHeight * devicePixelRatio / this.downScale, 1);

		var fullWidth = adjustWidth;
		var fullHeight = adjustHeight;

		if (camera && camera.lockedRatio === true && camera.aspect) {
			adjustWidth = adjustHeight * camera.aspect;
		}

		var aspect = adjustWidth / adjustHeight;
		this.setSize(adjustWidth, adjustHeight, fullWidth, fullHeight);

		if (camera && camera.lockedRatio === false && camera.aspect !== aspect) {
			camera.aspect = aspect;
			if (camera.projectionMode === 0) {
				camera.setFrustumPerspective();
			} else {
				camera.setFrustum();
			}
			camera.onFrameChange();
		}
	};

	/**
	 * Sets this.domElement.width and height using the parameters.
	 * Then it calls this.setViewport(0, 0, width, height);
	 * Finally it resets the hardwarePicking.pickingTarget.
	 *
	 * @param {number} width Aspect ratio corrected width.
	 * @param {number} height Aspect ratio corrected height.
	 * @param {number} [fullWidth] Full viewport width.
	 * @param {number} [fullHeight] Full viewport height.
	 */
	Renderer.prototype.setSize = function (width, height, fullWidth, fullHeight) {
		if (fullWidth === undefined) {
			fullWidth = width;
		}
		if (fullHeight === undefined) {
			fullHeight = height;
		}

		this.domElement.width = fullWidth;
		this.domElement.height = fullHeight;

		if (width > fullWidth) {
			var mult = fullWidth / width;
			width = fullWidth;
			height = fullHeight * mult;
		}

		var w = (fullWidth - width) * 0.5;
		var h = (fullHeight - height) * 0.5;

		if (w !== this.viewportX || h !== this.viewportY ||
			width !== this.viewportWidth || height !== this.viewportHeight) {
			this.setViewport(w, h, width, height);

			if (this.hardwarePicking !== null) {
				this.hardwarePicking.pickingTarget = null;
			}
		}
	};

	/**
	 * Sets this.viewportX and viewportY to the parameters or to 0.
	 * Sets this.viewportWidth and viewportHeight to the parameters or to this.domElement.width and height.
	 * Finally it calls this.context.viewport(x, y, w, h) with the resulting values.
	 * @param {number} [x] optional x coordinate.
	 * @param {number} [y] optional y coordinate.
	 * @param {number} [width] optional width coordinate.
	 * @param {number} [height] optional height coordinate.
	 */
	Renderer.prototype.setViewport = function (x, y, width, height) {
		this.viewportX = x !== undefined ? x : 0;
		this.viewportY = y !== undefined ? y : 0;

		this.viewportWidth = width !== undefined ? width : this.domElement.width;
		this.viewportHeight = height !== undefined ? height : this.domElement.height;

		this.context.viewport(this.viewportX, this.viewportY, this.viewportWidth, this.viewportHeight);

		SystemBus.emit('goo.viewportResize', {
			x: this.viewportX,
			y: this.viewportY,
			width: this.viewportWidth,
			height: this.viewportHeight
		}, true);
	};

	/**
	 * Set the background color of the 3D view. All colors are defined in the range 0.0 - 1.0.
	 *
	 * @param {number} r Red value.
	 * @param {number} g Green value.
	 * @param {number} b Blue value.
	 * @param {number} a Alpha value.
	 */
	Renderer.prototype.setClearColor = function (r, g, b, a) {
		//! AT: is exact equality important here?
		if (this._clearColor.r === r &&
			this._clearColor.g === g &&
			this._clearColor.b === b &&
			this._clearColor.a === a
		) {
			return;
		}

		this._clearColor.r = r;
		this._clearColor.g = g;
		this._clearColor.b = b;
		this._clearColor.a = a;
		this.clearColor.copy(this._clearColor);
		this.context.clearColor(r, g, b, a);
	};

	/**
	 * Binds the given BufferData's buffer, or creates a buffer and bind it if none exist.
	 *
	 * @param {BufferData} bufferData BufferData to bind.
	 */
	Renderer.prototype.bindData = function (bufferData) {
		var glBuffer = bufferData.glBuffer;
		var context = this.context;

		if (glBuffer !== null) {
			this.setBoundBuffer(glBuffer, bufferData.target);
			if (bufferData._dataNeedsRefresh) {
				context.bufferSubData(RendererUtils.getGLBufferTarget(context, bufferData.target), 0, bufferData.data);
				bufferData._dataNeedsRefresh = false;
			}
		} else {
			glBuffer = context.createBuffer();
			bufferData.glBuffer = glBuffer;

			this.rendererRecord.invalidateBuffer(bufferData.target);
			this.setBoundBuffer(glBuffer, bufferData.target);
			context.bufferData(RendererUtils.getGLBufferTarget(context, bufferData.target), bufferData.data, RendererUtils.getGLBufferUsage(context, bufferData._dataUsage));
		}
	};

	/**
	 * Update the data buffer of an attribute at it's offset location.
	 *
	 * @param {ArrayBuffer} attributeData New attribute data buffer.
	 * @param {number} offset The starting location offset to the attribute buffer.
	 */
	Renderer.prototype.updateAttributeData = function (attributeData, offset) {
		this.context.bufferSubData(this.context.ARRAY_BUFFER, offset, attributeData);
	};

	Renderer.prototype.setShadowType = function (type) {
		this.shadowHandler.shadowType = type;
	};

	/**
	 * Update the shadowHandler for the provided entities and lights.
	 *
	 * @param {SimplePartitioner} partitioner The partitioner used to determine what gets to be shadowed.
	 * @param {Array<Entity>} entities Array of all the entities to cast shadows.
	 * @param {Array<Light>} lights Array of all the lights to cast shadows for.
	 */
	Renderer.prototype.updateShadows = function (partitioner, entities, lights) {
		this.shadowHandler.checkShadowRendering(this, partitioner, entities, lights);
	};

	/**
	 * Preloads a texture.
	 *
	 * @param {WebGLRenderingContext} context
	 * @param {Texture} texture
	 */
	Renderer.prototype.preloadTexture = function (context, texture) {
		//! schteppe: Is there any case where we want to preload a texture to another context than this.context?

		// REVIEW: Veeeeery similar to loadTexture. Merge?
		//! AT: the code will diverge; it was initially copy-pasted and adapted to suit the need, but it will have to be iterated on; adding more ifs for different code paths is not gonna make the code nicer

		// this.bindTexture(context, texture, unit, record);
		// context.activeTexture(context.TEXTURE0 + unit); // do I need this?

		//! schteppe: What if the .glTexture is not allocated yet?
		context.bindTexture(RendererUtils.getGLType(context, texture.variant), texture.glTexture);

		// set alignment to support images with width % 4 !== 0, as
		// images are not aligned
		context.pixelStorei(context.UNPACK_ALIGNMENT, texture.unpackAlignment);

		// Using premultiplied alpha
		context.pixelStorei(context.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

		// set if we want to flip on Y
		context.pixelStorei(context.UNPACK_FLIP_Y_WEBGL, texture.flipY);

		// TODO: Check for the restrictions of using npot textures
		// see: http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
		// TODO: Add "usesMipmaps" to check if minfilter has mipmap mode

		var image = texture.image;
		if (texture.variant === '2D') {
			if (!image) {
				context.texImage2D(context.TEXTURE_2D, 0, RendererUtils.getGLInternalFormat(context, texture.format), texture.width, texture.height, 0,
					RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), null);
			} else {
				if (!image.isCompressed && (texture.generateMipmaps || image.width > this.maxTextureSize || image.height > this.maxTextureSize)) {
					this.checkRescale(texture, image, image.width, image.height, this.maxTextureSize);
					image = texture.image;
				}

				if (image.isData === true) {
					if (image.isCompressed) {
						this.loadCompressedTexture(context, context.TEXTURE_2D, texture, image.data);
					} else {
						context.texImage2D(context.TEXTURE_2D, 0, RendererUtils.getGLInternalFormat(context, texture.format), image.width,
							image.height, texture.hasBorder ? 1 : 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image.data);
					}
				} else {
					context.texImage2D(context.TEXTURE_2D, 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image);
				}

				if (texture.generateMipmaps && !image.isCompressed) {
					context.generateMipmap(context.TEXTURE_2D);
				}
			}
		} else if (texture.variant === 'CUBE') {
			if (image && !image.isData && (texture.generateMipmaps || image.width > this.maxCubemapSize || image.height > this.maxCubemapSize)) {
				for (var i = 0; i < Texture.CUBE_FACES.length; i++) {
					if (image.data[i] && !image.data[i].buffer ) {
						RendererUtils.scaleImage(texture, image.data[i], image.width, image.height, this.maxCubemapSize, i);
					} else {
						// REVIEW: Hard coded background color that should be determined by Create?
						RendererUtils.getBlankImage(texture, [0.3, 0.3, 0.3, 0], image.width, image.height, this.maxCubemapSize, i);
					}
				}
				texture.image.width = Math.min(this.maxCubemapSize, MathUtils.nearestPowerOfTwo(texture.image.width));
				texture.image.height = Math.min(this.maxCubemapSize, MathUtils.nearestPowerOfTwo(texture.image.height));
				image = texture.image;
			}

			for (var faceIndex = 0; faceIndex < Texture.CUBE_FACES.length; faceIndex++) {
				var face = Texture.CUBE_FACES[faceIndex];

				if (!image) {
					context.texImage2D(RendererUtils.getGLCubeMapFace(context, face), 0, RendererUtils.getGLInternalFormat(context, texture.format), texture.width, texture.height, 0,
						RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), null);
				} else {
					if (image.isData === true) {
						if (image.isCompressed) {
							this.loadCompressedTexture(context, RendererUtils.getGLCubeMapFace(context, face), texture, image.data[faceIndex]);
						} else {
							context.texImage2D(RendererUtils.getGLCubeMapFace(context, face), 0, RendererUtils.getGLInternalFormat(context, texture.format), image.width,
								image.height, texture.hasBorder ? 1 : 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image.data[faceIndex]);
						}
					} else {
						context.texImage2D(RendererUtils.getGLCubeMapFace(context, face), 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image.data[faceIndex]);
					}
				}
			}

			if (image && texture.generateMipmaps && !image.isCompressed) {
				context.generateMipmap(context.TEXTURE_CUBE_MAP);
			}
		}
	};

	/**
	 * Preloads the textures of a material.
	 *
	 * @private
	 * @param {Material} material
	 * @param {Array} queue
	 */
	Renderer.prototype.preloadTextures = function (material, queue) {
		var context = this.context;
		var textureKeys = Object.keys(material._textureMaps);

		// for (var i = 0; i < textureKeys.length; i++) {
		// gotta simulate lexical scoping
		textureKeys.forEach(function (textureKey) {
			var texture = material.getTexture(textureKey);

			if (texture === undefined) {
				return;
			}

			var textureList = texture;
			if (texture instanceof Array === false) {
				textureList = [texture];
			}

			// for (var j = 0; j < textureList.length; j++) {
			// gotta simulate lexical scoping
			textureList.forEach(function (texture) {
				if (!texture) { return; }
				queue.push(function () {
					if (texture instanceof RenderTarget === false &&
						(texture.image === undefined || texture.checkDataReady() === false)
					) {
						if (texture.variant === '2D') {
							texture = TextureCreator.DEFAULT_TEXTURE_2D;
						} else if (texture.variant === 'CUBE') {
							texture = TextureCreator.DEFAULT_TEXTURE_CUBE;
						}
					}

					if (texture.glTexture === null) {
						texture.glTexture = context.createTexture();
						this.preloadTexture(context, texture);
						texture.needsUpdate = false;
					} else if (texture instanceof Texture && texture.checkNeedsUpdate()) {
						this.preloadTexture(context, texture);
						texture.needsUpdate = false;
					}
				}.bind(this));
			}, this);
		}, this);
	};

	var preloadMaterialsRenderInfo = new RenderInfo();

	/**
	 * Preloads textures that come with the materials on the supplied "renderables".
	 *
	 * @param {Array} renderList An array of all the "renderables".
	 * @returns {RSVP.Promise}
	 */
	Renderer.prototype.preloadMaterials = function (renderList) {
		var queue = [];
		var renderInfo = preloadMaterialsRenderInfo;
		renderInfo.reset();

		if (Array.isArray(renderList)) {
			for (var i = 0; i < renderList.length; i++) {
				var renderable = renderList[i];
				if (renderable.isSkybox && this._overrideMaterials.length > 0) {
					continue;
				}

				// this function does so much more than I need it to do
				// I only need the material of the renderable
				renderInfo.fill(renderable);

				for (var j = 0; j < renderInfo.materials.length; j++) {
					this.preloadTextures(renderInfo.materials[j], queue);
				}
			}
		} else {
			renderInfo.fill(renderList);
			for (var j = 0; j < renderInfo.materials.length; j++) {
				this.preloadTextures(renderInfo.materials[j], queue);
			}
		}

		return TaskScheduler.each(queue);
	};

	/**
	 * Preprocesses a shader and compiles it.
	 *
	 * @private
	 * @param {Material} material
	 * @param {RenderInfo} renderInfo
	 */
	Renderer.prototype.precompileShader = function (material, renderInfo) {
		var shader = material.shader;

		shader.updateProcessors(renderInfo);
		this.findOrCacheMaterialShader(material, renderInfo);
		shader = material.shader;
		shader.precompile(this);
	};

	/**
	 * Remove all shaders from cache.
	 */
	Renderer.prototype.clearShaderCache = function () {
		this.rendererRecord.shaderCache.clear();
	};

	/**
	 * Precompiles shaders of the supplied "renderables".
	 *
	 * @param {Array} renderList An array of all the "renderables".
	 * @param {Array<Light>} lights
	 */
	Renderer.prototype.precompileShaders = function (renderList, lights) {
		var renderInfo = new RenderInfo();

		if (lights) {
			renderInfo.lights = lights;
		}

		var queue = [];

		if (Array.isArray(renderList)) {
			for (var i = 0; i < renderList.length; i++) {
				var renderable = renderList[i];
				if (renderable.isSkybox && this._overrideMaterials.length > 0) {
					continue;
				}
				renderInfo.fill(renderable);

				for (var j = 0; j < renderInfo.materials.length; j++) {
					renderInfo.material = renderInfo.materials[j];
					this.precompileShader(renderInfo.materials[j], renderInfo, queue);
				}
			}
		} else {
			renderInfo.fill(renderList);
			for (var j = 0; j < renderInfo.materials.length; j++) {
				renderInfo.material = renderInfo.materials[j];
				this.precompileShader(renderInfo.materials[j], renderInfo, queue);
			}
		}

		return TaskScheduler.each(queue);
	};

	//! MF: This method appears to be unused, and it's way of using renderInfo.fill might be questionable.
	/**
	 * Creates buffers of the supplied renderList.
	 *
	 * @hidden
	 * @param {Array} renderList An array of "renderables".
	 */
	Renderer.prototype.preloadBuffers = function (renderList) {
		var renderInfo = new RenderInfo();

		if (Array.isArray(renderList)) {
			for (var i = 0; i < renderList.length; i++) {
				var renderable = renderList[i];
				if (renderable.isSkybox && this._overrideMaterials.length > 0) {
					continue;
				}
				renderInfo.fill(renderable);
				for (var j = 0; j < renderInfo.materials.length; j++) {
					renderInfo.material = renderInfo.materials[j];
					this.preloadBuffer(renderable, renderInfo.materials[j], renderInfo);
				}
			}
		} else {
			renderInfo.fill(renderList);
			for (var j = 0; j < renderInfo.materials.length; j++) {
				renderInfo.material = renderInfo.materials[j];
				this.preloadBuffer(renderList, renderInfo.materials[j], renderInfo);
			}
		}
	};

	/**
	 * Creates buffers of the supplied "renderables".
	 *
	 * @hidden
	 * @param {Array} renderables
	 * @param {Material} material
	 * @param {RenderInfo} renderInfo
	 */
	Renderer.prototype.preloadBuffer = function (renderables, material, renderInfo) {
		var meshData = renderInfo.meshData;
		if (meshData.vertexData === null || meshData.vertexData !== null && meshData.vertexData.data.byteLength === 0 || meshData.indexData !== null
			&& meshData.indexData.data.byteLength === 0) {
			return;
		}
		this.bindData(meshData.vertexData);
		if (meshData.getIndexBuffer() !== null) {
			this.bindData(meshData.getIndexData());
		}

		var materials = renderInfo.materials;
		var flatOrWire = null;
		var originalData = meshData;

		var count;
		if (this._overrideMaterials.length === 0) {
			count = materials.length;
		} else {
			count = this._overrideMaterials.length;
		}

		for (var i = 0; i < count; i++) {
			var material = null, orMaterial = null;

			if (i < materials.length) {
				material = materials[i];
			}
			if (i < this._overrideMaterials.length) {
				orMaterial = this._overrideMaterials[i];
			}

			if (material && orMaterial) {
				this._override(orMaterial, material, this._mergedMaterial);
				material = this._mergedMaterial;
			} else if (orMaterial) {
				material = orMaterial;
			}

			if (!material.shader) {
				if (!material.errorOnce) {
					console.warn('No shader set on material: ' + material.name);
					material.errorOnce = true;
				}
				continue;
			} else {
				material.errorOnce = false;
			}

			if (material.wireframe && flatOrWire !== 'wire') {
				if (!meshData.wireframeData) {
					meshData.wireframeData = meshData.buildWireframeData();
				}
				meshData = meshData.wireframeData;
				this.bindData(meshData.vertexData);
				flatOrWire = 'wire';
			} else if (material.flat && flatOrWire !== 'flat') {
				if (!meshData.flatMeshData) {
					meshData.flatMeshData = meshData.buildFlatMeshData();
				}
				meshData = meshData.flatMeshData;
				this.bindData(meshData.vertexData);
				flatOrWire = 'flat';
			} else if (!material.wireframe && !material.flat && flatOrWire !== null) {
				meshData = originalData;
				this.bindData(meshData.vertexData);
				flatOrWire = null;
			}
		}
	};

	var renderRenderInfo = new RenderInfo();

	var startEachShaderFrame = function (shader) {
		shader.startFrame();
	};

	/**
	 * Renders a "renderable" or a list of renderables. Handles all setup and updates of materials/shaders and states.
	 * @param {Array<Entity>} renderList A list of "renderables". Eg Entities with the right components or objects with mesh data, material and transform.
	 * @param {Camera} camera Main camera for rendering.
	 * @param {Array<Light>} lights Lights used in the rendering.
	 * @param {RenderTarget} [renderTarget=null] Optional rendertarget to use as target for rendering, or null to render to the screen.
	 * @param {(boolean|Object)} [clear=false] true/false to clear or not clear all types, or an object in the form <code>{color:true/false, depth:true/false, stencil:true/false}</code>
	 * @param {Array<Material>} [overrideMaterials] Optional list of materials to override the renderList materials.
	 */
	Renderer.prototype.render = function (renderList, camera, lights, renderTarget, clear, overrideMaterials) {
		if (overrideMaterials) {
			this._overrideMaterials = (overrideMaterials instanceof Array) ? overrideMaterials : [overrideMaterials];
		} else {
			this._overrideMaterials = [];
		}
		if (!camera) {
			return;
		} else if (Renderer.mainCamera === null && !renderTarget) {
			Renderer.mainCamera = camera;
		}

		this.setRenderTarget(renderTarget);

		if (clear === undefined || clear === null || clear === true) {
			this.clear();
		} else if (typeof clear === 'object') {
			this.clear(clear.color, clear.depth, clear.stencil);
		}

		this.rendererRecord.shaderCache.forEach(startEachShaderFrame);

		var renderInfo = renderRenderInfo;
		renderInfo.reset();
		renderInfo.camera = camera;
		renderInfo.mainCamera = Renderer.mainCamera;
		renderInfo.lights = lights;
		renderInfo.shadowHandler = this.shadowHandler;
		renderInfo.renderer = this;

		if (Array.isArray(renderList)) {
			this.renderQueue.sort(renderList, camera);

			for (var i = 0; i < renderList.length; i++) {
				var renderable = renderList[i];
				if (renderable.isSkybox && this._overrideMaterials.length > 0) {
					continue;
				}
				renderInfo.fill(renderable);
				this.renderMesh(renderInfo);
			}
		} else {
			renderInfo.fill(renderList);
			this.renderMesh(renderInfo);
		}

		// TODO: shouldnt we check for generateMipmaps setting on rendertarget?
		if (
			renderTarget &&
			renderTarget.generateMipmaps &&
			MathUtils.isPowerOfTwo(renderTarget.width) &&
			MathUtils.isPowerOfTwo(renderTarget.height)
		) {
			this.updateRenderTargetMipmap(renderTarget);
		}
	};

	/*
	REVIEW:
	+ it is not called from anywhere outside of the renderer and it probably is not of public interest so it should be private
	+ moreover it does not change `this` in any way nor does it need to belong to instances of Renderer - it can be only a helper function
	+ it could also use a description of what it's supposed to do
	 */
	/**
	 * Fills the store parameter with the combined properties of mat1 and mat2.
	 *
	 * @param {Material} mat1
	 * @param {Material} mat2
	 * @param {Material} store
	 */
	Renderer.prototype._override = function (mat1, mat2, store) {
		store.empty();
		var keys = Object.keys(store);
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];

			var storeVal = store[key];
			var mat1Val = mat1[key];
			var mat2Val = mat2[key];
			if (storeVal instanceof Object && key !== 'shader') {
				var matkeys = Object.keys(mat1Val);
				for (var j = 0, l2 = matkeys.length; j < l2; j++) {
					var prop = matkeys[j];
					storeVal[prop] = mat1Val[prop];
				}
				var matkeys = Object.keys(mat2Val);
				for (var j = 0, l2 = matkeys.length; j < l2; j++) {
					var prop = matkeys[j];
					if (storeVal[prop] === undefined) {
						storeVal[prop] = mat2Val[prop];
					}
				}
			} else {
				if (mat1Val !== undefined) {
					store[key] = mat1Val;
				} else {
					store[key] = mat2Val;
				}
			}
		}
	};

	/**
	 * Renders a mesh from a RenderInfo.
	 *
	 * @param {RenderInfo} renderInfo
	 */
	Renderer.prototype.renderMesh = function (renderInfo) {
		var meshData = renderInfo.meshData;
		if (!meshData || meshData.vertexData === null || meshData.vertexData !== null && meshData.vertexData.data.byteLength === 0 || meshData.indexData !== null
			&& meshData.indexData.data.byteLength === 0) {
			return;
		}

		this.bindData(meshData.vertexData);

		if (meshData._attributeDataNeedsRefresh) {
			meshData._dirtyAttributeNames.forEach(function (name) {
				this.updateAttributeData(meshData.dataViews[name], meshData.attributeMap[name].offset);
			}, this);

			meshData._attributeDataNeedsRefresh = false;
			meshData._dirtyAttributeNames.clear();
		}

		var materials = renderInfo.materials;

		/*if (this.overrideMaterial !== null) {
			materials = this.overrideMaterial instanceof Array ? this.overrideMaterial : [this.overrideMaterial];
		}*/

		var flatOrWire = null;
		var originalData = meshData;

		// number of materials to render - own materials or overriding materials
		var count = 0;
		if (this._overrideMaterials.length === 0) {
			count = materials.length;
		} else {
			count = this._overrideMaterials.length;
		}

		for (var i = 0; i < count; i++) {
			this.renderMeshMaterial(i, materials, flatOrWire, originalData, renderInfo);
		}
	};

	/**
	 * Call the shader processors of the given material and update material cache.
	 *
	 * @param {Material} material
	 * @param {RenderInfo} renderInfo
	 */
	Renderer.prototype.callShaderProcessors = function (material, renderInfo) {
		// Check for caching of shader that use defines
		material.shader.updateProcessors(renderInfo);
		this.findOrCacheMaterialShader(material, renderInfo);
	};

	/**
	 * Render a material with the given parameters.
	 *
	 * @param {number} materialIndex
	 * @param {Array<Material>} materials
	 * @param {boolean} flatOrWire
	 * @param {MeshData} originalData
	 * @param {RenderInfo} renderInfo
	 */
	Renderer.prototype.renderMeshMaterial = function (materialIndex, materials, flatOrWire, originalData, renderInfo) {
		var material = null, orMaterial = null;

		if (materialIndex < materials.length) {
			material = materials[materialIndex];
		}
		if (materialIndex < this._overrideMaterials.length) {
			orMaterial = this._overrideMaterials[materialIndex];
		}

		material = this.configureRenderInfo(renderInfo, materialIndex, material, orMaterial, originalData, flatOrWire);
		var meshData = renderInfo.meshData;

		this.callShaderProcessors(material, renderInfo);

		material.shader.apply(renderInfo, this);

		this.updateDepthTest(material);
		this.updateCulling(material);
		this.updateBlending(material);
		this.updateOffset(material);
		this.updateTextures(material);

		this.updateLineAndPointSettings(material);

		this._checkDualTransparency(material, meshData);

		this.updateCulling(material);
		this._drawBuffers(meshData);

		this.info.calls++;
		this.info.vertices += meshData.vertexCount;
		this.info.indices += meshData.indexCount;
	};

	/**
	 * Draw the buffers of a MeshData using the specified index-mode.
	 *
	 * @param {MeshData} meshData
	 */
	Renderer.prototype._drawBuffers = function (meshData) {
		if (meshData.getIndexBuffer() !== null) {
			this.bindData(meshData.getIndexData());
			if (meshData.getIndexLengths() !== null) {
				this.drawElementsVBO(meshData.getIndexBuffer(), meshData.getIndexModes(), meshData.getIndexLengths());
			} else {
				this.drawElementsVBO(meshData.getIndexBuffer(), meshData.getIndexModes(), [meshData.getIndexBuffer().length]);
			}
		} else {
			if (meshData.getIndexLengths() !== null) {
				this.drawArraysVBO(meshData.getIndexModes(), meshData.getIndexLengths());
			} else {
				this.drawArraysVBO(meshData.getIndexModes(), [meshData.vertexCount]);
			}
		}
	};

	/**
	 * Decides which MeshData and Material to set on the renderInfo parameter object, also returns the specified material.
	 *
	 * @param {RenderInfo} renderInfo
	 * @param {number} materialIndex
	 * @param {Material} material
	 * @param {Material} orMaterial
	 * @param {MeshData} originalData
	 * @param {string} flatOrWire Can be one of 'flat' or 'wire'
	 * @returns {Material}
	 */
	Renderer.prototype.configureRenderInfo = function (renderInfo, materialIndex, material, orMaterial, originalData, flatOrWire) {
		var meshData = renderInfo.meshData;
		if (materialIndex < this._overrideMaterials.length) {
			orMaterial = this._overrideMaterials[materialIndex];
		}

		if (material && orMaterial && orMaterial.fullOverride !== true) {
			this._override(orMaterial, material, this._mergedMaterial);
			material = this._mergedMaterial;
		} else if (orMaterial) {
			material = orMaterial;
		}

		if (!material.shader) {
			if (!material.errorOnce) {
				console.warn('No shader set on material: ' + material.name);
				material.errorOnce = true;
			}
			return;
		} else {
			material.errorOnce = false;
		}

		if (material.wireframe && flatOrWire !== 'wire') {
			if (!meshData.wireframeData) {
				meshData.wireframeData = meshData.buildWireframeData();
			}
			meshData = meshData.wireframeData;
			this.bindData(meshData.vertexData);
			flatOrWire = 'wire';
		} else if (material.flat && flatOrWire !== 'flat') {
			if (!meshData.flatMeshData) {
				meshData.flatMeshData = meshData.buildFlatMeshData();
			}
			meshData = meshData.flatMeshData;
			this.bindData(meshData.vertexData);
			flatOrWire = 'flat';
		} else if (!material.wireframe && !material.flat && flatOrWire !== null) {
			meshData = originalData;
			this.bindData(meshData.vertexData);
			flatOrWire = null;
		}


		renderInfo.material = material;
		renderInfo.meshData = meshData;
		return material;
	};

	/**
	 * Finds shader of the material in the cache, or add it to the cache if not added yet. Then update the uniforms to the cached shader.
	 *
	 * @param {Material} material
	 * @param {RenderInfo} renderInfo
	 */
	Renderer.prototype.findOrCacheMaterialShader = function (material, renderInfo) {
		// check defines. if no hit in cache -> add to cache. if hit in cache,
		// replace with cache version and copy over uniforms.

		var shader = material.shader;
		var defineKey = shader.getDefineKey(this._definesIndices);
		shader.endFrame();

		var shaderCache = this.rendererRecord.shaderCache;
		var cachedShader = shaderCache.get(defineKey);
	
		// Check if the shader cache is invalid
		if (cachedShader && cachedShader.defineKey !== defineKey) {
			shaderCache.delete(defineKey);
			cachedShader = undefined;
		}

		if (cachedShader) {
			if (cachedShader !== material.shader) {
				var uniforms = material.shader.uniforms;
				var keys = Object.keys(uniforms);
				for (var i = 0, l = keys.length; i < l; i++) {
					var key = keys[i];
					var origUniform = cachedShader.uniforms[key] = uniforms[key];
					if (origUniform instanceof Array) {
						cachedShader.uniforms[key] = origUniform.slice(0);
					}
				}
			}
			material.shader = cachedShader;
		} else {
			if (shader.builder) {
				shader.builder(shader, renderInfo);
			}
			shader = shader.clone();
			shaderCache.set(defineKey, shader);
			material.shader = shader;
		}
	};

	/**
	 * Checks a material for dualTransparency and if enabled, draws the MeshData buffers again with inverse cullFace.
	 *
	 * @param {Material} material
	 * @param {MeshData} meshData
	 */
	Renderer.prototype._checkDualTransparency = function (material, meshData) {
		if (material.dualTransparency) {
			var savedCullFace = material.cullState.cullFace;
			var newCullFace = savedCullFace === 'Front' ? 'Back' : 'Front';
			material.cullState.cullFace = newCullFace;

			this.updateCulling(material);
			this._drawBuffers(meshData);

			material.cullState.cullFace = savedCullFace;
		}
	};

	/**
	 * Read pixels from current framebuffer to a typed array (ArrayBufferView).
	 *
	 * @param {number} x x offset of rectangle to read from.
	 * @param {number} y y offset of rectangle to read from.
	 * @param {number} width width of rectangle to read from.
	 * @param {number} height height of rectangle to read from.
	 * @param {ArrayBufferView} store ArrayBufferView to store data in (Uint8Array).
	 */
	Renderer.prototype.readPixels = function (x, y, width, height, store) {
		store = store || new Uint8Array(width * height * 4);
		var context = this.context;
		context.readPixels(x, y, width, height, context.RGBA, context.UNSIGNED_BYTE, store);
		return store;
	};

	/**
	 * Read pixels from a texture to a typed array (ArrayBufferView).
	 *
	 * @param {Texture} texture texture to read pixels from.
	 * @param {number} x x offset of rectangle to read from.
	 * @param {number} y y offset of rectangle to read from.
	 * @param {number} width width of rectangle to read from.
	 * @param {number} height height of rectangle to read from.
	 * @param {ArrayBufferView} store ArrayBufferView to store data in (Uint8Array).
	 */
	Renderer.prototype.readTexturePixels = function (texture, x, y, width, height, store) {
		store = store || new Uint8Array(width * height * 4);
		var context = this.context;
		var glFrameBuffer = context.createFramebuffer();
		context.bindFramebuffer(context.FRAMEBUFFER, glFrameBuffer);
		context.framebufferTexture2D(context.FRAMEBUFFER, context.COLOR_ATTACHMENT0,
			context.TEXTURE_2D, texture.glTexture, 0);
		if (context.checkFramebufferStatus(context.FRAMEBUFFER) === context.FRAMEBUFFER_COMPLETE) {
			context.readPixels(x, y, width, height, context.RGBA, context.UNSIGNED_BYTE, store);
		}
		return store;
	};

	/**
	 * Draws a vertex buffer object (VBO) using drawElements.
	 *
	 * @param {BufferData} indices The index-buffer.
	 * @param {Array<string>} indexModes Array of index-modes.
	 * @param {Array<number>} indexLengths Array of index-counts per index-mode.
	 */
	Renderer.prototype.drawElementsVBO = function (indices, indexModes, indexLengths) {
		var offset = 0;
		var indexModeCounter = 0;
		var type = indices.type = indices.type || RendererUtils.getGLArrayType(this.context, indices);
		var byteSize = RendererUtils.getGLByteSize(indices);

		for (var i = 0; i < indexLengths.length; i++) {
			var count = indexLengths[i];
			var glIndexMode = RendererUtils.getGLIndexMode(this.context, indexModes[indexModeCounter]);

			this.context.drawElements(glIndexMode, count, type, offset * byteSize);

			offset += count;

			if (indexModeCounter < indexModes.length - 1) {
				indexModeCounter++;
			}
		}
	};

	/**
	 * Draws a vertex buffer object (VBO) using drawArrays.
	 *
	 * @param {Array<string>} indexModes Array of index-modes.
	 * @param {Array<number>} indexLengths Array of index-counts per index-mode.
	 */
	Renderer.prototype.drawArraysVBO = function (indexModes, indexLengths) {
		var offset = 0;
		var indexModeCounter = 0;

		for (var i = 0; i < indexLengths.length; i++) {
			var count = indexLengths[i];
			var glIndexMode = RendererUtils.getGLIndexMode(this.context, indexModes[indexModeCounter]);

			this.context.drawArrays(glIndexMode, offset, count);

			offset += count;

			if (indexModeCounter < indexModes.length - 1) {
				indexModeCounter++;
			}
		}
	};

	/**
	 * Render entities to be used with the Renderer.pick.
	 *
	 * @param {Array<Entity>} renderList A list of "renderables". Eg Entities with the right components or objects with mesh data, material and transform.
	 * @param {Camera} camera Main camera for rendering to pick.
	 * @param {(boolean|Object)} [clear=false] true/false to clear or not clear all types, or an object in the form <code>{color:true/false, depth:true/false, stencil:true/false}</code>
	 * @param {boolean} skipUpdateBuffer
	 * @param {boolean} doScissor
	 * @param {number} clientX scissor position X.
	 * @param {number} clientY scissor position Y.
	 * @param {Material} customPickingMaterial Custom picking material.
	 * @param {boolean} skipOverride
	 */
	Renderer.prototype.renderToPick = function (renderList, camera, clear, skipUpdateBuffer, doScissor, clientX, clientY, customPickingMaterial, skipOverride) {
		if (this.viewportWidth * this.viewportHeight === 0) {
			return;
		}
		var pickingResolutionDivider = 4;
		if (this.hardwarePicking === null) {
			var pickingMaterial = Material.createEmptyMaterial(ShaderLib.pickingShader, 'pickingMaterial');
			pickingMaterial.blendState = {
				blending: 'NoBlending',
				blendEquation: 'AddEquation',
				blendSrc: 'SrcAlphaFactor',
				blendDst: 'OneMinusSrcAlphaFactor'
			};
			pickingMaterial.wireframe = false;

			this.hardwarePicking = {
				pickingTarget: new RenderTarget(this.viewportWidth / pickingResolutionDivider, this.viewportHeight / pickingResolutionDivider, {
					minFilter: 'NearestNeighborNoMipMaps',
					magFilter: 'NearestNeighbor'
				}),
				pickingMaterial: pickingMaterial,
				pickingBuffer: new Uint8Array(4),
				clearColorStore: new Vector4()
			};
			skipUpdateBuffer = false;
		} else if (this.hardwarePicking.pickingTarget === null) {
			this.hardwarePicking.pickingTarget = new RenderTarget(this.viewportWidth / pickingResolutionDivider, this.viewportHeight / pickingResolutionDivider, {
					minFilter: 'NearestNeighborNoMipMaps',
					magFilter: 'NearestNeighbor'
				});
			skipUpdateBuffer = false;
		}

		if (!skipUpdateBuffer) {
			this.hardwarePicking.clearColorStore.set(this.clearColor);
			if (doScissor && clientX !== undefined && clientY !== undefined) {
				var devicePixelRatio = this._useDevicePixelRatio && window.devicePixelRatio ? window.devicePixelRatio / this.svg.currentScale : 1;

				var x = Math.floor((clientX * devicePixelRatio - this.viewportX) / pickingResolutionDivider);
				var y = Math.floor((this.viewportHeight - (clientY * devicePixelRatio - this.viewportY)) / pickingResolutionDivider);
				this.context.enable(this.context.SCISSOR_TEST);
				this.context.scissor(x, y, 1, 1);
			}

			var pickList = [];
			for (var i = 0, l = renderList.length; i < l; i++) {
				var entity = renderList[i];
				if (!entity.meshRendererComponent || entity.meshRendererComponent.isPickable) {
					pickList.push(entity);
				}
			}

			if (skipOverride) {
				this.render(pickList, camera, [], this.hardwarePicking.pickingTarget, clear);
			} else {
				this.render(pickList, camera, [], this.hardwarePicking.pickingTarget, clear, customPickingMaterial || this.hardwarePicking.pickingMaterial);
			}

			if (doScissor) {
				this.context.disable(this.context.SCISSOR_TEST);
			}
		} else {
			this.setRenderTarget(this.hardwarePicking.pickingTarget);
		}
	};

	/**
	 * Determine what entity ID is at a specific pixel of the camera.
	 *
	 * @param {number} clientX pixel position X to pick at.
	 * @param {number} clientY pixel position Y to pick at.
	 * @param {Object} pickingStore An object with variables 'id' and 'depth' to be populated by the function.
	 * @param {Camera} camera Same camera that was used with Renderer.renderToPick.
	 */
	Renderer.prototype.pick = function (clientX, clientY, pickingStore, camera) {
		if (this.viewportWidth * this.viewportHeight === 0) {
			pickingStore.id = -1;
			pickingStore.depth = 0;
			return;
		}
		var devicePixelRatio = this._useDevicePixelRatio && window.devicePixelRatio ? window.devicePixelRatio / this.svg.currentScale : 1;

		var pickingResolutionDivider = 4;
		var x = Math.floor((clientX * devicePixelRatio - this.viewportX) / pickingResolutionDivider);
		var y = Math.floor((this.viewportHeight - (clientY * devicePixelRatio - this.viewportY)) / pickingResolutionDivider);

		this.readPixels(x, y, 1, 1, this.hardwarePicking.pickingBuffer);

		var id = this.hardwarePicking.pickingBuffer[0] * 255.0 + this.hardwarePicking.pickingBuffer[1] - 1;
		var depth = (this.hardwarePicking.pickingBuffer[2] / 255.0 + (this.hardwarePicking.pickingBuffer[3] / (255.0 * 255.0))) * camera.far;
		pickingStore.id = id;
		pickingStore.depth = depth;
	};

	/**
	 * Update the webgl contexts line and point settings.
	 *
	 * @param {Material} material
	 */
	Renderer.prototype.updateLineAndPointSettings = function (material) {
		var record = this.rendererRecord.lineRecord;
		var lineWidth = material.lineWidth || 1;

		if (record.lineWidth !== lineWidth) {
			this.context.lineWidth(lineWidth);
			record.lineWidth = lineWidth;
		}
	};

	/**
	 * Update the webgl contexts depth test settings.
	 *
	 * @param {Material} material
	 */
	Renderer.prototype.updateDepthTest = function (material) {
		var record = this.rendererRecord.depthRecord;
		var depthState = material.depthState;

		if (record.enabled !== depthState.enabled) {
			if (depthState.enabled) {
				this.context.enable(this.context.DEPTH_TEST);
			} else {
				this.context.disable(this.context.DEPTH_TEST);
			}
			record.enabled = depthState.enabled;
		}
		if (record.write !== depthState.write) {
			if (depthState.write) {
				this.context.depthMask(true);
			} else {
				this.context.depthMask(false);
			}
			record.write = depthState.write;
		}
		// this.context.depthFunc(this.context.LEQUAL);
	};

	/**
	 * Update the webgl contexts culling settings.
	 *
	 * @param {Material} material
	 */
	Renderer.prototype.updateCulling = function (material) {
		var record = this.rendererRecord.cullRecord;
		var cullFace = material.cullState.cullFace;
		var frontFace = material.cullState.frontFace;
		var enabled = material.cullState.enabled;

		if (record.enabled !== enabled) {
			if (enabled) {
				this.context.enable(this.context.CULL_FACE);
			} else {
				this.context.disable(this.context.CULL_FACE);
			}
			record.enabled = enabled;
		}

		if (record.cullFace !== cullFace) {
			var glCullFace = cullFace === 'Front' ? this.context.FRONT : cullFace === 'Back' ? this.context.BACK
				: this.context.FRONT_AND_BACK;
			this.context.cullFace(glCullFace);
			record.cullFace = cullFace;
		}

		if (record.frontFace !== frontFace) {
			switch (frontFace) {
				case 'CCW':
					this.context.frontFace(this.context.CCW);
					break;
				case 'CW':
					this.context.frontFace(this.context.CW);
					break;
			}
			record.frontFace = frontFace;
		}
	};

	/**
	 * Update the webgl contexts settings concerning textures.
	 * updates the material textures if necessary.
	 *
	 * @param {Material} material
	 */
	Renderer.prototype.updateTextures = function (material) {
		var context = this.context;
		var textureSlots = material.shader.textureSlots;

		for (var i = 0; i < textureSlots.length; i++) {
			var textureSlot = textureSlots[i];
			var texture = material.getTexture(textureSlot.mapping);

			if (texture === undefined) {
				continue;
			}

			var textureList = texture;
			if (texture instanceof Array === false) {
				textureList = [texture];
			}

			for (var j = 0; j < textureList.length; j++) {
				texture = textureList[j];

				var texIndex = textureSlot.index instanceof Array ? textureSlot.index[j] : textureSlot.index;

				if (texture === null || texture instanceof RenderTarget && texture.glTexture === null ||
					texture instanceof RenderTarget === false && (texture.image === undefined ||
						texture.checkDataReady() === false)) {
					if (textureSlot.format === 'sampler2D') {
						texture = TextureCreator.DEFAULT_TEXTURE_2D;
					} else if (textureSlot.format === 'samplerCube') {
						texture = TextureCreator.DEFAULT_TEXTURE_CUBE;
					}
				}

				var unitrecord = this.rendererRecord.textureRecord[texIndex];
				if (unitrecord === undefined) {
					unitrecord = this.rendererRecord.textureRecord[texIndex] = {};
				}

				if (texture.glTexture === null) {
					texture.glTexture = context.createTexture();
					this.updateTexture(context, texture, texIndex, unitrecord);
					texture.needsUpdate = false;
				} else if (texture instanceof RenderTarget === false && texture.checkNeedsUpdate()) {
					this.updateTexture(context, texture, texIndex, unitrecord);
					texture.needsUpdate = false;
				} else {
					this.bindTexture(context, texture, texIndex, unitrecord);
				}

				var imageObject = texture.image !== undefined ? texture.image : texture;
				var isTexturePowerOfTwo = MathUtils.isPowerOfTwo(imageObject.width) && MathUtils.isPowerOfTwo(imageObject.height);
				this.updateTextureParameters(texture, isTexturePowerOfTwo);
			}
		}
	};

	/**
	 * Update the webgl contexts settings of a single texture, such as filtering and wrapping.
	 *
	 * @param {Texture} texture
	 * @param {boolean} isImagePowerOfTwo
	 */
	Renderer.prototype.updateTextureParameters = function (texture, isImagePowerOfTwo) {
		var context = this.context;

		var texrecord = texture.textureRecord;

		var glType = RendererUtils.getGLType(context, texture.variant);
		if (texrecord.magFilter !== texture.magFilter) {
			context.texParameteri(glType, context.TEXTURE_MAG_FILTER, RendererUtils.getGLMagFilter(context, texture.magFilter));
			texrecord.magFilter = texture.magFilter;
		}
		var minFilter = isImagePowerOfTwo ? texture.minFilter : RendererUtils.getFilterFallback(texture.minFilter);
		if (texrecord.minFilter !== minFilter) {
			context.texParameteri(glType, context.TEXTURE_MIN_FILTER, RendererUtils.getGLMinFilter(context, minFilter));
			texrecord.minFilter = minFilter;
		}

		var wrapS = isImagePowerOfTwo ? texture.wrapS : 'EdgeClamp';
		if (texrecord.wrapS !== wrapS) {
			var glwrapS = RendererUtils.getGLWrap(context, wrapS);
			context.texParameteri(glType, context.TEXTURE_WRAP_S, glwrapS);
			texrecord.wrapS = wrapS;
		}
		var wrapT = isImagePowerOfTwo ? texture.wrapT : 'EdgeClamp';
		if (texrecord.wrapT !== wrapT) {
			var glwrapT = RendererUtils.getGLWrap(context, wrapT);
			context.texParameteri(glType, context.TEXTURE_WRAP_T, glwrapT);
			texrecord.wrapT = wrapT;
		}

		if (Capabilities.TextureFilterAnisotropic && texture.type !== 'Float') {
			var anisotropy = texture.anisotropy;
			if (texrecord.anisotropy !== anisotropy) {
				context.texParameterf(glType, Capabilities.TextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(anisotropy, Capabilities.maxAnisotropy));
				texrecord.anisotropy = anisotropy;
			}
		}
	};

	/**
	 * Binds a texture to webgl.
	 *
	 * @param {WebGLRenderingContext} context
	 * @param {Texture} texture
	 * @param {number} unit The index for the textureRecord.
	 * @param {Object} record
	 */
	Renderer.prototype.bindTexture = function (context, texture, unit, record) {
		if (record.boundTexture === undefined || texture.glTexture !== undefined && record.boundTexture !== texture.glTexture) {
			context.activeTexture(context.TEXTURE0 + unit);
			context.bindTexture(RendererUtils.getGLType(context, texture.variant), texture.glTexture);
			record.boundTexture = texture.glTexture;
		}
	};

	/**
	 * Unbinds a texture from webgl.
	 *
	 * @param {WebGLRenderingContext} context
	 * @param {Texture} texture
	 * @param {number} unit The index for the textureRecord.
	 * @param {Object} record
	 */
	Renderer.prototype.unbindTexture = function (context, texture, unit, record) {
		context.activeTexture(context.TEXTURE0 + unit);
		context.bindTexture(RendererUtils.getGLType(context, texture.variant), null);
		record.boundTexture = undefined;
	};

	/**
	 * Loads a compressed texture into webgl and optionally generates mipmaps.
	 *
	 * @param {WebGLRenderingContext} context
	 * @param {number} target For example context.TEXTURE_2D.
	 * @param {Texture} texture
	 * @param {(Uint8Array|ArrayBufferView)} imageData The image data object.
	 */
	Renderer.prototype.loadCompressedTexture = function (context, target, texture, imageData) {
		var mipSizes = texture.image.mipmapSizes;
		var dataOffset = 0, dataLength = 0;
		var width = texture.image.width, height = texture.image.height;
		var ddsExt = Capabilities.CompressedTextureS3TC;

		if (!ddsExt) {
			texture.image = undefined;
			texture.needsUpdate = true;
			console.warn('Tried to load unsupported compressed texture.');
			return;
		}

		var internalFormat = ddsExt.COMPRESSED_RGBA_S3TC_DXT5_EXT;
		if (texture.format === 'PrecompressedDXT1') {
			internalFormat = ddsExt.COMPRESSED_RGB_S3TC_DXT1_EXT;
		} else if (texture.format === 'PrecompressedDXT1A') {
			internalFormat = ddsExt.COMPRESSED_RGBA_S3TC_DXT1_EXT;
		} else if (texture.format === 'PrecompressedDXT3') {
			internalFormat = ddsExt.COMPRESSED_RGBA_S3TC_DXT3_EXT;
		} else if (texture.format === 'PrecompressedDXT5') {
			internalFormat = ddsExt.COMPRESSED_RGBA_S3TC_DXT5_EXT;
		} else {
			throw new Error('Unhandled compression format: ' + imageData.getDataFormat().name());
		}

		if (typeof mipSizes === 'undefined' || mipSizes === null) {
			if (imageData instanceof Uint8Array) {
				context.compressedTexImage2D(target, 0, internalFormat, width, height, 0, imageData);
			} else {
				context.compressedTexImage2D(target, 0, internalFormat, width, height, 0, new Uint8Array(imageData.buffer, imageData.byteOffset,
					imageData.byteLength));
			}
		} else {
			texture.generateMipmaps = false;
			if (imageData instanceof Array) {
				for (var i = 0; i < imageData.length; i++) {
					context.compressedTexImage2D(target, i, internalFormat, width, height, 0, imageData[i]);
					//! SH: REVIEW: this operation is being done many times, not very DRY; also Math.floor is practically as fast as ~~, does the same thing, and is more readable. http://jsperf.com/jsfvsbitnot/15
					width = ~~(width / 2) > 1 ? ~~(width / 2) : 1;
					height = ~~(height / 2) > 1 ? ~~(height / 2) : 1;
				}
			} else {
				for (var i = 0; i < mipSizes.length; i++) {
					dataLength = mipSizes[i];
					context.compressedTexImage2D(target, i, internalFormat, width, height, 0, new Uint8Array(imageData.buffer, imageData.byteOffset
						+ dataOffset, dataLength));
					width = ~~(width / 2) > 1 ? ~~(width / 2) : 1;
					height = ~~(height / 2) > 1 ? ~~(height / 2) : 1;
					dataOffset += dataLength;
				}
			}

			var expectedMipmaps = 1 + Math.ceil(Math.log(Math.max(texture.image.height, texture.image.width)) / Math.log(2));
			var size = mipSizes[mipSizes.length - 1];
			if (mipSizes.length < expectedMipmaps) {
				for (var i = mipSizes.length; i < expectedMipmaps; i++) {
					size = ~~((width + 3) / 4) * ~~((height + 3) / 4) * texture.image.bpp * 2;
					context.compressedTexImage2D(target, i, internalFormat, width, height, 0, new Uint8Array(size));
					width = ~~(width / 2) > 1 ? ~~(width / 2) : 1;
					height = ~~(height / 2) > 1 ? ~~(height / 2) : 1;
				}
			}
		}
	};

	/**
	 * Updates a texture in webgl with the Texture objects settings.
	 *
	 * @param {WebGLRenderingContext} context
	 * @param {Texture} texture
	 * @param {number} unit
	 * @param {Object} record
	 */
	Renderer.prototype.updateTexture = function (context, texture, unit, record) {
		// this.bindTexture(context, texture, unit, record);
		context.activeTexture(context.TEXTURE0 + unit);
		context.bindTexture(RendererUtils.getGLType(context, texture.variant), texture.glTexture);
		record.boundTexture = texture.glTexture;

		// set alignment to support images with width % 4 !== 0, as
		// images are not aligned
		context.pixelStorei(context.UNPACK_ALIGNMENT, texture.unpackAlignment);

		// Using premultiplied alpha
		context.pixelStorei(context.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

		// set if we want to flip on Y
		context.pixelStorei(context.UNPACK_FLIP_Y_WEBGL, texture.flipY);

		// TODO: Check for the restrictions of using npot textures
		// see: http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
		// TODO: Add "usesMipmaps" to check if minfilter has mipmap mode

		var image = texture.image;
		if (texture.variant === '2D') {
			if (!image) {
				context.texImage2D(context.TEXTURE_2D, 0, RendererUtils.getGLInternalFormat(context, texture.format), texture.width, texture.height, 0,
					RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), null);
			} else {
				if (!image.isCompressed && (texture.generateMipmaps || image.width > this.maxTextureSize || image.height > this.maxTextureSize)) {
					this.checkRescale(texture, image, image.width, image.height, this.maxTextureSize);
					image = texture.image;
				}

				if (image.isData === true) {
					if (image.isCompressed) {
						this.loadCompressedTexture(context, context.TEXTURE_2D, texture, image.data);
					} else {
						context.texImage2D(context.TEXTURE_2D, 0, RendererUtils.getGLInternalFormat(context, texture.format), image.width,
							image.height, texture.hasBorder ? 1 : 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image.data);
					}
				} else {
					context.texImage2D(context.TEXTURE_2D, 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image);
				}

				if (texture.generateMipmaps && !image.isCompressed) {
					context.generateMipmap(context.TEXTURE_2D);
				}
			}
		} else if (texture.variant === 'CUBE') {
			if (image && !image.isData && (texture.generateMipmaps || image.width > this.maxCubemapSize || image.height > this.maxCubemapSize)) {
				for (var i = 0; i < Texture.CUBE_FACES.length; i++) {
					if (image.data[i] && !image.data[i].buffer ) {
						RendererUtils.scaleImage(texture, image.data[i], image.width, image.height, this.maxCubemapSize, i);
					} else {
						RendererUtils.getBlankImage(texture, [0.3, 0.3, 0.3, 0], image.width, image.height, this.maxCubemapSize, i);
					}
				}
				texture.image.width = Math.min(this.maxCubemapSize, MathUtils.nearestPowerOfTwo(texture.image.width));
				texture.image.height = Math.min(this.maxCubemapSize, MathUtils.nearestPowerOfTwo(texture.image.height));
				image = texture.image;
			}

			for (var faceIndex = 0; faceIndex < Texture.CUBE_FACES.length; faceIndex++) {
				var face = Texture.CUBE_FACES[faceIndex];

				if (!image) {
					context.texImage2D(RendererUtils.getGLCubeMapFace(context, face), 0, RendererUtils.getGLInternalFormat(context, texture.format), texture.width, texture.height, 0,
						RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), null);
				} else {
					if (image.isData === true) {
						if (image.isCompressed) {
							this.loadCompressedTexture(context, RendererUtils.getGLCubeMapFace(context, face), texture, image.data[faceIndex]);
						} else {
							context.texImage2D(RendererUtils.getGLCubeMapFace(context, face), 0, RendererUtils.getGLInternalFormat(context, texture.format), image.width,
								image.height, texture.hasBorder ? 1 : 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image.data[faceIndex]);
						}
					} else {
						context.texImage2D(RendererUtils.getGLCubeMapFace(context, face), 0, RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLInternalFormat(context, texture.format), RendererUtils.getGLDataType(context, texture.type), image.data[faceIndex]);
					}
				}
			}

			if (image && texture.generateMipmaps && !image.isCompressed) {
				context.generateMipmap(context.TEXTURE_CUBE_MAP);
			}
		}
	};

	/**
	 * Updates a texture in webgl with the Texture objects settings.
	 *
	 * @param {Texture} texture
	 * @param {Image} image Can be an Image, TypedArray or an array of Images (for cubemaps).
	 * @param {number} width The new image width.
	 * @param {number} height The new image height.
	 * @param {number} maxSize
	 * @param {number} index
	 */
	Renderer.prototype.checkRescale = function (texture, image, width, height, maxSize, index) {
		RendererUtils.scaleImage(texture, image, width, height, maxSize, index);
	};

	/**
	 * Update the blend settings on the webgl context.
	 *
	 * @param {Material} material
	 */
	Renderer.prototype.updateBlending = function (material) {
		var blendRecord = this.rendererRecord.blendRecord;
		var context = this.context;

		var blending = material.blendState.blending;
		if (blending !== blendRecord.blending) {
			if (blending === 'NoBlending') {
				context.disable(context.BLEND);
			} else if (blending === 'AdditiveBlending') {
				context.enable(context.BLEND);
				context.blendEquation(context.FUNC_ADD);
				context.blendFunc(context.SRC_ALPHA, context.ONE);
			} else if (blending === 'SubtractiveBlending') {
				// TODO: Find blendFuncSeparate() combination
				context.enable(context.BLEND);
				context.blendEquation(context.FUNC_REVERSE_SUBTRACT);
				context.blendFunc(context.SRC_ALPHA, context.ONE);
			} else if (blending === 'MultiplyBlending') {
				// TODO: Find blendFuncSeparate() combination
				context.enable(context.BLEND);
				context.blendEquation(context.FUNC_ADD);
				context.blendFunc(context.DST_COLOR, context.ONE_MINUS_SRC_ALPHA);
			} else if (blending === 'AlphaBlending') {
				context.enable(context.BLEND);
				context.blendEquation(context.FUNC_ADD);
				context.blendFunc(context.SRC_ALPHA, context.ONE_MINUS_SRC_ALPHA);
			} else if (blending === 'TransparencyBlending') {
				context.enable(context.BLEND);
				context.blendEquationSeparate(
					context.FUNC_ADD,
					context.FUNC_ADD
				);
				context.blendFuncSeparate(
					context.SRC_ALPHA,
					context.ONE_MINUS_SRC_ALPHA,
					context.ONE,
					context.ONE_MINUS_SRC_ALPHA
				);
			} else if (blending === 'CustomBlending') {
				context.enable(context.BLEND);
			} else if (blending === 'SeparateBlending') {
				context.enable(context.BLEND);
				context.blendEquationSeparate(
						RendererUtils.getGLBlendParam(context, material.blendState.blendEquationColor),
						RendererUtils.getGLBlendParam(context, material.blendState.blendEquationAlpha));
				context.blendFuncSeparate(
					RendererUtils.getGLBlendParam(context, material.blendState.blendSrcColor),
					RendererUtils.getGLBlendParam(context, material.blendState.blendDstColor),
					RendererUtils.getGLBlendParam(context, material.blendState.blendSrcAlpha),
					RendererUtils.getGLBlendParam(context, material.blendState.blendDstAlpha));
			} else {
				context.enable(context.BLEND);
				context.blendEquationSeparate(context.FUNC_ADD, context.FUNC_ADD);
				context.blendFuncSeparate(context.SRC_ALPHA, context.ONE_MINUS_SRC_ALPHA, context.ONE,
					context.ONE_MINUS_SRC_ALPHA);
			}

			blendRecord.blending = blending;
		}

		if (blending === 'CustomBlending') {
			var blendEquation = material.blendState.blendEquation;
			var blendSrc = material.blendState.blendSrc;
			var blendDst = material.blendState.blendDst;

			if (blendEquation !== blendRecord.blendEquation) {
				context.blendEquation(RendererUtils.getGLBlendParam(context, blendEquation));
				blendRecord.blendEquation = blendEquation;
			}

			if (blendSrc !== blendRecord.blendSrc || blendDst !== blendRecord.blendDst) {
				context.blendFunc(RendererUtils.getGLBlendParam(context, blendSrc), RendererUtils.getGLBlendParam(context, blendDst));

				blendRecord.blendSrc = blendSrc;
				blendRecord.blendDst = blendDst;
			}
		} else {
			blendRecord.blendEquation = null;
			blendRecord.blendSrc = null;
			blendRecord.blendDst = null;
		}
	};

	/**
	 * Updates the polygon offset settings on the webgl context.
	 *
	 * @param {Material} material
	 */
	Renderer.prototype.updateOffset = function (material) {
		var offsetRecord = this.rendererRecord.offsetRecord;
		var context = this.context;

		var enabled = material.offsetState.enabled;
		var factor = material.offsetState.factor;
		var units = material.offsetState.units;

		if (offsetRecord.enabled !== enabled) {
			if (enabled) {
				context.enable(context.POLYGON_OFFSET_FILL);
			} else {
				context.disable(context.POLYGON_OFFSET_FILL);
			}

			offsetRecord.enabled = enabled;
		}

		if (enabled && (offsetRecord.factor !== factor || offsetRecord.units !== units)) {
			context.polygonOffset(factor, units);

			offsetRecord.factor = factor;
			offsetRecord.units = units;
		}
	};

	/**
	 * Binds a buffer to the webgl context.
	 *
	 * @param {WebGLBuffer} buffer
	 * @param {string} target for example 'ArrayBuffer'.
	 */
	Renderer.prototype.setBoundBuffer = function (buffer, target) {
		var targetBuffer = this.rendererRecord.currentBuffer[target];
		if (!targetBuffer.valid || targetBuffer.buffer !== buffer) {
			this.context.bindBuffer(RendererUtils.getGLBufferTarget(this.context, target), buffer);
			targetBuffer.buffer = buffer;
			targetBuffer.valid = true;
			if (target === 'ArrayBuffer') {
				this.rendererRecord.attributeCache.length = 0;
			}
		}
	};

	/**
	 * Binds vertex attributes to the webgl context.
	 *
	 * @param {number} attribIndex
	 * @param {Object} attribute See MeshData.createAttribute for definition.
	 */
	Renderer.prototype.bindVertexAttribute = function (attribIndex, attribute) {
		var hashKey = this.rendererRecord.attributeCache[attribIndex];
		if (hashKey !== attribute.hashKey) {
			this.context.vertexAttribPointer(attribIndex, attribute.count, RendererUtils.getGLDataType(this.context, attribute.type), attribute.normalized, attribute.stride, attribute.offset);
			this.rendererRecord.attributeCache[attribIndex] = attribute.hashKey;
		}
	};

	/**
	 * Clears the webgl context with the specified options.
	 *
	 * @param {boolean} color
	 * @param {boolean} depth
	 * @param {boolean} stencil
	 */
	Renderer.prototype.clear = function (color, depth, stencil) {
		var bits = 0;

		if (color === undefined || color) {
			bits |= this.context.COLOR_BUFFER_BIT;
		}
		if (depth === undefined || depth) {
			bits |= this.context.DEPTH_BUFFER_BIT;
		}
		if (stencil === undefined || stencil) {
			bits |= this.context.STENCIL_BUFFER_BIT;
		}

		var record = this.rendererRecord.depthRecord;
		if (record.write !== true) {
			this.context.depthMask(true);
			record.write = true;
		}

		if (bits) {
			this.context.clear(bits);
		}
	};

	/**
	 * Flushes the webgl context.
	 *
	 */
	Renderer.prototype.flush = function () {
		this.context.flush();
	};

	/**
	 * calls finish on the webgl context.
	 *
	 */
	Renderer.prototype.finish = function () {
		this.context.finish();
	};

	// ---------------------------------------------

	/**
	 * Setup a Frame Buffer Object with the supplied render target.
	 *
	 * @param {WebGLFramebuffer} framebuffer
	 * @param {RenderTarget} renderTarget
	 * @param {number} textureTarget For instance context.TEXTURE_2D.
	 */
	Renderer.prototype.setupFrameBuffer = function (framebuffer, renderTarget, textureTarget) {
		this.context.bindFramebuffer(this.context.FRAMEBUFFER, framebuffer);
		this.context.framebufferTexture2D(this.context.FRAMEBUFFER, this.context.COLOR_ATTACHMENT0, textureTarget,
			renderTarget.glTexture, 0);
	};

	/**
	 * Setup an Render Buffer Object with the supplied render target.
	 *
	 * @param {WebGLRenderbuffer} renderbuffer
	 * @param {RenderTarget} renderTarget
	 */
	Renderer.prototype.setupRenderBuffer = function (renderbuffer, renderTarget) {
		var context = this.context;
		context.bindRenderbuffer(context.RENDERBUFFER, renderbuffer);

		if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
			context.renderbufferStorage(context.RENDERBUFFER, context.DEPTH_COMPONENT16, renderTarget.width,
				renderTarget.height);
			context.framebufferRenderbuffer(context.FRAMEBUFFER, context.DEPTH_ATTACHMENT,
				context.RENDERBUFFER, renderbuffer);
		} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
			context.renderbufferStorage(context.RENDERBUFFER, context.DEPTH_STENCIL, renderTarget.width,
				renderTarget.height);
			context.framebufferRenderbuffer(context.FRAMEBUFFER, context.DEPTH_STENCIL_ATTACHMENT,
				context.RENDERBUFFER, renderbuffer);
		} else {
			this.context
				.renderbufferStorage(context.RENDERBUFFER, context.RGBA4, renderTarget.width, renderTarget.height);
		}
	};

	/**
	 * Binds the supplied render target's FBO to the webgl context.
	 * Creates FBO and RBO for the render target if not set already.
	 *
	 * @param {RenderTarget} renderTarget
	 */
	Renderer.prototype.setRenderTarget = function (renderTarget) {
		var context = this.context;
		if (renderTarget && !renderTarget._glFrameBuffer) {
			if (renderTarget.depthBuffer === undefined) {
				renderTarget.depthBuffer = true;
			}
			if (renderTarget.stencilBuffer === undefined) {
				renderTarget.stencilBuffer = true;
			}

			if (renderTarget.glTexture === null) {
				renderTarget.glTexture = this.context.createTexture();
			}

			// Setup texture, create render and frame buffers
			var isTargetPowerOfTwo = MathUtils.isPowerOfTwo(renderTarget.width) && MathUtils.isPowerOfTwo(renderTarget.height);
			var glFormat = RendererUtils.getGLInternalFormat(context, renderTarget.format);
			var glType = RendererUtils.getGLDataType(context, renderTarget.type);

			renderTarget._glFrameBuffer = this.context.createFramebuffer();
			renderTarget._glRenderBuffer = this.context.createRenderbuffer();

			this.context.bindTexture(context.TEXTURE_2D, renderTarget.glTexture);
			this.updateTextureParameters(renderTarget, isTargetPowerOfTwo);

			this.context
				.texImage2D(context.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);

			this.setupFrameBuffer(renderTarget._glFrameBuffer, renderTarget, context.TEXTURE_2D);
			this.setupRenderBuffer(renderTarget._glRenderBuffer, renderTarget);

			if (renderTarget.generateMipmaps && isTargetPowerOfTwo) {
				this.context.generateMipmap(context.TEXTURE_2D);
			}

			// Release everything
			this.context.bindTexture(context.TEXTURE_2D, null);
			this.context.bindRenderbuffer(context.RENDERBUFFER, null);
			this.context.bindFramebuffer(context.FRAMEBUFFER, null);
		}

		var framebuffer, width, height, vx, vy;

		if (renderTarget) {
			framebuffer = renderTarget._glFrameBuffer;

			vx = 0;
			vy = 0;
			width = renderTarget.width;
			height = renderTarget.height;
		} else {
			framebuffer = null;

			vx = this.viewportX;
			vy = this.viewportY;
			width = this.viewportWidth;
			height = this.viewportHeight;
		}

		if (framebuffer !== this.rendererRecord.currentFrameBuffer) {
			context.bindFramebuffer(context.FRAMEBUFFER, framebuffer);
			context.viewport(vx, vy, width, height);

			this.rendererRecord.currentFrameBuffer = framebuffer;

			// Need to force rebinding of textures on framebuffer change (TODO: verify this)
			this.rendererRecord.textureRecord = [];
		}

		this.currentWidth = width;
		this.currentHeight = height;
	};

	/**
	 * Updates the render targets mipmaps.
	 *
	 * @param {RenderTarget} renderTarget
	 */
	Renderer.prototype.updateRenderTargetMipmap = function (renderTarget) {
		var context = this.context;
		context.bindTexture(context.TEXTURE_2D, renderTarget.glTexture);
		context.generateMipmap(context.TEXTURE_2D);
		context.bindTexture(context.TEXTURE_2D, null);
	};

	/**
	 * Deallocates a meshdata with the Renderer's webgl context.
	 *
	 * @param {MeshData} meshData
	 */
	Renderer.prototype._deallocateMeshData = function (meshData) {
		meshData.destroy(this.context);
	};

	/**
	 * Deallocates a texture with the Renderer's webgl context.
	 *
	 * @param {Texture} texture
	 */
	Renderer.prototype._deallocateTexture = function (texture) {
		texture.destroy(this.context);
	};

	/**
	 * Deallocates a render target with the Renderer's webgl context.
	 *
	 * @param {RenderTarget} renderTarget
	 */
	Renderer.prototype._deallocateRenderTarget = function (renderTarget) {
		renderTarget.destroy(this.context);
	};

	/**
	 * Deallocates a shader.
	 *
	 * @param {Shader} shader
	 */
	Renderer.prototype._deallocateShader = function (shader) {
		shader.destroy();
	};

	return Renderer;
})(goo.Capabilities,goo.RendererRecord,goo.RendererUtils,goo.TextureCreator,goo.RenderTarget,goo.Vector4,goo.Entity,goo.Texture,goo.DdsLoader,goo.DdsUtils,goo.Material,goo.Transform,goo.RenderQueue,goo.ShaderLib,goo.ShadowHandler,goo.RenderStats,goo.SystemBus,goo.TaskScheduler,goo.RenderInfo,goo.MathUtils);
goo.TransformSystem = (function (System) {
	'use strict';

	// has to stay here because it's used by traverseFunc below
	// it's pretty crappy how it's sprinkled over the code
	var numUpdates;

	/**
	 * Processes all entities with transform components, making sure they are up to date and valid according to the "scenegraph"
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/TransformComponent/TransformComponent-vtest.html Working example
	 * @extends System
	 */
	function TransformSystem() {
		System.call(this, 'TransformSystem', ['TransformComponent']);
		this.numUpdates = 0;
	}

	TransformSystem.prototype = Object.create(System.prototype);
	TransformSystem.prototype.constructor = TransformSystem;

	TransformSystem.prototype.process = function (entities) {
		numUpdates = 0;
		var i, transformComponent;
		var l = entities.length;
		for (i = 0; i < l; i++) {
			transformComponent = entities[i].transformComponent;
			transformComponent._updated = false;
			if (transformComponent._dirty) {
				transformComponent.updateTransform();
			}
		}

		// Traverse from root nodes and down, depth first
		for (i = 0; i < l; i++) {
			var entity = entities[i];
			transformComponent = entity.transformComponent;
			if (transformComponent.parent === null) {
				entity.traverse(traverseFunc);
			}
		}

		this.numUpdates = numUpdates;
	};

	function traverseFunc(entity) {
		if (entity.transformComponent._dirty) {
			entity.transformComponent.updateWorldTransform();
			numUpdates++;
			// Set children to dirty
			var children = entity.transformComponent.children;
			for (var j = 0; j < children.length; j++) {
				children[j]._dirty = true;
			}
		}
	}

	return TransformSystem;
})(goo.System);
goo.SimplePartitioner = (function (Camera) {
	'use strict';

	/**
	 * Culls entities based on camera frustum and boundings
	 */
	function SimplePartitioner() {
	}

	SimplePartitioner.prototype.added = function () {
		// needed for things like quadtrees etc
	};

	SimplePartitioner.prototype.removed = function () {
		// needed for things like quadtrees etc
	};

	SimplePartitioner.prototype.process = function (camera, entities, renderList) {
		var index = 0;
		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];

			if (entity.skip || entity.meshRendererComponent.hidden) {
				entity.isVisible = false;
				continue;
			}

			if (entity.meshRendererComponent.cullMode === 'Never') {
				renderList[index++] = entity;
				entity.isVisible = true;
			} else {
				var bounds = entity.meshRendererComponent.worldBound;
				var result = camera.contains(bounds);
				if (result !== Camera.Outside) {
					renderList[index++] = entity;
					entity.isVisible = true;
				} else {
					entity.isVisible = false;
				}
			}
		}
		renderList.length = index;
	};

	return SimplePartitioner;
})(goo.Camera);
goo.RenderSystem = (function (
	System,
	SystemBus,
	SimplePartitioner,
	Material,
	ShaderLib,
	ObjectUtils
) {
	'use strict';

	/**
	 * Renders entities/renderables using a configurable partitioner for culling
	 * @property {boolean} doRender Only render if set to true
	 * @extends System
	 */
	function RenderSystem() {
		System.call(this, 'RenderSystem', ['MeshRendererComponent', 'MeshDataComponent']);

		this.entities = [];
		this.renderList = [];
		this.postRenderables = [];
		this.partitioner = new SimplePartitioner();
		this.preRenderers = [];
		this.composers = [];
		this._composersActive = true;
		this.doRender = true;

		this._debugMaterials = {};
		this.overrideMaterials = [];
		this.partitioningCamera = null;

		this.camera = null;
		this.lights = [];
		this.currentTpf = 0.0;

		SystemBus.addListener('goo.setCurrentCamera', function (newCam) {
			this.camera = newCam.camera;
		}.bind(this));

		SystemBus.addListener('goo.setLights', function (lights) {
			this.lights = lights;
		}.bind(this));

		this.picking = {
			doPick: false,
			x: 0,
			y: 0,
			pickingStore: {},
			pickingCallback: function (id, depth) {
				console.log(id, depth);
			},
			skipUpdateBuffer: false
		};
	}

	RenderSystem.prototype = Object.create(System.prototype);
	RenderSystem.prototype.constructor = RenderSystem;

	RenderSystem.prototype.pick = function (x, y, callback, skipUpdateBuffer) {
		this.picking.x = x;
		this.picking.y = y;
		this.picking.skipUpdateBuffer = skipUpdateBuffer === undefined ? false : skipUpdateBuffer;
		if (callback) {
			this.picking.pickingCallback = callback;
		}
		this.picking.doPick = true;
	};

	RenderSystem.prototype.inserted = function (entity) {
		if (this.partitioner) {
			this.partitioner.added(entity);
		}
	};

	RenderSystem.prototype.deleted = function (entity) {
		if (this.partitioner) {
			this.partitioner.removed(entity);
		}
	};

	RenderSystem.prototype.process = function (entities, tpf) {
		this.entities = entities;
		this.currentTpf = tpf;
	};

	RenderSystem.prototype.render = function (renderer) {
		if (!this.doRender) {
			return;
		}

		if (this.camera) {
			renderer.updateShadows(this.partitioner, this.entities, this.lights);

			for (var i = 0; i < this.preRenderers.length; i++) {
				var preRenderer = this.preRenderers[i];
				preRenderer.process(renderer, this.entities, this.partitioner, this.camera, this.lights);
			}

			if (this.partitioningCamera) {
				this.partitioner.process(this.partitioningCamera, this.entities, this.renderList);
			} else {
				this.partitioner.process(this.camera, this.entities, this.renderList);
			}

			if (this.composers.length > 0 && this._composersActive) {
				for (var i = 0; i < this.composers.length; i++) {
					var composer = this.composers[i];
					composer.render(renderer, this.currentTpf, this.camera, this.lights, null, true, this.overrideMaterials);
				}
			} else {
				renderer.render(this.renderList, this.camera, this.lights, null, true, this.overrideMaterials);
			}
		}
	};

	RenderSystem.prototype.renderToPick = function (renderer, skipUpdateBuffer) {
		renderer.renderToPick(this.renderList, this.camera, true, skipUpdateBuffer);
	};

	RenderSystem.prototype.enableComposers = function (activate) {
		this._composersActive = !!activate;
	};

	RenderSystem.prototype._createDebugMaterial = function (key) {
		if (key === '') {
			return;
		}
		var fshader;
		switch (key) {
			case 'wireframe':
			case 'color':
				fshader = ObjectUtils.deepClone(ShaderLib.simpleColored.fshader);
				break;
			case 'lit':
				fshader = ObjectUtils.deepClone(ShaderLib.simpleLit.fshader);
				break;
			case 'texture':
				fshader = ObjectUtils.deepClone(ShaderLib.textured.fshader);
				break;
			case 'normals':
				fshader = ObjectUtils.deepClone(ShaderLib.showNormals.fshader);
				break;
			case 'simple':
				fshader = ObjectUtils.deepClone(ShaderLib.simple.fshader);
				break;
		}
		var shaderDef = ObjectUtils.deepClone(ShaderLib.uber);
		shaderDef.fshader = fshader;
		if (key !== 'flat') {
			this._debugMaterials[key] = new Material(shaderDef, key);
			if (key === 'wireframe') {
				this._debugMaterials[key].wireframe = true;
			}
			if (key === 'lit') {
				this._debugMaterials[key]._textureMaps = {
					EMISSIVE_MAP: null,
					DIFFUSE_MAP: null,
					SPECULAR_MAP: null,
					NORMAL_MAP: null,
					AO_MAP: null,
					LIGHT_MAP: null,
					TRANSPARENCY_MAP: null
				};
			}
		} else {
			this._debugMaterials[key] = Material.createEmptyMaterial(null, key);
			this._debugMaterials[key].flat = true;
		}
	};

	RenderSystem.prototype.setDebugMaterial = function (key) {
		if (!key || key === '') {
			this.overrideMaterials = [];
			return;
		}
		var debugs = key.split('+');
		this.overrideMaterials = [];

		for (var i = 0; i < debugs.length; i++) {
			var key = debugs[i];
			if (!this._debugMaterials[key]) {
				this._createDebugMaterial(key);
			}
			if (key === '') {
				this.overrideMaterials.push(null);
			} else {
				this.overrideMaterials.push(this._debugMaterials[key]);
			}
		}
	};

	RenderSystem.prototype.invalidateHandles = function (renderer) {
		for (var i = 0; i < this.entities.length; i++) {
			var entity = this.entities[i];

			var materials = entity.meshRendererComponent.materials;
			for (var j = 0; j < materials.length; j++) {
				renderer.invalidateMaterial(materials[j]);
			}
			renderer.invalidateMeshData(entity.meshDataComponent.meshData);
		}

		for (var i = 0; i < this.composers.length; i++) {
			var composer = this.composers[i];
			renderer.invalidateComposer(composer);
		}

		renderer.rendererRecord = null; // might hold on to stuff
	};

	return RenderSystem;
})(goo.System,goo.SystemBus,goo.SimplePartitioner,goo.Material,goo.ShaderLib,goo.ObjectUtils);
goo.BoundingUpdateSystem = (function (
	System,
	BoundingBox
) {
	'use strict';

	/**
	 * Calculates and updates all boundings on entities with both transform, meshrenderer and meshdata components
	 * @extends System
	 */
	function BoundingUpdateSystem () {
		System.call(this, 'BoundingUpdateSystem', ['TransformComponent', 'MeshRendererComponent', 'MeshDataComponent']);
		this._worldBound = new BoundingBox();
		this._computeWorldBound = null;
	}

	BoundingUpdateSystem.prototype = Object.create(System.prototype);
	BoundingUpdateSystem.prototype.constructor = BoundingUpdateSystem;

	BoundingUpdateSystem.prototype.process = function (entities) {
		var l = entities.length;
		if (l === 0) {
			this._computeWorldBound = null;
			return;
		}

		for (var i = 0; i < l; i++) {
			var entity = entities[i];
			var meshDataComponent = entity.meshDataComponent;
			var transformComponent = entity.transformComponent;
			var meshRendererComponent = entity.meshRendererComponent;

			if (meshDataComponent.autoCompute) {
				meshDataComponent.computeBoundFromPoints();
				meshRendererComponent.updateBounds(meshDataComponent.modelBound, transformComponent.worldTransform);
			} else if (transformComponent._updated) {
				meshRendererComponent.updateBounds(meshDataComponent.modelBound, transformComponent.worldTransform);
				// meshDataComponent.setDirty(false);
			}
		}
		if (this._computeWorldBound && this._computeWorldBound instanceof Function) {
			//this._worldBound = new BoundingSphere(new Vector3(0, 0, 0), 0); // optional for including the center of the scene into the world bound

			// generally we don't want particle systems to end up in our world bound computing since they have huge world bounds and can mess up stuff
			for (var i = 0; i < l; i++) {
				if (!entities[i].particleComponent) {
					this._worldBound = entities[i].meshRendererComponent.worldBound.clone();
					break;
				}
			}

			for (; i < l; i++) {
				if (!entities[i].particleComponent) {
					var mrc = entities[i].meshRendererComponent;
					this._worldBound = this._worldBound.merge(mrc.worldBound);
				}
			}

			this._computeWorldBound(this._worldBound);
			this._computeWorldBound = null;
		}
	};

	// function named get actually does a set
	BoundingUpdateSystem.prototype.getWorldBound = function (callback) {
		this._computeWorldBound = callback;
	};

	BoundingUpdateSystem.prototype.deleted = function (entity) {
		if (entity.meshRendererComponent) {
			entity.meshRendererComponent.worldBound = new BoundingBox();
		}
	};

	return BoundingUpdateSystem;
})(goo.System,goo.BoundingBox);
goo.ScriptSystem = (function (
	System,
	SystemBus
) {
	'use strict';

	/**
	 * Processes all entities with script components, running the scripts where applicable
	 * @extends System
	 */
	function ScriptSystem(world) {
		System.call(this, 'ScriptSystem', ['ScriptComponent']);

		//! AT: why this?
		this._world = world;

		var renderer = this._world.gooRunner.renderer;
		// General world environment
		this.context = {
			domElement: renderer.domElement,
			viewportWidth: renderer.viewportWidth,
			viewportHeight: renderer.viewportHeight,
			world: world,
			activeCameraEntity: null,
			worldData: {},
			playTime: 0
		};

		this._playing = true;

		SystemBus.addListener('goo.setCurrentCamera', function (data) {
			this.context.activeCameraEntity = data.entity;
		}.bind(this));

		SystemBus.addListener('goo.viewportResize', function (data) {
			this.context.viewportWidth = data.width;
			this.context.viewportHeight = data.height;
		}.bind(this));

		this.manualSetup = false;

		this.priority = 500;
	}

	ScriptSystem.prototype = Object.create(System.prototype);
	ScriptSystem.prototype.constructor = ScriptSystem;

	/*
	ScriptSystem.prototype.inserted = function (entity) {
		if (!this.manualSetup) {
			entity.scriptComponent.setup(entity);
		}
	};*/

	ScriptSystem.prototype.play = function () {
		this.context.playTime = 0;
		this._playing = true;
	};

	ScriptSystem.prototype.resume = function () {
		this._playing = true;
	};

	ScriptSystem.prototype.pause = function () {
		this._playing = false;
	};

	ScriptSystem.prototype.stop = ScriptSystem.prototype.pause;

	ScriptSystem.prototype.process = function (entities, tpf) {
		// Update scripts
		for (var i = 0; i < entities.length; i++) {
			var scriptComponent = entities[i].scriptComponent;
			scriptComponent.run(entities[i], tpf);
		}

		// update play time
		if (this._playing) {
			this.context.playTime += tpf;
		}
	};

	ScriptSystem.prototype.addedComponent = function (entity, component) {
		if (component.type === 'ScriptComponent' && !this.manualSetup) {
			component.setup(entity);
		}
	};

	ScriptSystem.prototype.removedComponent = function (entity, component) {
		if (component.type === 'ScriptComponent' && !this.manualSetup) {
			component.cleanup();
		}
	};

	/*
	ScriptSystem.prototype.deleted = function (entity) {
		if (entity.scriptComponent && !this.manualSetup) {
			entity.scriptComponent.cleanup();
		}
	};*/

	ScriptSystem.prototype.clear = function () {
		for (var i = 0; i < this._activeEntities.length; i++) {
			var entity = this._activeEntities[i];
			entity.scriptComponent.cleanup();
		}

		this._world = null;
		this.context = null;

		System.prototype.clear.call(this);
	};

	return ScriptSystem;
})(goo.System,goo.SystemBus);
goo.LightingSystem = (function (
	Capabilities,
	System,
	SystemBus
) {
	'use strict';

	/**
	 * Processes all entities with a light component making sure that lights are placed according to its transforms<br>
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/light/Lights-vtest.html Working example
	 * @extends System
	 */
	function LightingSystem() {
		System.call(this, 'LightingSystem', ['LightComponent', 'TransformComponent']);

		this.overrideLights = null;
		this._needsUpdate = true;

		this.lights = [];
	}

	LightingSystem.prototype = Object.create(System.prototype);
	LightingSystem.prototype.constructor = LightingSystem;

	/**
	 * Replaces the lights tracked by the system with custom ones.
	 * @param overrideLights
	 */
	LightingSystem.prototype.setOverrideLights = function (overrideLights) {
		this.overrideLights = overrideLights;
		SystemBus.emit('goo.setLights', this.overrideLights);
		this._needsUpdate = true;
	};

	/**
	 * Disables overriding of lights tracked by the system
	 */
	LightingSystem.prototype.clearOverrideLights = function () {
		this.overrideLights = undefined;
		this._needsUpdate = true;
	};

	LightingSystem.prototype.inserted = function (entity) {
		entity.lightComponent.updateLight(entity.transformComponent.worldTransform);
	};

	LightingSystem.prototype.process = function (entities) {
		// do we use this anymore?
		// we used to have this feature for the early days of create
		if (!this.overrideLights) {
			this.lights.length = 0;

			for (var i = 0; i < entities.length; i++) {
				var entity = entities[i];
				var transformComponent = entity.transformComponent;
				var lightComponent = entity.lightComponent;

				if (transformComponent._updated || this._needsUpdate) {
					lightComponent.updateLight(transformComponent.worldTransform);
				}

				if (!lightComponent.hidden) {
					var light = lightComponent.light;
					light.shadowCaster = light.shadowCaster && Capabilities.TextureFloat; // Needs float texture for shadows (for now)
					this.lights.push(light);
				}
			}
			this._needsUpdate = false;

			SystemBus.emit('goo.setLights', this.lights);
		}
	};

	LightingSystem.prototype.invalidateHandles = function (renderer) {
		this._activeEntities.forEach(function (entity) {
			entity.lightComponent.light.invalidateHandles(renderer);
		});
	};

	return LightingSystem;
})(goo.Capabilities,goo.System,goo.SystemBus);
goo.CameraSystem = (function (
	System,
	SystemBus,
	Renderer
) {
	'use strict';

	/**
	 * Updates cameras/cameracomponents with their transform component transforms
	 * @extends System
	 */
	function CameraSystem() {
		System.call(this, 'CameraSystem', ['TransformComponent', 'CameraComponent']);
		this.mainCamera = null; //! AT: what's up with this? is it unused?
	}

	CameraSystem.prototype = Object.create(System.prototype);
	CameraSystem.prototype.constructor = CameraSystem;

	/**
	 * Sets the Renderer's main camera to be the first camera of the CameraComponents
	 * in the currently active entities of this system.
	 */
	CameraSystem.prototype.findMainCamera = function () {
		if (this._activeEntities.length) {
			var firstEntity = this._activeEntities[0];
			SystemBus.emit('goo.setCurrentCamera', {
				camera: firstEntity.cameraComponent.camera,
				entity: firstEntity
			});
		}
	};

	CameraSystem.prototype.inserted = function (entity) {
		if (!Renderer.mainCamera) {
			SystemBus.emit('goo.setCurrentCamera', {
				camera: entity.cameraComponent.camera,
				entity: entity
			});
		}
	};

	CameraSystem.prototype.deleted = function () {
		//! AT: leaving it like this until a better solution is found
		// apparently it might conflict with the new loader scheme
		//this.findMainCamera();
	};

	CameraSystem.prototype.process = function () {
		for (var i = 0; i < this._activeEntities.length; i++) {
			var entity = this._activeEntities[i];
			var transformComponent = entity.transformComponent;
			var cameraComponent = entity.cameraComponent;

			if (transformComponent._updated) {
				cameraComponent.updateCamera(transformComponent.worldTransform);
			}
		}
	};

	return CameraSystem;
})(goo.System,goo.SystemBus,goo.Renderer);
goo.ParticlesSystem = (function (
	System
) {
	'use strict';

	/**
	 * Manages and reacts to particle components on entities.
	 * @extends System
	 */
	function ParticlesSystem() {
		System.call(this, 'ParticlesSystem', ['TransformComponent', 'MeshRendererComponent', 'MeshDataComponent', 'ParticleComponent']);
		this.passive = false;
	}

	ParticlesSystem.prototype = Object.create(System.prototype);
	ParticlesSystem.prototype.constructor = ParticlesSystem;

	ParticlesSystem.prototype.process = function (entities, tpf) {
		if (tpf > 1) {
			return; // ignore, probably was out of focus
		}
		// go through each particle component and update
		for (var i = 0, max = entities.length; i < max; i++) {
			var entity = entities[i];
			var particleComponent = entity.particleComponent;

			if (particleComponent.enabled) {
				this.updateParticles(entity, particleComponent, tpf);
			}
		}
	};

	ParticlesSystem.prototype.updateParticles = function (particleEntity, particleComponent, tpf) {
		var particleIndex = 0;
		var emitterIndex = -1;
		var emitter;
		var needsUpdate = false;

		// step through our particles
		while (particleIndex < particleComponent.particleCount) {
			// watch for emitter changes
			while (emitter === undefined) {
				emitterIndex++;
				if (particleComponent.emitters.length > emitterIndex) {
					emitter = particleComponent.emitters[emitterIndex];

					// go through any influences and prepare them - we can use this to enable / disable the emitter
					if (emitter.influences.length) {
						for (var j = 0, max = emitter.influences.length; j < max; j++) {
							emitter.influences[j].prepare(particleEntity, emitter);
						}
					}

					// check if this emitter is enabled and bail out if not
					if (!emitter.enabled) {
						emitter = undefined;
						continue;
					}

					if (emitter.totalParticlesToSpawn !== 0) {
						// find out how many particles to create.
						emitter.particlesWaitingToRelease += emitter.releaseRatePerSecond * tpf;
						emitter.particlesWaitingToRelease = Math.max(emitter.particlesWaitingToRelease, 0);
					}

					// no particles to make this turn, so move on.
					if (emitter.particlesWaitingToRelease < 1) {
						emitter = undefined;
						continue;
					}
				} else {
					emitter = null;
				}
			}

			// pull the current particle
			var particle = particleComponent.particles[particleIndex];

			// if this particle is alive and we have influences, apply them
			if (particle.alive && particle.emitter && particle.emitter.influences.length) {
				for ( var j = 0, max = particle.emitter.influences.length; j < max; j++) {
					if (particle.emitter.influences[j].enabled) {
						particle.emitter.influences[j].apply(tpf, particle, particleIndex);
					}
				}
			}

			// if alive, update the particle along its lifetime - this may kill the particle
			if (particle.alive) {
				particle.update(tpf, particleEntity);
				needsUpdate = true;
			}

			// if not alive, see if we want to respawn it at the current emitter (if we have one)
			if (!particle.alive && emitter) {
				emitter.particlesWaitingToRelease--;
				if (emitter.totalParticlesToSpawn >= 1) {
					emitter.totalParticlesToSpawn--;
				}

				particle.respawnParticle(emitter);
				emitter.getEmissionPoint(particle, particleEntity);
				emitter.getEmissionVelocity(particle, particleEntity);

				if (emitter.particlesWaitingToRelease < 1 || emitter.totalParticlesToSpawn === 0) {
					// setup to pull next emitter, if any
					emitter = undefined;
				}
			}

			particleIndex++;
		}

		// tell particle meshdata we are updated.
		if (needsUpdate) {
			particleComponent.meshData.vertexData._dataNeedsRefresh = true;
			particleEntity.meshDataComponent.autoCompute = true;
		}
	};

	ParticlesSystem.prototype.play = function () {
		this.passive = false;
	};

	ParticlesSystem.prototype.pause = function () {
		this.passive = true;
	};

	ParticlesSystem.prototype.resume = ParticlesSystem.prototype.play;

	ParticlesSystem.prototype.stop = ParticlesSystem.prototype.pause;

	return ParticlesSystem;
})(goo.System);
goo.Stats = (function () {
	'use strict';

	/**
	 * Shows render statistics
	 * @example
	 * this.stats = new Stats();
	 * document.body.appendChild(this.stats.domElement);
	 */
	function Stats() {
		var startTime = Date.now(), prevTime = startTime, prevTimeMs = startTime;
		var ms = 0, msMin = Infinity, msMax = 0;
		var fps = 0, fpsMin = Infinity, fpsMax = 0;
		var frames = 0, mode = 0;

		var container = document.createElement('div');
		container.id = 'stats';
		container.addEventListener('mousedown', function (event) {
			event.preventDefault();
			setModeP(++mode % 2);
		}, false);
		container.style.cssText = 'width:80px;cursor:pointer;z-index:1000;' +
			'-webkit-touch-callout: none;' +
			'-webkit-user-select: none;' +
			'-khtml-user-select: none;' +
			'-moz-user-select: none;' +
			'-ms-user-select: none;' +
			'user-select: none;';

		var fpsDiv = document.createElement('div');
		fpsDiv.id = 'fps';
		fpsDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#002';
		container.appendChild(fpsDiv);

		var fpsText = document.createElement('div');
		fpsText.id = 'fpsText';
		fpsText.style.cssText = 'color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:8px;font-weight:bold;line-height:13px';
		fpsText.innerHTML = 'FPS';
		fpsDiv.appendChild(fpsText);

		var fpsGraph = document.createElement('div');
		fpsGraph.id = 'fpsGraph';
		fpsGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0ff';
		fpsDiv.appendChild(fpsGraph);

		while (fpsGraph.children.length < 74) {
			var bar = document.createElement('span');
			bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#113';
			fpsGraph.appendChild(bar);
		}

		var msDiv = document.createElement('div');
		msDiv.id = 'ms';
		msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#020;display:none';
		container.appendChild(msDiv);

		var msText = document.createElement('div');
		msText.id = 'msText';
		msText.style.cssText = 'color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:8px;font-weight:bold;line-height:13px';
		msText.innerHTML = 'MS';
		msDiv.appendChild(msText);

		var msGraph = document.createElement('div');
		msGraph.id = 'msGraph';
		msGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0f0';
		msDiv.appendChild(msGraph);

		while (msGraph.children.length < 74) {
			var bar = document.createElement('span');
			bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#131';
			msGraph.appendChild(bar);
		}

		var infoDiv = document.createElement('div');
		infoDiv.id = 'info';
		infoDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#200';
		container.appendChild(infoDiv);

		var infoText = document.createElement('div');
		infoText.id = 'infoText';
		infoText.style.cssText = 'color:#f66;font-family:Helvetica,Arial,sans-serif;font-size:8px;font-weight:bold;line-height:13px';
		infoText.innerHTML = 'INFO';
		infoDiv.appendChild(infoText);

		var setModeP = function (value) {
			mode = value;
			switch (mode)
			{
			case 0:
				fpsDiv.style.display = 'block';
				msDiv.style.display = 'none';
				break;
			case 1:
				fpsDiv.style.display = 'none';
				msDiv.style.display = 'block';
				break;
			}
		};

		var updateGraph = function (dom, value) {
			var child = dom.appendChild(dom.firstChild);
			child.style.height = value + 'px';
		};

		this.domElement = container;
		this.setMode = setModeP;
		this.begin = function () {
			startTime = Date.now();
		};

		this.end = function (info) {
			var time = Date.now();

			if (time > prevTimeMs + 100) {
				ms = time - startTime;
				msMin = Math.min(msMin, ms);
				msMax = Math.max(msMax, ms);

				msText.textContent = ms + ' MS (' + msMin + '-' + msMax + ')';
				updateGraph(msGraph, Math.min(30, 30 - (ms / 200) * 30));

				prevTimeMs = time;

				if (info) {
					infoText.innerHTML = info;
				}
			}

			frames++;

			if (time > prevTime + 1000) {
				fps = Math.round((frames * 1000) / (time - prevTime));
				fpsMin = Math.min(fpsMin, fps);
				fpsMax = Math.max(fpsMax, fps);

				fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
				updateGraph(fpsGraph, Math.min(30, 30 - (fps / (Math.min(500, fpsMax) + 10)) * 30));

				prevTime = time;
				frames = 0;
			}

			return time;
		};

		this.update = function (info) {
			startTime = this.end(info);
		};
	}

	return Stats;
})();
goo.AudioContext = (function () {
	'use strict';

	// we presume there is support
	var supported = true;

	var AudioContext = window.AudioContext || window.webkitAudioContext;
	if (!AudioContext) {
		// warn once
		console.warn('WebAudio not supported');
		supported = false;
	}

	var context;

	return {
		getContext: function () {
			// try to get a context if it's supposedly supported or not cached
			if (!context && supported) {
				try {
					// even if window.AudioContext is available something might go wrong
					context = new AudioContext();
				} catch (e) {
					console.warn(e.message);
					supported = false;
				}
			}
			return context;
		},
		isSupported: function () {
			return supported;
		}
	};
})();
goo.SoundSystem = (function (
	System,
	AudioContext,
	MathUtils,
	SystemBus,
	Matrix4
) {
	'use strict';
	
	/**
	 * System responsible for sound.
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/addons/Sound/Sound-vtest.html Working example
	 * @extends System
	 */
	function SoundSystem() {
		this._isSupported = AudioContext.isSupported();
		if (!this._isSupported) {
			console.warn('Cannot create SoundSystem, WebAudio not supported');
			return;
		}
		System.call(this, 'SoundSystem', ['SoundComponent', 'TransformComponent']);

		this.entities = [];
		this._relativeTransform = new Matrix4();

		this._pausedSounds = {};
		
		this.initialized = false;

		/**
		 * @type {number}
		 * @readonly
		 */
		this.rolloffFactor = 0.4;

		/**
		 * @type {number}
		 * @readonly
		 */
		this.maxDistance = 100;

		/**
		 * @type {number}
		 * @readonly
		 */
		this.dopplerFactor = 0.05;

		/**
		 * @type {number}
		 * @readonly
		 */
		this.volume = 1;

		/**
		 * @type {number}
		 * @readonly
		 */
		this.reverb = 0;

		/**
		 * The muted state. To mute or unmute, see the mute() and unmute() methods.
		 * @type {boolean}
		 * @readonly
		 */
		this.muted = false;
		
		this.reverbAudioBuffer = null;

		this._reverbDirty = true;
		this._dirty = true;
		this._camera = null;

		var that = this;
		SystemBus.addListener('goo.setCurrentCamera', function (camConfig) {
			that._camera = camConfig.camera;
		});

		this._scheduledUpdates = [];
	}

	SoundSystem.prototype = Object.create(System.prototype);
	SoundSystem.prototype.constructor = SoundSystem;

	SoundSystem.prototype._initializeAudioNodes = function () {
		this._outNode = AudioContext.getContext().createGain();
		this._outNode.connect(AudioContext.getContext().destination);

		this._wetNode = AudioContext.getContext().createGain();
		this._wetNode.connect(this._outNode);
		this._wetNode.gain.value = 0.2;

		this._convolver = AudioContext.getContext().createConvolver();
		this._convolver.connect(this._wetNode);

		this._listener = AudioContext.getContext().listener;
		this._listener.dopplerFactor = 0;

		// Everything is relative to the camera
		this._listener.setPosition(0, 0, 0);
		this._listener.setVelocity(0, 0, 0);
		this._listener.setOrientation(
			0, 0, -1, // Orientation
			0, 1, 0  // Up
		);

		this.initialized = true;
	};

	/**
	 * Connect sound components output nodes to sound system buses. Called by world.process()
	 * @param {Entity} entity
	 * @private
	 */
	SoundSystem.prototype.inserted = function (entity) {
		if (!this.initialized) { this._initializeAudioNodes(); }

		entity.soundComponent.connectTo({
			dry: this._outNode,
			wet: this._convolver
		});

		entity.soundComponent._system = this;
	};

	/**
	 * Be sure to stop all playing sounds when a component is removed. Called by world.process()
	 * Sometimes this has already been done by the loader
	 * @param {Entity} entity
	 * @private
	 */
	SoundSystem.prototype.deleted = function (entity) {
		if (entity.soundComponent) {
			var sounds = entity.soundComponent.sounds;
			for (var i = 0; i < sounds.length; i++) {
				sounds[i].stop();
			}
			entity.soundComponent.connectTo();
			entity.soundComponent._system = null;
		}
	};

	/**
	 * Update the environmental sound system properties. The settings are applied on the next process().
	 * @param {Object} [config]
	 * @param {number} [config.dopplerFactor] How much doppler effect the sound will get.
	 * @param {number} [config.rolloffFactor] How fast the sound fades with distance.
	 * @param {number} [config.maxDistance] After this distance, sound will keep its volume.
	 * @param {number} [config.volume] Will be clamped between 0 and 1.
	 * @param {number} [config.reverb] Will be clamped between 0 and 1.
	 * @param {boolean} [config.muted]
	 */
	SoundSystem.prototype.updateConfig = function (config) {
		config = config || {};

		if(config.maxDistance !== undefined){
			this.maxDistance = config.maxDistance;
		}
		if(config.rolloffFactor !== undefined){
			this.rolloffFactor = config.rolloffFactor;
		}
		if(config.dopplerFactor !== undefined){
			this.dopplerFactor = config.dopplerFactor * 0.05; // 0.05 ??? I have no idea
		}
		if(config.volume !== undefined){
			this.volume = MathUtils.clamp(config.volume, 0, 1);
		}
		if(config.reverb !== undefined){
			this.reverb = MathUtils.clamp(config.reverb, 0, 1);
		}
		if(config.muted !== undefined){
			this.muted = config.muted;
		}
		
		this._dirty = true;
	};

	/**
	 * Set the reverb impulse response. The settings are not applied immediately.
	 * @param {AudioBuffer|null} [audioBuffer] if empty will also empty existing reverb
	 */
	SoundSystem.prototype.setReverb = function (audioBuffer) {
		this.reverbAudioBuffer = audioBuffer;
		this._reverbDirty = true;
	};

	/**
	 * Pause the sound system and thereby all sounds in the scene
	 */
	SoundSystem.prototype.pause = function () {
		if (this._pausedSounds) { return; }
		this._pausedSounds = {};
		for (var i = 0; i < this.entities.length; i++) {
			var sounds = this.entities[i].soundComponent.sounds;
			for (var j = 0; j < sounds.length; j++) {
				var sound = sounds[j];
				if (sound.isPlaying()) {
					sound.pause();
					this._pausedSounds[sound.id] = true;
				}
			}
		}
	};

	/**
	 * Mute all sounds.
	 */
	SoundSystem.prototype.mute = function () {
		this.muted = true;
		this._dirty = true;
	};

	/**
	 * Unmute all sounds.
	 */
	SoundSystem.prototype.unmute = function () {
		this.muted = false;
		this._dirty = true;
	};

	/**
	 * Resumes playing of all sounds that were paused
	 */
	SoundSystem.prototype.resume = function () {
		if (!this._pausedSounds) { return; }

		for (var i = 0; i < this.entities.length; i++) {
			var sounds = this.entities[i].soundComponent.sounds;
			for (var j = 0; j < sounds.length; j++) {
				var sound = sounds[j];
				if (this._pausedSounds[sound.id]) {
					sound.play();
				}
			}
		}
		this._pausedSounds = null;
	};

	/**
	 * Resumes playing of all sounds that were paused.
	 */
	SoundSystem.prototype.play = function(){
		this.resume();
		this.passive = false;
	};

	/**
	 * Stopping the sound system and all sounds in scene
	 */
	SoundSystem.prototype.stop = function () {
		for (var i = 0; i < this.entities.length; i++) {
			var sounds = this.entities[i].soundComponent.sounds;
			for (var j = 0; j < sounds.length; j++) {
				var sound = sounds[j];
				sound.stop();
			}
		}
		this._pausedSounds = null;
		this.passive = true;
	};

	SoundSystem.prototype.process = function (entities, tpf) {
		if (!this._isSupported || entities.length === 0) {
			return;
		}

		if (!this.initialized) {
			this._initializeAudioNodes();
		}

		if(this._reverbDirty){
			this._wetNode.disconnect();
			if (!this.reverbAudioBuffer && this._wetNode) {
				this._convolver.buffer = null;
			} else {
				this._convolver.buffer = this.reverbAudioBuffer;
				this._wetNode.connect(this._outNode);
			}
			this._reverbDirty = false;
		}

		if(this._dirty){
			this._listener.dopplerFactor = this.dopplerFactor;
			this._outNode.gain.value = this.muted ? 0 : this.volume;
			this._wetNode.gain.value = this.reverb;
			this._dirty = false;
		}

		this.entities = entities;
		var relativeTransform = this._relativeTransform;

		var viewMat;
		if (this._camera) {
			viewMat = this._camera.getViewMatrix();
		}

		for (var i = 0; i < entities.length; i++) {
			var e = entities[i];
			var component = e.soundComponent;

			component._attachedToCamera = !!(e.cameraComponent && e.cameraComponent.camera === this._camera);

			if (this._camera && !component._attachedToCamera) {
				// Give the transform relative to the camera
				relativeTransform.mul2(viewMat, e.transformComponent.worldTransform.matrix);
				component.process(this, relativeTransform, tpf);
			} else {
				// Component is attached to camera.
				component.process(this, null, tpf);
			}
		}
	};

	return SoundSystem;
})(goo.System,goo.AudioContext,goo.MathUtils,goo.SystemBus,goo.Matrix4);
goo.MeshDataComponent = (function (
	BoundingBox,
	Component,
	MeshData
) {
	'use strict';

	/**
	 * Holds the mesh data, like vertices, normals, indices etc. Also defines the local bounding volume.
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/components/MeshDataComponent/MeshDataComponent-example.html Working example
	 * @param {MeshData} meshData Target mesh data for this component.
	 * @extends Component
	 */
	function MeshDataComponent(meshData) {
		Component.apply(this, arguments);

		this.type = 'MeshDataComponent';

		/**
		 * @type {MeshData}
		 */
		this.meshData = meshData;

		/** Bounding volume in local space.
		 * @type {BoundingVolume}
		 */
		this.modelBound = new BoundingBox();

		/** Automatically compute bounding fit.
		 * @type {boolean}
		 * @default
		 */
		this.autoCompute = true;

		/**
		 * @type {SkeletonPose}
		 * @default
		 */
		this.currentPose = null; // SkeletonPose

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	MeshDataComponent.type = 'MeshDataComponent';

	MeshDataComponent.prototype = Object.create(Component.prototype);
	MeshDataComponent.prototype.constructor = MeshDataComponent;

	/**
	 * Set the bounding volume type (sphere, box etc).
	 *
	 * @param {BoundingVolume} modelBound Bounding to apply to this meshdata component.
	 * @param {boolean} autoCompute If true, automatically compute bounding fit.
	 */
	MeshDataComponent.prototype.setModelBound = function (modelBound, autoCompute) {
		this.modelBound = modelBound;
		this.autoCompute = autoCompute;
	};

	/**
	 * Compute bounding center and bounds for this mesh.
	 */
	MeshDataComponent.prototype.computeBoundFromPoints = function () {
		if (this.autoCompute && this.modelBound !== null && this.meshData) {
			var verts = this.meshData.getAttributeBuffer('POSITION');
			if (verts !== undefined) {
				this.modelBound.computeFromPoints(verts);
				this.autoCompute = false;
			}
		}
	};

	/**
	 * Returns a clone of this mesh data component
	 * @param {Object} [options]
	 * @param {boolean} [options.shareMeshData=false] Cloning this component clones the mesh data by default
	 * @returns {MeshDataComponent}
	 */
	MeshDataComponent.prototype.clone = function (options) {
		options = options || {};

		var clone = new MeshDataComponent();

		if (options.shareMeshData) {
			clone.meshData = this.meshData;
			clone.modelBound = this.modelBound;
		} else {
			clone.meshData = this.meshData.clone();
			clone.modelBound = this.modelBound.clone();
		}

		clone.autoCompute = this.autoCompute;

		return clone;
	};

	MeshDataComponent.applyOnEntity = function (obj, entity) {
		if (obj instanceof MeshData) {
			var meshDataComponent = new MeshDataComponent(obj);
			entity.setComponent(meshDataComponent);
			return true;
		}
	};

	return MeshDataComponent;
})(goo.BoundingBox,goo.Component,goo.MeshData);
goo.MeshRendererComponent = (function (
	Component,
	Material
) {
	'use strict';

	/**
	 * Defines the appearance of a mesh, through materials. Using several materials results in multi-pass rendering.
	 * @example-link http://code.gooengine.com/latest/examples/goo/entities/components/MeshRendererComponent/MeshRendererComponent-example.html Working example
	 * @extends Component
	 */
	function MeshRendererComponent(materials) {
		Component.apply(this, arguments);

		this.type = 'MeshRendererComponent';

		//! schteppe: Don't chain or nest ternary operators as it hard to read and confusing
		/** Materials to use when rendering
		 * @type {Array<Material>}
		 */
		this.materials = Array.isArray(materials) ? materials : materials ? [materials] : [];
		/** Worldspace bounding considering entity transformations
		 * @type {BoundingVolume}
		 */
		this.worldBound = null;

		/** Culling mode. Other valid values: 'Never'
		 * @type {string}
		 * @default
		 */
		this.cullMode = 'Dynamic'; //'Dynamic', 'Never'
		/**
		 * @type {boolean}
		 * @default
		 */
		this.castShadows = true;
		/**
		 * @type {boolean}
		 * @default
		 */
		this.receiveShadows = true;

		/**
		 * @type {boolean}
		 * @default
		 */
		this.isPickable = true;

		/**
		 * @type {boolean}
		 * @default
		 */
		this.isReflectable = true;

		/**
		 * @type {boolean}
		 * @default
		 */
		this.hidden = false;

		this._renderDistance = 0;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	MeshRendererComponent.type = 'MeshRendererComponent';

	MeshRendererComponent.prototype = Object.create(Component.prototype);
	MeshRendererComponent.prototype.constructor = MeshRendererComponent;

	MeshRendererComponent.prototype.api = {
		setDiffuse: function () {
			var material = this.meshRendererComponent.materials[0];
			if (!material.uniforms.materialDiffuse) {
				material.uniforms.materialDiffuse = [0, 0, 0, 1];
			}
			var diffuse = material.uniforms.materialDiffuse;

			//! AT: need to search for a pattern matching library; this is just ugly and unmaintainable
			if (arguments.length >= 3) {
				diffuse[0] = arguments[0];
				diffuse[1] = arguments[1];
				diffuse[2] = arguments[2];
				diffuse[3] = arguments.length === 3 ? 1 : arguments[3];
			} else {
				var arg = arguments[0];
				if (arg instanceof Array) {
					diffuse[0] = arg[0];
					diffuse[1] = arg[1];
					diffuse[2] = arg[2];
					diffuse[3] = arg.length === 3 ? 1 : arg[3];
				} else if (arg.r !== undefined && arg.g !== undefined && typeof arg.b !== undefined) {
					diffuse[0] = arg.r;
					diffuse[1] = arg.g;
					diffuse[2] = arg.b;
					diffuse[3] = arg.a === undefined ? 1 : arg.a;
				}
			}
		},
		getDiffuse: function () {
			return this.meshRendererComponent.materials[0].uniforms.materialDiffuse;
		}
	};

	MeshRendererComponent.entitySelectionAPI = {
		setDiffuse: MeshRendererComponent.prototype.api.setDiffuse
	};

	/**
	 * Update world bounding
	 *
	 * @param {BoundingVolume} bounding Bounding volume in local space
	 * @param {Transform} transform Transform to apply to local bounding -> world bounding
	 */
	MeshRendererComponent.prototype.updateBounds = function (bounding, transform) {
		this.worldBound = bounding.transform(transform, this.worldBound);
	};

	/**
	 * Returns a clone of this mesh renderer component
	 * @param {Object} [options]
	 * @param {boolean} [options.shareMaterials=false] Cloning this component clones the materials by default
	 * @returns {MeshRendererComponent}
	 */
	MeshRendererComponent.prototype.clone = function (options) {
		options = options || {};

		var clonedMaterials;

		if (options.shareMaterials) {
			clonedMaterials = this.materials;
		} else {
			clonedMaterials = this.materials.map(function (material) { return material.clone(options); });
		}

		var clone = new MeshRendererComponent(clonedMaterials);

		clone.cullMode = this.cullMode;
		clone.castShadows = this.castShadows;
		clone.receiveShadows = this.receiveShadows;
		clone.isPickable = this.isPickable;
		clone.isReflectable = this.isReflectable;

		return clone;
	};

	MeshRendererComponent.applyOnEntity = function (obj, entity) {
		var meshRendererComponent = entity.meshRendererComponent;

		if (!meshRendererComponent) {
			meshRendererComponent = new MeshRendererComponent();
		}

		// or a texture
		// or a {r, g, b} object
		var matched = false;
		if (obj instanceof Material) {
			meshRendererComponent.materials.push(obj);
			matched = true;
		}

		if (matched) {
			entity.setComponent(meshRendererComponent);
			return true;
		}
	};

	return MeshRendererComponent;
})(goo.Component,goo.Material);
goo.CameraComponent = (function (
	Component,
	Vector3,
	Camera,
	SystemBus
) {
	'use strict';

	/**
	 * Holds a camera.
	 * @param {Camera} camera Camera to contain in this component.
	 * @extends Component
	 */
	function CameraComponent (camera) {
		Component.apply(this, arguments);

		this.type = 'CameraComponent';

		/**
		 * The camera contained by the component.
		 * @type {Camera}
		 */
		this.camera = camera;

		/**
		 * Left vector.
		 * @type {Vector3}
		 * @default (-1, 0, 0)
		 */
		this.leftVec = new Vector3(-1, 0, 0);

		/**
		 * Up vector.
		 * @type {Vector3}
		 * @default (0, 1, 0)
		 */
		this.upVec = new Vector3(0, 1, 0);

		/**
		 * Direction vector.
		 * @type {Vector3}
		 * @default (0, 0, -1)
		 */
		this.dirVec = new Vector3(0, 0, -1);

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	CameraComponent.type = 'CameraComponent';

	CameraComponent.prototype = Object.create(Component.prototype);
	CameraComponent.prototype.constructor = CameraComponent;

	CameraComponent.prototype.api = {
		//! AT: the component holds no reference to its entity therefore this method could never stay on the component
		setAsMainCamera: function () {
			SystemBus.emit('goo.setCurrentCamera', {
				camera: this.cameraComponent.camera,
				entity: this
			});
			return this;
		}
	};

	/**
	 * @param {number} axisId Axis to use as up-vector (0=X, 1=Y, 2=Z).
	 */
	CameraComponent.prototype.setUpVector = function (axisId) {
		if (axisId === 0) {
			this.leftVec.setDirect(0, -1, 0);
			this.upVec.setDirect(1, 0, 0);
			this.dirVec.setDirect(0, 0, -1);
		} else if (axisId === 2) {
			this.leftVec.setDirect(-1, 0, 0);
			this.upVec.setDirect(0, 0, 1);
			this.dirVec.setDirect(0, -1, 0);
		} else {
			this.leftVec.setDirect(-1, 0, 0);
			this.upVec.setDirect(0, 1, 0);
			this.dirVec.setDirect(0, 0, -1);
		}
	};

	/**
	 * Updates the contained camera according to a transform (coming from the TransformComponent).
	 * @param {Transform} transform
	 */
	CameraComponent.prototype.updateCamera = function (transform) {
		this.camera._left.set(this.leftVec);
		//! AT: let's prevent scaling or skewing from spilling in the view(projection) matrix
//		transform.matrix.applyPostVector(this.camera._left);
		this.camera._left.applyPost(transform.rotation);

		this.camera._up.set(this.upVec);
//		transform.matrix.applyPostVector(this.camera._up);
		this.camera._up.applyPost(transform.rotation);

		this.camera._direction.set(this.dirVec);
//		transform.matrix.applyPostVector(this.camera._direction);
		this.camera._direction.applyPost(transform.rotation);

		transform.matrix.getTranslation(this.camera.translation);

		// RH: Don't update the frustum only the frame
		// this.camera.update();
		this.camera.onFrameChange();
	};

	CameraComponent.prototype.copy = function (source) {
		this.camera.copy(source.camera);
		this.leftVec.copy(source.leftVec);
		this.upVec.copy(source.upVec);
		this.dirVec.copy(source.dirVec);
		return this;
	};

	CameraComponent.prototype.clone = function () {
		var clone = new CameraComponent(this.camera.clone());

		clone.leftVec.copy(this.leftVec);
		clone.upVec.copy(this.upVec);
		clone.dirVec.copy(this.dirVec);

		return clone;
	};

	CameraComponent.applyOnEntity = function (obj, entity) {
		if (obj instanceof Camera) {
			var cameraComponent = new CameraComponent(obj);
			entity.setComponent(cameraComponent);
			return true;
		}
	};

	return CameraComponent;
})(goo.Component,goo.Vector3,goo.Camera,goo.SystemBus);
goo.LightComponent = (function (
	Component,
	Light
) {
	'use strict';

	/**
	 * Defines a light<br>
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/renderer/light/Lights-vtest.html Working example
	 * @param {Light} light Light to contain in this component (directional, spot, point)
	 * @extends Component
	 */
	function LightComponent(light) {
		Component.apply(this, arguments);

		this.type = 'LightComponent';

        /**
         * Light contained in this component.
         */
		this.light = light;

		/**
		 * @type {boolean}
		 * @default
		 */
		this.hidden = false;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	LightComponent.type = 'LightComponent';

	LightComponent.prototype = Object.create(Component.prototype);
	LightComponent.prototype.constructor = LightComponent;

	LightComponent.prototype.updateLight = function (transform) {
		this.light.update(transform);
	};

	LightComponent.prototype.copy = function (source) {
		// has to be the same sort of light
		this.light.copy(source);

		// the status depends on the entity and its ancestors
		this.hidden = source.hidden;

		return this;
	};

	LightComponent.prototype.clone = function () {
		var clone = new LightComponent(this.light.clone());

		// this status needs updating
		clone.hidden = this.hidden;
		return clone;
	};

	LightComponent.applyOnEntity = function (obj, entity) {
		if (obj instanceof Light) {
			var lightComponent = new LightComponent(obj);
			entity.setComponent(lightComponent);
			return true;
		}
	};

	return LightComponent;
})(goo.Component,goo.Light);
goo.ScriptComponent = (function (
	Component,
	SystemBus,
	Scripts,
	_
) {
	'use strict';

	/**
	 * Contains scripts to be executed each frame when set on an active entity.
	 * @param {(Object|Array<Object>)} [scripts] A script-object or an array of script-objects to attach to the
	 * entity.
	 * The script-object needs to define the function <code>run({@link Entity} entity, number tpf)</code>,
	 * which runs on every frame update.
	 *
	 * The script object can also define the function <code>setup({@link Entity} entity)</code>, called upon script creation.
	 * @extends Component
	 */
	function ScriptComponent(scripts) {
		Component.apply(this, arguments);

		this.type = 'ScriptComponent';

		if (scripts instanceof Array) {
			this.scripts = scripts;
		} else if (scripts) {
			this.scripts = [scripts];
		} else {
			/**
			* Array of scripts tied to this script component. Scripts can be added to the component
			* using the constructor or by manually adding to the array.
			* @type {Array}
			* @example
			* // Add a script to script component
			* var scriptComponent = new ScriptComponent();
			* var controlScript = new WasdControlScript();
			* scriptComponent.scripts.push(controlScript);
			*/
			this.scripts = [];
		}

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	ScriptComponent.type = 'ScriptComponent';

	ScriptComponent.prototype = Object.create(Component.prototype);
	ScriptComponent.prototype.constructor = ScriptComponent;

	/**
	 * Runs the .setup method on each script; called when the ScriptComponent is
	 * attached to the entity or when the entity is added to the world.
	 *
	 * @private
	 * @param entity
	 */
	ScriptComponent.prototype.setup = function (entity) {
		var systemContext = entity._world.getSystem('ScriptSystem').context;
		var componentContext = Object.create(systemContext);
		_.extend(componentContext, {
			entity: entity,
			entityData: {}
		});

		for (var i = 0; i < this.scripts.length; i++) {
			var script = this.scripts[i];
			if (!script.context) {
				script.context = Object.create(componentContext);

				if (script.parameters && script.parameters.enabled !== undefined) {
					script.enabled = script.parameters.enabled;
				} else {
					script.enabled = true;
				}

				if (script.setup && script.enabled) {
					try {
						script.setup(script.parameters, script.context, window.goo);
					} catch (e) {
						this._handleError(script, e, 'setup');
					}
				}
			}
		}
	};

	/**
	 * Called when script component is attached to entity.
	 * @private
	 * @type {setup}
	 */
	//ScriptComponent.prototype.attached = ScriptComponent.prototype.setup;

	/**
	 * Runs the update function on every script attached to this entity.
	 * @private
	 * @param entity {Entity}
	 * @param tpf {number}
	 * @param context
	 */
	ScriptComponent.prototype.run = function (entity) {
		for (var i = 0; i < this.scripts.length; i++) {
			var script = this.scripts[i];
			if (script && script.run && (script.enabled === undefined || script.enabled)) {
				try {
					script.run(entity, entity._world.tpf, script.context, script.parameters);
				} catch (e) {
					this._handleError(script, e, 'run');
				}
			} else if (script.update && (script.enabled === undefined || script.enabled)) {
				try {
					script.update(script.parameters, script.context, window.goo);
				} catch (e) {
					this._handleError(script, e, 'update');
				}
			}
		}
	};

	/**
	 * Reverts any changes done by setup; called when the entity loses its ScriptComponent or is removed from the world.
	 * @private
	 */
	ScriptComponent.prototype.cleanup = function () {
		for (var i = 0; i < this.scripts.length; i++) {
			var script = this.scripts[i];
			if (script.context) {
				if (script.cleanup &&
					(script.parameters && script.parameters.enabled !== undefined ?
						script.parameters.enabled :
						script.enabled)
				) {
					try {
						script.cleanup(script.parameters, script.context, window.goo);
					} catch (e) {
						this._handleError(script, e, 'cleanup');
					}
				}
				script.enabled = false;
				script.context = null;
			}
		}
	};

	/**
	 * Enables all the scripts that are in the component.
	 */
	ScriptComponent.prototype.startScripts = function () {
		this.scripts.forEach(function (script) {
			if (script.parameters && script.parameters.enabled === false) {
				script.enabled = false;
			} else {
				script.enabled = true;
			}
		});
	};

	/**
	 * Disables all the scripts that are in the component.
	 */
	ScriptComponent.prototype.stopScripts = function () {
		this.scripts.forEach(function (script) {
			script.enabled = false;
		});
	};

	/**
	 * Formats the error and sends it to the systembus
	 * @private
	 */
	ScriptComponent.prototype._handleError = function (script, error, phase) {
		script.enabled = false;
		var err = {
			id: script.id,
			errors: [{
				message: error.message || error,
				phase: phase
			}]
		};
		// TODO Test if this works across browsers
		/**/
		if (error instanceof Error) {
			var lineNumbers = error.stack.split('\n')[1].match(/(\d+):\d+\)$/);
			if (lineNumbers) {
				err.line = parseInt(lineNumbers[1], 10) - 1;
			}
		}
		/**/
		console.error(err.errors[0].message, err);
		SystemBus.emit('goo.scriptError', err);
	};

	/**
	 * Called when script component is detached from entity.
	 * @private
	 * @type {setup}
	 */
	//ScriptComponent.prototype.detached = ScriptComponent.prototype.cleanup;

	/**
	 * Attempts to add a script to an entity. The object can be a { run: Function } object or a Function. The entity is supposed to get a ScriptComponent with a script created out of the passed object
	 * @private
	 * @param obj {Function | { run: Function }}
	 * @param entity {Entity}
	 * @returns {boolean}
	 */
	ScriptComponent.applyOnEntity = function (obj, entity) {
		if (obj instanceof Function || (obj && obj.run instanceof Function) || (obj && obj.update instanceof Function)) {
			var scriptComponent;
			if (!entity.scriptComponent) {
				scriptComponent = new ScriptComponent();
				entity.setComponent(scriptComponent);
			} else {
				scriptComponent = entity.scriptComponent;
			}
			scriptComponent.scripts.push(obj.run instanceof Function || obj.update instanceof Function ? obj : { run: obj });

			return true;
		}
	};

	return ScriptComponent;
})(goo.Component,goo.SystemBus,goo.Scripts,goo.ObjectUtils);
goo.SoundComponent = (function (
	Component,
	AudioContext,
	Vector3,
	MathUtils
) {
	'use strict';

	//! AT: every method here is prefixed with a check for AudioContext. Is it really needed? can it just be refactored away?
	//Or, isn't just one (the first) warning enough - it might ruing everything if flooding the console

	/**
	 * Component that adds sound to an entity.
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/addons/Sound/Sound-vtest.html Working example
	 * @extends {Component}
	 */
	function SoundComponent() {
		Component.apply(this, arguments);

		this.type = 'SoundComponent';

		this._system = null;

		/**
		 * Current sounds in the entity. Add a sound using {@link SoundComponent#addSound}.
		 * @type {Array<Sound>}
		 */
		this.sounds = [];

		this._isPanned = true;
		this._outDryNode = AudioContext.getContext().createGain();
		this._outWetNode = AudioContext.getContext().createGain();
		this.connectTo();
		this._pannerNode = AudioContext.getContext().createPanner();
		this._pannerNode.connect(this._outDryNode);
		this._inNode = AudioContext.getContext().createGain();
		this._inNode.connect(this._pannerNode);

		// The 2D sounds are always in camera space
		// Do we need another outDryNode for 2D?
		this._inNode2d = AudioContext.getContext().createGain();
		this._inNode2d.connect(this._outDryNode);

		this._oldPosition = new Vector3();
		this._position = new Vector3();
		this._orientation = new Vector3();
		this._velocity = new Vector3();
		this._attachedToCamera = false;
		
		this._autoPlayDirty = false;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	SoundComponent.type = 'SoundComponent';

	SoundComponent.prototype = Object.create(Component.prototype);
	SoundComponent.prototype.constructor = SoundComponent;

	/**
	 * Add a sound to the component
	 * @param {Sound} sound
	 */
	SoundComponent.prototype.addSound = function (sound) {
		if (this.sounds.indexOf(sound) === -1) {
			if(sound.spatialize){
				sound.connectTo([this._inNode, this._outWetNode]);
			} else {
				sound.connectTo([this._inNode2d]);
			}
			this.sounds.push(sound);
			this._autoPlayDirty = true;
		}
	};

	/**
	 * Remove sound from component
	 * @param {Sound} sound
	 */
	SoundComponent.prototype.removeSound = function (sound) {
		var idx = this.sounds.indexOf(sound);
		if (idx > -1) {
			sound.stop();
			this.sounds.splice(idx, 1);

			if(sound.spatialize){
				sound.disconnectFrom([this._inNode, this._outWetNode]);
			} else {
				sound.disconnectFrom([this._inNode2d]);
			}
		}
	};

	/**
	 * Get a component's sound by id
	 * @param {string} id
	 * @returns {Sound}
	 */
	SoundComponent.prototype.getSoundById = function (id) {
		for (var i = 0; i < this.sounds.length; i++) {
			if (this.sounds[i].id === id) {
				return this.sounds[i];
			}
		}
	};

	/**
	 * Connect output of component to audionodes
	 * @param {Object} [nodes]
	 * @param {AudioNode} [nodes.dry]
	 * @param {AudioNode} [nodes.wet]
	 */
	SoundComponent.prototype.connectTo = function (nodes) {
		this._outDryNode.disconnect();
		this._outWetNode.disconnect();
		if (nodes && nodes.dry) {
			this._outDryNode.connect(nodes.dry);
		}
		if (nodes && nodes.wet) {
			this._outWetNode.connect(nodes.wet);
		}
	};

	/**
	 * Updates the component valueas according to config
	 * @param {Object} [config]
	 * @param {number} [config.volume] A number between 0 and 1.
	 * @param {number} [config.reverb] A number between 0 and 1.
	 */
	SoundComponent.prototype.updateConfig = function (config) {
		if (config.volume !== undefined) {
			this._outDryNode.gain.value = MathUtils.clamp(config.volume, 0, 1);
		}
		if (config.reverb !== undefined) {
			this._outWetNode.gain.value = MathUtils.clamp(config.reverb, 0, 1);
		}
	};

	SoundComponent.prototype._autoPlaySounds = function () {
		var sounds = this.sounds;
		for (var i = 0; i < sounds.length; i++) {
			var sound = sounds[i];
			if (sound.autoPlay) {
				sound.play();
			}
		}
	};

	/**
	 * Updates position, velocity and orientation of component and thereby all connected sounds.
	 * Since all sounds in the engine are relative to the current camera, the model view matrix needs to be passed to this method.
	 * @param {Object} settings See {@link SoundSystem}
	 * @param {Matrix4} mvMat The model view matrix from the current camera, or falsy if the component is attached to the camera.
	 * @param {number} tpf
	 * @hidden
	 */
	SoundComponent.prototype.process = function (settings, mvMat, tpf) {
		this._pannerNode.rolloffFactor = settings.rolloffFactor;
		this._pannerNode.maxDistance = settings.maxDistance;

		if (this._autoPlayDirty && this._system && !this._system.passive) {
			this._autoPlaySounds();
			this._autoPlayDirty = false;
		}

		if (this._attachedToCamera || !mvMat) {
			// The component is attached to the current camera.
			if (this._isPanned) {
				this._inNode.disconnect();
				this._inNode.connect(this._outDryNode);
				this._isPanned = false;
			}
			this._pannerNode.setPosition(0, 0, 0);
			this._pannerNode.setVelocity(0, 0, 0);
			this._pannerNode.setOrientation(0, 0, 0);
			return;
		} else if (!this._isPanned) {
			this._inNode.disconnect();
			this._inNode.connect(this._pannerNode);
			this._isPanned = true;
		}

		mvMat.getTranslation(this._position);
		if (tpf > 0) {
			this._velocity.set(this._position).sub(this._oldPosition).scale(1 / tpf);
		} else {
			this._velocity.setDirect(0, 0, 0);
		}
		this._oldPosition.set(this._position);
		this._orientation.setDirect(0, 0, -1);
		this._orientation.applyPostVector(mvMat);

		this._pannerNode.setPosition(this._position.x, this._position.y, this._position.z);
		this._pannerNode.setVelocity(this._velocity.x, this._velocity.y, this._velocity.z);
		this._pannerNode.setOrientation(this._orientation.x, this._orientation.y, this._orientation.z);
	};

	return SoundComponent;
})(goo.Component,goo.AudioContext,goo.Vector3,goo.MathUtils);
goo.GameUtils = (function () {
	'use strict';

	/**
	 * Shims for standard gaming features
	 * Only used to define the class. Should never be instantiated.
	 */
	function GameUtils () {}

	/** Supported features. All true by default.
	 * @type {Object}
	 * @property {boolean} fullscreen
	 * @property {boolean} pointerLock
	 */
	GameUtils.supported = {
		fullscreen: true,
		pointerLock: true
	};

	/**
	 * Attempts to request fullscreen.
	 */
	GameUtils.requestFullScreen = function () {
		if (!document.fullscreenElement && document.documentElement.requestFullScreen) {
			document.documentElement.requestFullScreen();
		}
	};

	/**
	 * Attempts to exit fullscreen.
	 */
	GameUtils.exitFullScreen = function () {
		if (document.fullscreenElement && document.cancelFullScreen) {
			document.cancelFullScreen();
		}
	};

	/**
	 * Attempts to toggle fullscreen.
	 */
	GameUtils.toggleFullScreen = function () {
		if (!document.fullscreenElement) {
			if (document.documentElement.requestFullScreen) {
				document.documentElement.requestFullScreen();
			}
		} else {
			if (document.cancelFullScreen) {
				document.cancelFullScreen();
			}
		}
	};

	/**
	 * Attempts to lock the mouse pointer in the window.
	 */
	GameUtils.requestPointerLock = function (optionalTarget) {
		var target = optionalTarget || document.documentElement;
		if (target.requestPointerLock) {
			target.requestPointerLock();
		}
	};

	/**
	 * Attempts to unlock the mouse pointer in the window.
	 */
	GameUtils.exitPointerLock = function () {
		if (document.exitPointerLock) {
			document.exitPointerLock();
		}
	};

	/**
	 * Attempts to toggle the lock on the mouse pointer in the window.
	 */
	GameUtils.togglePointerLock = function (optionalTarget) {
		if (!document.pointerLockElement) {
			GameUtils.requestPointerLock(optionalTarget);
		} else {
			GameUtils.exitPointerLock();
		}
	};

	var visibilityChangeListeners = [];

	/**
	 * Add a visibilitychange listener.
	 * @param {Function} callback function called with a boolean (true=hidden, false=visible)
	 */
	GameUtils.addVisibilityChangeListener = function (callback) {
		if (typeof callback !== 'function') {
			return;
		}

		var vendors = ['', 'ms', 'moz', 'webkit'];

		var hidden, visibilityChange;
		for (var x = 0; x < vendors.length; ++x) {
			var hiddenAttribute = vendors[x] + (vendors[x].length === 0 ? 'hidden' : 'Hidden');
			var visibilityAttribute = vendors[x] + 'visibilitychange';

			if (typeof document[hiddenAttribute] !== 'undefined') {
				hidden = hiddenAttribute;
				visibilityChange = visibilityAttribute;
				break;
			}
		}

		if (typeof document.addEventListener !== 'undefined' &&
			typeof hidden !== 'undefined') {
			var eventListener = function () {
				if (document[hidden]) {
					callback(true);
				} else {
					callback(false);
				}
			};
			visibilityChangeListeners.push({
				eventName: visibilityChange,
				eventListener: eventListener
			});
			document.addEventListener(visibilityChange, eventListener);
		}
	};

	GameUtils.clearVisibilityChangeListeners = function () {
		visibilityChangeListeners.forEach(function (listener) {
			document.removeEventListener(listener.eventName, listener.eventListener);
		});
		visibilityChangeListeners = [];
	};

	/**
	 * Attempts to initialize all shims (animation, fullscreen, pointer lock).
	 * @param {Element} [global=window] The global element (for compatibility checks and patching)
	 */
	GameUtils.initAllShims = function (global) {
		GameUtils.initWebGLShims();
		GameUtils.initAnimationShims();
		GameUtils.initFullscreenShims(global);
		GameUtils.initPointerLockShims(global);
	};

	/**
	 * Handle missing WebGL features like IE 11 Uint8ClampedArray
	 */
	GameUtils.initWebGLShims = function () {
		window.Uint8ClampedArray = window.Uint8ClampedArray || window.Uint8Array;
	};

	/**
	 * Attempts to initialize the animation shim, ie. defines requestAnimationFrame and cancelAnimationFrame
	 */
	GameUtils.initAnimationShims = function () {
		var lastTime = 0;
		var vendors = ['ms', 'moz', 'webkit', 'o'];

		for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
			window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
			window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
		}

		if (window.requestAnimationFrame === undefined) {
			window.requestAnimationFrame = function (callback) {
				var currTime = Date.now(), timeToCall = Math.max(0, 16 - (currTime - lastTime));
				var id = window.setTimeout(function () {
						callback(currTime + timeToCall);
					}, timeToCall);
				lastTime = currTime + timeToCall;
				return id;
			};
		}

		if (window.cancelAnimationFrame === undefined) {
			window.cancelAnimationFrame = function (id) {
				clearTimeout(id);
			};
		}
	};

	/**
	 * Attempts to initialize the fullscreen shim, ie. defines requestFullscreen and cancelFullscreen
	 * @param {Element} [global=window] The global element (for compatibility checks and patching)
	 */
	GameUtils.initFullscreenShims = function (global) {
		global = global || window;
		var elementPrototype = (global.HTMLElement || global.Element).prototype;

		if (!document.hasOwnProperty('fullscreenEnabled')) {
			var getter = (function () {
				if ('webkitIsFullScreen' in document) {
					return function () {
						return document.webkitFullscreenEnabled;
					};
				}
				if ('mozFullScreenEnabled' in document) {
					return function () {
						return document.mozFullScreenEnabled;
					};
				}

				GameUtils.supported.fullscreen = false;

				return function () {
					return false;
				};
			})();

			Object.defineProperty(document, 'fullscreenEnabled', {
				enumerable: true,
				configurable: false,
				writeable: false,
				get: getter
			});
		}

		if (!document.hasOwnProperty('fullscreenElement')) {
			var getter = (function () {
				var name = ['webkitCurrentFullScreenElement', 'webkitFullscreenElement', 'mozFullScreenElement'];

				var getNameInDocument = function (i) {
					return function () {
						return document[name[i]];
					};
				};

				for (var i = 0; i < name.length; i++) {
					if (name[i] in document) {
						return getNameInDocument(i);
					}
				}
				return function () {
					return null;
				};
			})();

			Object.defineProperty(document, 'fullscreenElement', {
				enumerable: true,
				configurable: false,
				writeable: false,
				get: getter
			});
		}

		function fullscreenchange () {
			var newEvent = document.createEvent('CustomEvent');
			newEvent.initCustomEvent('fullscreenchange', true, false, null);
			document.dispatchEvent(newEvent);
		}
		document.addEventListener('webkitfullscreenchange', fullscreenchange, false);
		document.addEventListener('mozfullscreenchange', fullscreenchange, false);

		function fullscreenerror () {
			var newEvent = document.createEvent('CustomEvent');
			newEvent.initCustomEvent('fullscreenerror', true, false, null);
			document.dispatchEvent(newEvent);
		}
		document.addEventListener('webkitfullscreenerror', fullscreenerror, false);
		document.addEventListener('mozfullscreenerror', fullscreenerror, false);

		if (!elementPrototype.requestFullScreen) {
			elementPrototype.requestFullScreen = (function () {
				if (elementPrototype.webkitRequestFullScreen) {
					return function () {
						this.webkitRequestFullScreen(global.Element.ALLOW_KEYBOARD_INPUT);
					};
				}

				if (elementPrototype.mozRequestFullScreen) {
					return function () {
						this.mozRequestFullScreen();
					};
				}

				return function () {
				};
			})();
		}

		if (!document.cancelFullScreen) {
			document.cancelFullScreen = (function () {
				return document.webkitCancelFullScreen || document.mozCancelFullScreen || function () {
				};
			})();
		}
	};

	/**
	 * Attempts to initialize the pointer lock shim, ie. define requestPointerLock and exitPointerLock
	 * @param {Element} [global=window] The global element (for compatibility checks and patching)
	 */
	GameUtils.initPointerLockShims = function (global) {
		global = global || window;
		var elementPrototype = (global.HTMLElement || global.Element).prototype;

		if (!global.MouseEvent) {
			return;
		}

		var mouseEventPrototype = global.MouseEvent.prototype;

		if (!('movementX' in mouseEventPrototype)) {
			Object.defineProperty(mouseEventPrototype, 'movementX', {
				enumerable: true,
				configurable: false,
				writeable: false,
				get: function () {
					return this.webkitMovementX || this.mozMovementX || 0;
				}
			});
		}

		if (!('movementY' in mouseEventPrototype)) {
			Object.defineProperty(mouseEventPrototype, 'movementY', {
				enumerable: true,
				configurable: false,
				writeable: false,
				get: function () {
					return this.webkitMovementY || this.mozMovementY || 0;
				}
			});
		}

		if (!navigator.pointer) {
			navigator.pointer = navigator.webkitPointer || navigator.mozPointer;
		}

		function pointerlockchange () {
			var newEvent = document.createEvent('CustomEvent');
			newEvent.initCustomEvent('pointerlockchange', true, false, null);
			document.dispatchEvent(newEvent);
		}
		document.addEventListener('webkitpointerlockchange', pointerlockchange, false);
		document.addEventListener('webkitpointerlocklost', pointerlockchange, false);
		document.addEventListener('mozpointerlockchange', pointerlockchange, false);
		document.addEventListener('mozpointerlocklost', pointerlockchange, false);

		function pointerlockerror () {
			var newEvent = document.createEvent('CustomEvent');
			newEvent.initCustomEvent('pointerlockerror', true, false, null);
			document.dispatchEvent(newEvent);
		}
		document.addEventListener('webkitpointerlockerror', pointerlockerror, false);
		document.addEventListener('mozpointerlockerror', pointerlockerror, false);

		if (!("pointerLockElement" in document)) {
			var getter = (function () {
				if ('webkitPointerLockElement' in document) {
					return function () {
						return document.webkitPointerLockElement;
					};
				}
				if ('mozPointerLockElement' in document) {
					return function () {
						return document.mozPointerLockElement;
					};
				}
				return function () {
					return null;
				};
			})();

			Object.defineProperty(document, 'pointerLockElement', {
				enumerable: true,
				configurable: false,
				writeable: false,
				get: getter
			});
		}

		if (!elementPrototype.requestPointerLock) {
			elementPrototype.requestPointerLock = (function () {
				if (elementPrototype.webkitRequestPointerLock) {
					return function () {
						this.webkitRequestPointerLock();
					};
				}

				if (elementPrototype.mozRequestPointerLock) {
					return function () {
						this.mozRequestPointerLock();
					};
				}

				if (navigator.pointer) {
					return function () {
						navigator.pointer.lock(this, pointerlockchange, pointerlockerror);
					};
				}

				GameUtils.supported.pointerLock = false;

				return function () {};
			})();
		}

		if (!document.exitPointerLock) {
			document.exitPointerLock = (function () {
				return document.webkitExitPointerLock || document.mozExitPointerLock || function () {
					if (navigator.pointer) {
						navigator.pointer.unlock();
					}
				};
			})();
		}
	};

	return GameUtils;
})();
goo.Logo = (function () {
	'use strict';
	/**
	 * Get logo svg in different formats
	 * Only used to define the class. Should never be instantiated.
	 */
	function Logo() {}

	/** @type {string} */
	Logo.blue = '#2A3276';
	/** @type {string} */
	Logo.white = '#FFFFFF';

	var defaults = {
		color: Logo.white,
		shadow: false
	};

	/**
	 * Get svg as string to add to html DOM
	 * @param {Object} properties
	 * @param {string} [properties.color=Logo.blue]
	 * @param {boolean} [properties.shadow=false]
	 * @param {string} [properties.width]
	 * @param {string} [properties.height]
	 */
	Logo.getLogo = function (properties) {
		properties = properties || {};
		for (var key in defaults) {
			if (properties[key] === undefined) {
				properties[key] = defaults[key];
			}
		}

		if (!document.createElementNS) { return ''; }

		var xmlns = 'http://www.w3.org/2000/svg';
		var svg = document.createElementNS(xmlns, 'svg');
		svg.setAttribute('version', '1.1');
		svg.setAttribute('xmlns', xmlns);
		svg.setAttribute('x', '0px');
		svg.setAttribute('y', '0px');
		svg.setAttribute('viewBox', '0 0 396.603 277.343');
		svg.setAttribute('enable-background', 'new 0 0 396.603 277.343');
		svg.setAttribute('xml:space', 'preserve');


		if (properties.width) {
			svg.setAttribute('width', properties.width);
		}
		if (properties.height) {
			svg.setAttribute('height', properties.height);
		}

		var g = document.createElementNS(xmlns, 'g');

		svg.appendChild(g);


		var shadowFilter = document.createElementNS(xmlns, 'filter');
		shadowFilter.setAttribute('id', 'insetShadow');

		var gauss = document.createElementNS(xmlns, 'feGaussianBlur');
		gauss.setAttribute('in', 'SourceAlpha');
		gauss.setAttribute('stdDeviation', '0');

		var offset = document.createElementNS(xmlns, 'feOffset');
		offset.setAttribute('dx', '0');
		offset.setAttribute('dy', '-5');
		offset.setAttribute('result', 'offsetblur');

		var compTransfer = document.createElementNS(xmlns, 'feComponentTransfer');
		var funcA = document.createElementNS(xmlns, 'feFuncA');
		funcA.setAttribute('type', 'linear');
		funcA.setAttribute('slope', '0.5');
		compTransfer.appendChild(funcA);

		var merge = document.createElementNS(xmlns, 'feMerge');
		var mn1 = document.createElementNS(xmlns, 'feMergeNode');
		var mn2 = document.createElementNS(xmlns, 'feMergeNode');
		mn2.setAttribute('in', 'SourceGraphic');
		merge.appendChild(mn1);
		merge.appendChild(mn2);

		shadowFilter.appendChild(gauss);
		shadowFilter.appendChild(offset);
		shadowFilter.appendChild(compTransfer);
		shadowFilter.appendChild(merge);

		g.appendChild(shadowFilter);
		var path = document.createElementNS(xmlns, 'path');
		path.setAttribute('d', 'M303.337,46.286c-13.578,0-25.784,5.744-34.396,14.998c-9.86,10.59-26.319,10.59-36.172,0' +
			'c-8.605-9.254-20.818-14.998-34.402-14.998c-25.936,0-46.971,21.034-46.971,46.978c0,25.936,21.035,46.972,46.971,46.972' +
			'c13.584,0,25.797-5.744,34.402-14.998c9.853-10.598,26.325-10.598,36.172,0c8.612,9.254,20.818,14.998,34.396,14.998' +
			'c25.941,0,46.977-21.036,46.977-46.972C350.313,67.32,329.278,46.286,303.337,46.286z M198.296,116.39' +
			'c-12.785,0-23.146-10.359-23.146-23.144s10.361-23.151,23.146-23.151c12.795,0,23.156,10.367,23.156,23.151' +
			'S211.091,116.39,198.296,116.39z M303.337,116.407c-12.785,0-23.146-10.36-23.146-23.144c0-12.784,10.36-23.151,23.146-23.151' +
			'c12.795,0,23.156,10.367,23.156,23.151C326.493,106.047,316.132,116.407,303.337,116.407z M156.18,138.347' +
			'c-14.087-3.23-22.316-17.482-18.068-31.305c3.704-12.072,2.568-25.511-4.22-37.256C120.927,47.323,92.22,39.63,69.766,52.587' +
			'C47.317,65.552,39.624,94.26,52.581,116.713c6.795,11.761,17.853,19.462,30.17,22.282c14.084,3.235,22.314,17.497,18.074,31.317' +
			'c-3.711,12.08-2.582,25.504,4.213,37.264c12.965,22.455,41.666,30.148,64.127,17.178c22.447-12.945,30.148-41.658,17.185-64.111' +
			'C179.554,148.881,168.497,141.181,156.18,138.347z M104.802,113.287c-11.064,6.387-25.219,2.599-31.604-8.474' +
			'c-6.397-11.07-2.604-25.225,8.474-31.609c11.057-6.398,25.22-2.598,31.611,8.46C119.673,92.741,115.872,106.897,104.802,113.287z' +
			' M145.687,207.256c-12.785,0-23.145-10.361-23.145-23.145s10.359-23.15,23.145-23.15c12.797,0,23.156,10.367,23.156,23.15' +
			'S158.483,207.256,145.687,207.256z');
		path.setAttribute('fill', properties.color);
		if (properties.shadow) {
			g.appendChild(shadowFilter);
			path.setAttribute('style', 'filter:url(#insetShadow)');
		}
		g.appendChild(path);

		var serializer = new XMLSerializer();
		var str = serializer.serializeToString(svg);
		return str;
	};

	return Logo;
})();
goo.GooRunner = (function (
	World,
	Renderer,
	TransformSystem,
	RenderSystem,
	BoundingUpdateSystem,
	ScriptSystem,
	LightingSystem,
	CameraSystem,
	ParticlesSystem,
	Stats,

	AudioContext,
	SoundSystem,

	TransformComponent,
	MeshDataComponent,
	MeshRendererComponent,
	CameraComponent,
	LightComponent,
	ScriptComponent,
	SoundComponent,

	GameUtils,
	Logo,

	SystemBus,
	Material
) {
	'use strict';

	/**
	 * The main class that updates the world and calls the renderers.
	 * See [this engine overview article]{@link http://www.gootechnologies.com/learn/tutorials/engine/engine-overview/} for more info.
	 *
	 * @param {Object} [parameters] GooRunner settings passed in a JSON object
	 * @param {boolean} [parameters.alpha=false] Specifies if the canvas should have an alpha channel or not.
	 * @param {boolean} [parameters.premultipliedAlpha=true] Enables or disables premultiplication of color by alpha
	 * @param {boolean} [parameters.antialias=true] Specifies if antialiasing should be turned on or no
	 * @param {boolean} [parameters.stencil=false] Enables the stencil buffer
	 * @param {boolean} [parameters.preserveDrawingBuffer=false] By default the drawing buffer will be cleared after it is presented to the HTML compositor. Enable this option to not clear the drawing buffer
	 * @param {HTMLCanvasElement}  [parameters.canvas] If not supplied, Renderer will create a new canvas
	 * @param {boolean} [parameters.showStats=false] If enabled a small stats widget showing stats will be displayed
	 * @param {boolean} [parameters.useDevicePixelRatio=false] Take into account the device pixel ratio (for retina screens etc)
	 * @param {boolean} [parameters.manuallyStartGameLoop=false] By default the 'game loop' will start automatically. Enable this option to manually start the game loop at any time
	 * @param {(boolean | string | { position, color })} [parameters.logo='topright'] Specifies whether the Goo logo is visible or not and where should and be placed and what color should it have.
	 * If the parameter is not specified then the logo is placed in the top right corner.
	 * If no logo is desired then this parameter should have the 'false' value.
	 * If the supplied parameter is one of the following: 'topleft', 'topright', 'bottomleft', 'bottomright' then the logo will be positioned in the according corner
	 * If the parameter is of type object then the logo will be positioned according to the 'position' key and will be colored according to the 'color' key
	 * @param {boolean} [parameters.tpfSmoothingCount=10] Specifies the amount of previous frames to use when computing the 'time per frame'
	 * @param {boolean} [parameters.debugKeys=false] If enabled the hotkeys Shift+[1..6] will be enabled
	 * @param {boolean} [parameters.useTryCatch=true]
	 */
	function GooRunner(parameters) {
		parameters = parameters || {};

		GameUtils.initAllShims();

		/**
		 * Automatically created Goo world.
		 * @type {World}
		 */
		this.world = new World(this);

		/**
		 * Automatically created renderer.
		 * @type {Renderer}
		 */
		this.renderer = new Renderer(parameters);

		/**
		 * Set to true to run user-defined callbacks within try/catch statements. Errors will be printed to console.
		 * @type {boolean}
		 * @default true
		 */
		this.useTryCatch = parameters.useTryCatch !== undefined ? parameters.useTryCatch : true;

		this._setBaseSystems();
		this._registerBaseComponents();

		this.doProcess = true;
		this.doRender = true;

		this.tpfSmoothingCount = parameters.tpfSmoothingCount !== undefined ? parameters.tpfSmoothingCount : 10;

		if (parameters.showStats) {
			this.stats = new Stats();
			this.stats.domElement.style.position = 'absolute';
			this.stats.domElement.style.left = '10px';
			this.stats.domElement.style.top = '10px';
			document.body.appendChild(this.stats.domElement);
		}
		if (parameters.logo === undefined || parameters.logo) {
			var logoDiv = this._buildLogo(parameters.logo);
			if (logoDiv) {
				document.body.appendChild(logoDiv);
			}
		}

		/**
		 * A list of callbacks to call every frame, before the world is processed.
		 * @type {Array<function (tpf: number)>}
		 */
		this.callbacksPreProcess = [];

		/**
		 * A list of callbacks to call every frame, after the world is processed and before the rendering is done.
		 * @type {Array<function (tpf: number)>}
		 */
		this.callbacksPreRender = [];

		/**
		 * A list of callbacks to call every frame, after the rendering is done.
		 * @type {Array<function (tpf: number)>}
		 */
		this.callbacks = [];

		/**
		 * A list of callbacks to call once, in the following frame, before the world is processed.
		 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/CallbacksNextFrame/CallbacksNextFrame-vtest.html Working example
		 * @type {Array<function (tpf: number)>}
		 */
		this.callbacksNextFrame = [];

		this._takeSnapshots = [];

		this.start = -1;

		this.animationId = 0;
		if (!parameters.manuallyStartGameLoop) {
			this.startGameLoop();
		}

		if (parameters.debugKeys) {
			this._addDebugKeys();
		}

		// Event stuff
		this._events = {
			click: null,
			mousedown: null,
			mouseup: null,
			mousemove: null,
			touchstart: null,
			touchend: null,
			touchmove: null
		};
		this._eventListeners = {
			click: [],
			mousedown: [],
			mouseup: [],
			mousemove: [],
			touchstart: [],
			touchend: [],
			touchmove: []
		};
		this._eventTriggered = {
			click: null,
			mousedown: null,
			mouseup: null,
			mousemove: null,
			touchstart: null,
			touchend: null,
			touchmove: null
		};

		GameUtils.addVisibilityChangeListener(function (paused) {
			if (paused) {
				this._stopGameLoop();
			} else {
				if (!this.manuallyPaused) {
					this._startGameLoop();
				}
			}
		}.bind(this));

		this._picking = {
			x: 0,
			y: 0,
			skipUpdateBuffer: false,
			doPick: false,
			pickingCallback: null,
			pickingStore: {},
			clearColorStore: [] //! AT: why is this an array and not a vector4?
		};

		this.manuallyPaused = !!parameters.manuallyStartGameLoop;

		this._setupContextLost();
	}

	GooRunner.prototype._setupContextLost = function () {
		SystemBus.addListener('goo.contextLost', function () {
			for (var i = 0; i < this.renderSystems.length; i++) {
				var renderSystem = this.renderSystems[i];
				if (renderSystem.invalidateHandles) {
					renderSystem.invalidateHandles(this.renderer);
				}
			}

			// invalidate shadow-related webgl resources
			var lightingSystem = this.world.getSystem('LightingSystem');
			if (lightingSystem) {
				lightingSystem.invalidateHandles(this.renderer);
			}

			if (this.renderer.shadowHandler) {
				this.renderer.shadowHandler.invalidateHandles(this.renderer);
			}

			this.renderer.invalidatePicking();

			this.stopGameLoop();
		}.bind(this));

		SystemBus.addListener('goo.contextRestored', function () {
			this.startGameLoop();
		}.bind(this));
	};

	/**
	 * Sets the base systems on the world.
	 * @private
	 */
	GooRunner.prototype._setBaseSystems = function () {
		this.world.setSystem(new ScriptSystem(this.world));
		this.world.setSystem(new TransformSystem());
		this.world.setSystem(new CameraSystem());
		this.world.setSystem(new ParticlesSystem());
		this.world.setSystem(new BoundingUpdateSystem());
		this.world.setSystem(new LightingSystem());

		if (AudioContext.isSupported()) {
			this.world.setSystem(new SoundSystem());
		}

		this.renderSystem = new RenderSystem();
		this.renderSystems = [this.renderSystem];
		this.world.setSystem(this.renderSystem);
	};

	/**
	 * Registers the base components so that methods like Entity.prototype.set can work.
	 * @private
	 */
	GooRunner.prototype._registerBaseComponents = function () {
		this.world.registerComponent(TransformComponent);
		this.world.registerComponent(MeshDataComponent);
		this.world.registerComponent(MeshRendererComponent);
		this.world.registerComponent(CameraComponent);
		this.world.registerComponent(LightComponent);
		this.world.registerComponent(ScriptComponent);
	};

	/**
	 * Wrapper function for _updateFrame; called by requestAnimationFrame
	 * @private
	 * @param time
	 */
	//! TODO: private until documented
	GooRunner.prototype.run = function (time) {
		//! AT: move the conditional out; assign either variants to the run method
		if (this.useTryCatch) {
			this._callSafe(this._updateFrame, time);// this._updateFrameSafe(time);
		} else {
			this._updateFrame(time);
		}
	};

	/**
     * Calls a function and catches any error
	 * @private
	 */
	GooRunner.prototype._callSafe = function (func) {
		try {
			func.apply(this, Array.prototype.slice.call(arguments, 1));
		} catch (error) {
			if (error instanceof Error) {
				console.error(error.stack);
			} else {
				console.log(error);
			}
		}
	};

	/**
	 * Add a render system to the world
	 * @private
	 * @param system
	 * @param idx
	 */
	//! AT: private until priorities get added to render systems as 'idx' is very unflexibile
	GooRunner.prototype.setRenderSystem = function (system, idx) {
		this.world.setSystem(system);
		if (idx !== undefined) {
			this.renderSystems.splice(idx, 0, system);
		} else {
			this.renderSystems.push(system);
		}
	};

	var tpfSmoothingArray = [];
	var tpfIndex = 0;

	GooRunner.prototype._updateFrame = function (time) {
		if (this.start < 0) {
			this.start = time;
		}

		var tpf = (time - this.start) / 1000.0;

		if (tpf < 0 || tpf > 1.0) { // skip a loop - original start time probably bad.
			this.start = time;
			this.animationId = window.requestAnimationFrame(this.run.bind(this));
			return;
		}

		// Smooth out the tpf
		tpfSmoothingArray[tpfIndex] = tpf;
		tpfIndex = (tpfIndex + 1) % this.tpfSmoothingCount;
		var avg = 0;
		for (var i = 0; i < tpfSmoothingArray.length; i++) {
			avg += tpfSmoothingArray[i];
		}
		avg /= tpfSmoothingArray.length;
		this.world.smoothedTpf = avg;

		this.world.tpf = tpf;
		this.world.time += this.world.tpf;
		World.time = this.world.time; // get rid of this
		World.tpf = this.world.tpf; // get rid of this
		this.start = time;

		// execute callbacks
		//! AT: doing this to be able to schedule new callbacks from the existing callbacks
		if (this.callbacksNextFrame.length > 0) {
			var callbacksNextFrame = this.callbacksNextFrame;
			this.callbacksNextFrame = [];
			if (this.useTryCatch) {
				for (var i = 0; i < callbacksNextFrame.length; i++) {
					var callback = callbacksNextFrame[i];
					this._callSafe(callback, this.world.tpf);
				}
			} else {
				for (var i = 0; i < callbacksNextFrame.length; i++) {
					var callback = callbacksNextFrame[i];
					callback(this.world.tpf);
				}
			}
		}

		if (this.useTryCatch) {
			for (var i = 0; i < this.callbacksPreProcess.length; i++) {
				var callback = this.callbacksPreProcess[i];
				this._callSafe(callback, this.world.tpf);
			}
		} else {
			for (var i = 0; i < this.callbacksPreProcess.length; i++) {
				var callback = this.callbacksPreProcess[i];
				callback(this.world.tpf);
			}
		}

		// process the world
		if (this.doProcess) {
			this.world.process();
		}

		this.renderer.info.reset();

		if (this.doRender) {
			this.renderer.checkResize(Renderer.mainCamera);
			this.renderer.setRenderTarget();
			//this.renderer.clear();

			// run the prerender callbacks
			for (var i = 0; i < this.callbacksPreRender.length; i++) {
				this.callbacksPreRender[i](this.world.tpf);
			}

			// run all the renderers
			for (var i = 0; i < this.renderSystems.length; i++) {
				if (!this.renderSystems[i].passive) {
					this.renderSystems[i].render(this.renderer);
				}
			}
			// handle pick requests
			if (this._picking.doPick && Renderer.mainCamera) {
				var clearColor = this.renderer.clearColor;
				this._picking.clearColorStore[0] = clearColor.r;
				this._picking.clearColorStore[1] = clearColor.g;
				this._picking.clearColorStore[2] = clearColor.b;
				this._picking.clearColorStore[3] = clearColor.a;
				this.renderer.setClearColor(0, 0, 0, 1);

				for (var i = 0; i < this.renderSystems.length; i++) {
					if (this.renderSystems[i].renderToPick && !this.renderSystems[i].passive) {
						this.renderSystems[i].renderToPick(this.renderer, this._picking.skipUpdateBuffer);
					}
				}
				this.renderer.pick(this._picking.x, this._picking.y, this._picking.pickingStore, Renderer.mainCamera);
				if (this.useTryCatch) {
					this._callSafe(this._picking.pickingCallback, this._picking.pickingStore.id, this._picking.pickingStore.depth);
				} else {
					this._picking.pickingCallback(this._picking.pickingStore.id, this._picking.pickingStore.depth);
				}
				this._picking.doPick = false;

				this.renderer.setClearColor.apply(this.renderer, this._picking.clearColorStore);
			}
		}

		// run the post render callbacks
		if (this.useTryCatch) {
			for (var i = 0; i < this.callbacks.length; i++) {
				var callback = this.callbacks[i];
				this._callSafe(callback, this.world.tpf);
			}
		} else {
			for (var i = 0; i < this.callbacks.length; i++) {
				var callback = this.callbacks[i];
				callback(this.world.tpf);
			}
		}

		// update the stats if there are any
		if (this.stats) {
			this.stats.update(
				this.renderer.info.toString() + '<br>' +
				'Transform updates: ' + this.world.getSystem('TransformSystem').numUpdates +
				'<br>Cached shaders: ' + Object.keys(this.renderer.rendererRecord.shaderCache).length
			);
		}

		// resolve any snapshot requests
		if (this._takeSnapshots.length) {
			var image = this.renderer.domElement.toDataURL();
			if (this.useTryCatch) {
				for (var i = this._takeSnapshots.length - 1; i >= 0; i--) {
					var callback = this._takeSnapshots[i];
					this._callSafe(callback, image);
				}
			} else {
				for (var i = this._takeSnapshots.length - 1; i >= 0; i--) {
					var callback = this._takeSnapshots[i];
					callback(image);
				}
			}
			this._takeSnapshots = [];
		}

		// schedule next frame
		if (this.animationId) {
			this.animationId = window.requestAnimationFrame(this.run.bind(this));
		}
	};

	//TODO: move this to Logo
	GooRunner.prototype._buildLogo = function (settings) {
		var div = document.createElement('div');

		var color = settings && settings.color ? settings.color : Logo.white;

		var svg = Logo.getLogo({
			width: '70px',
			height: '50px',
			color: color
		});
		if (svg === '') {
			return;
		}

		div.innerHTML = '<a style="text-decoration: none;" href="http://www.goocreate.com" target="_blank">' + svg + '</a>';
		div.style.position = 'absolute';
		div.style.zIndex = '2000';

		if (!settings) {
			div.style.top = '10px';
			div.style.right = '10px';
		} else if (settings === 'topright' || settings.position === 'topright') {
			div.style.top = '10px';
			div.style.right = '10px';
		} else if (settings === 'topleft' || settings.position === 'topleft') {
			div.style.top = '10px';
			div.style.left = '10px';
		} else if (settings === 'bottomright' || settings.position === 'bottomright') {
			div.style.bottom = '10px';
			div.style.right = '10px';
		} else {
			div.style.bottom = '10px';
			div.style.left = '10px';
		}

		div.id = 'goologo';
		div.style.webkitTouchCallout = 'none';
		div.style.webkitUserSelect = 'none';
		div.style.khtmlUserSelect = 'none';
		div.style.mozUserSelect = 'none';
		div.style.msUserSelect = 'none';
		div.style.userSelect = 'none';
		div.ondragstart = function () {
			return false;
		};

		return div;
	};

	/**
	 * Enable misc debug configurations for inspecting aspects of the scene on hotkeys.
	 * @private
	 */
	GooRunner.prototype._addDebugKeys = function () {
		// shift+space = toggle fullscreen
		// shift+enter = toggle mouselock
		// shift+1 = normal rendering
		// shift+2 = show normals
		// shift+3 = simple lit
		// shift+4 = color
		// shift+5 = wireframe
		// shift+6 = flat
		// shift+7 = textured
		// shift+8 = regular material + wireframe
		// shift+click = log picked entity
		var ACTIVE_KEY = 'shiftKey';

		var modesByKeyCode = {
			50: 'normals',
			222: 'normals',
			51: 'lit',
			52: 'color',
			53: 'wireframe',
			54: 'flat',
			55: 'texture',
			191: 'texture',
			56: '+wireframe'
		};

		document.addEventListener('keydown', function (event) {
			if (!event[ACTIVE_KEY]) { return; }

			switch (event.which) {
				case 32: // Space
					GameUtils.toggleFullScreen();
					break;
				case 13: // Enter
					GameUtils.togglePointerLock();
					break;
				case 49: // 1
					this.renderSystem.setDebugMaterial();
					break;
				default:
					if (modesByKeyCode[event.which]) {
						this.renderSystem.setDebugMaterial(modesByKeyCode[event.which]);
					}
			}
		}.bind(this), false);

		document.addEventListener('mousedown', function (event) {
			if (event[ACTIVE_KEY]) {
				var x = event.clientX;
				var y = event.clientY;
				this.pick(x, y, function (id, depth) {
					var entity = this.world.entityManager.getEntityById(id);
					console.log('Picked entity:', entity, 'At depth:', depth);
				}.bind(this));
			}
		}.bind(this), false);
	};

	/**
	 * Adds an event listener to the GooRunner.
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/misc/PickingEvents/PickingEvents-vtest.html Working example
	 * @param {string} type Can currently be 'click', 'mousedown', 'mousemove', 'mouseup',
	 * 'touchstart', 'touchend' or 'touchmove'.
	 * @param  {function (event)} callback Callback function.
	 * @param {Entity} callback.event.entity Picked entity, undefined if no entity is picked.
	 * @param {Vector3} callback.event.intersection Point of pick ray intersection with scene.
	 * @param {number} callback.event.depth Depth of pick ray intersection.
	 * @param {number} callback.event.x Canvas x coordinate.
	 * @param {number} callback.event.y Canvas y coordinate.
	 * @param {string} callback.event.type Type of triggered event ('mousedown', 'touchstart', etc).
	 * @param {Event} callback.event.domEvent Original DOM event.
	 * @param {number} callback.event.id Entity pick ID. -1 if no entity was picked.
	 * @example
	 * gooRunner.addEventListener('mousedown', function (event) {
	 *   if (event.entity) {
	 *     console.log('clicked entity', event.entity.name);
	 *     console.log('clicked point', event.intersection);
	 *   }
	 * });
	 */
	GooRunner.prototype.addEventListener = function (type, callback) {
		if (!this._eventListeners[type] || this._eventListeners[type].indexOf(callback) > -1) {
			return;
		}

		if (typeof callback === 'function') {
			this._eventListeners[type].push(callback);
			if (this._eventListeners[type].length === 1) {
				this._enableEvent(type);
			}
		}
	};

	/**
	 * Removes an event listener from the GooRunner.
	 * @param {string} type Can currently be 'click', 'mousedown', 'mousemove', 'mouseup',
	 * 'touchstart', 'touchend' or 'touchmove'.
	 * @param {function (event)} callback Callback to remove from event listener.
	 */
	GooRunner.prototype.removeEventListener = function (type, callback) {
		if (!this._eventListeners[type]) {
			return;
		}
		var index = this._eventListeners[type].indexOf(callback);
		if (index > -1) {
			this._eventListeners[type].splice(index, 1);
		}
		if (this._eventListeners[type].length === 0) {
			this._disableEvent(type);
		}
	};

	/**
	 * Triggers an event on the GooRunner (force).
	 * @param {string} type Can currently be 'click', 'mousedown', 'mousemove', 'mouseup',
	 * 'touchstart', 'touchend' or 'touchmove'.
	 * @param {Object} evt The GooRunner-style event
	 * @param {Entity} evt.entity Event entity.
	 * @param {number} evt.x Event canvas X coordinate.
	 * @param {number} evt.y Event canvas Y coordinate.
	 * @param {Event} evt.domEvent The original DOM event.
     */
	GooRunner.prototype.triggerEvent = function (type, evt) {
		evt.type = type;
		this._eventTriggered[type] = evt.domEvent;
		this._dispatchEvent(evt);
	};


	GooRunner.prototype._dispatchEvent = function (evt) {
		var types = Object.keys(this._eventTriggered);
		for (var i = 0; i < types.length; i++) {
			var type = types[i];
			if (this._eventTriggered[type] && this._eventListeners[type]) {
				var e = {
					entity: evt.entity,
					depth: evt.depth,
					x: evt.x,
					y: evt.y,
					type: type,
					domEvent: this._eventTriggered[type],
					id: evt.id,
					intersection: evt.intersection
				};
				try {
					for (var j = 0; j < this._eventListeners[type].length; j++) {
						if (this._eventListeners[type][j](e) === false) {
							break;
						}
					}
				} catch (err) {
					console.error(err);
				}
				this._eventTriggered[type] = null;
			}
		}
	};

	/**
	 * Enables event listening on the GooRunner
	 * @param {string} type Can currently be 'click', 'mousedown', 'mousemove',
	 * 'touchstart', 'touchend' or 'touchmove'.
	 * @private
	 */
	GooRunner.prototype._enableEvent = function (type) {
		if (this._events[type]) {
			return;
		}
		var func = function (e) {
			var x, y;
			if (e.type === 'touchstart' || e.type === 'touchend' || e.type === 'touchmove') {
				x = e.changedTouches[0].pageX - e.changedTouches[0].target.getBoundingClientRect().left;
				y = e.changedTouches[0].pageY - e.changedTouches[0].target.getBoundingClientRect().top;
			} else {
				var target = e.target || e.srcElement;
				var rect = target.getBoundingClientRect();
				x = e.clientX - rect.left;
				y = e.clientY - rect.top;
			}
			this._eventTriggered[type] = e;
			this.pick(x, y, function (index, depth) {
				var dpx = this.renderer.devicePixelRatio;
				var entity = this.world.entityManager.getEntityByIndex(index);
				var intersection = Renderer.mainCamera.getWorldPosition(x * dpx, y * dpx, this.renderer.viewportWidth, this.renderer.viewportHeight, depth);
				this._dispatchEvent({
					entity: entity,
					depth: depth,
					x: x,
					y: y,
					id: index,
					intersection: intersection
				});
			}.bind(this));
		}.bind(this);
		this.renderer.domElement.addEventListener(type, func);
		this._events[type] = func;
	};

	/**
	 * Disables event listening on the GooRunner
	 * @param {string} type Can currently be 'click', 'mousedown', 'mousemove',
	 * 'touchstart', 'touchend' or 'touchmove'.
	 * @private
	 */
	GooRunner.prototype._disableEvent = function (type) {
		if (this._events[type]) {
			this.renderer.domElement.removeEventListener(type, this._events[type]);
		}
		this._events[type] = null;
	};

	/**
	 * The method that actually starts the game loop
	 * @private
	 */
	GooRunner.prototype._startGameLoop = function () {
		if (!this.animationId) {
			this.start = -1;
			this.animationId = window.requestAnimationFrame(this.run.bind(this));
		}
	};

	/**
	 * Starts the game loop (done through requestAnimationFrame).
	 */
	GooRunner.prototype.startGameLoop = function () {
		this.manuallyPaused = false;
		this._startGameLoop();
	};

	/**
	 * The method that actually stops the game loop
	 * @private
	 */
	GooRunner.prototype._stopGameLoop = function () {
		window.cancelAnimationFrame(this.animationId);
		this.animationId = 0;
	};

	/**
	 * Stops the game loop.
	 */
	GooRunner.prototype.stopGameLoop = function () {
		this.manuallyPaused = true;
		this._stopGameLoop();
	};

	/**
	 * Takes an image snapshot from the 3d scene at next render call.
	 * @param {Function} callback
	 */
	GooRunner.prototype.takeSnapshot = function (callback) {
		this._takeSnapshots.push(callback);
	};

	/**
	 * Requests a pick from screen space coordinates. A successful pick returns id and depth of the pick target.
	 *
	 * @param {number} x screen coordinate
	 * @param {number} y screen coordinate
	 * @param {Function} callback to handle the pick result
	 * @param {boolean} skipUpdateBuffer when true picking will be attempted against existing buffer
	 */
	GooRunner.prototype.pick = function (x, y, callback, skipUpdateBuffer) {
		this._picking.x = x;
		this._picking.y = y;
		this._picking.skipUpdateBuffer = skipUpdateBuffer === undefined ? false : skipUpdateBuffer;
		if (callback) {
			this._picking.pickingCallback = callback;
		}
		this._picking.doPick = true;
	};

	/**
	 * Pick, the synchronous method. Uses the same pickbuffer so it will affect asynch picking. Also goes only through the normal render system.
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/misc/PickSync/PickSync-vtest.html Working example
	 * @param {number} x screen coordinate
	 * @param {number} y screen coordinate
	 * @param {boolean} skipUpdateBuffer when true picking will be attempted against existing buffer
	 */
	GooRunner.prototype.pickSync = function (x, y, skipUpdateBuffer) {
		// save the clear color
		var currentClearColor = this.renderer.clearColor;

		this._picking.skipUpdateBuffer = skipUpdateBuffer === undefined ? false : skipUpdateBuffer;

		var savedClearColor = currentClearColor.clone();

		// change the clear color
		this.renderer.setClearColor(0, 0, 0, 1);

		// render
		this.renderSystem.renderToPick(this.renderer, false);

		// restore the clear color
		this.renderer.setClearColor(savedClearColor.r, savedClearColor.g, savedClearColor.b, savedClearColor.a);

		// get the picking data from the buffer
		var pickingStore = {};
		this.renderer.pick(x, y, pickingStore, Renderer.mainCamera);
		return pickingStore;
	};

	/**
	 * Clears the GooRunner and anything associated with it. Once this method is called this instanceof of GooRunner is unusable.
	 */
	GooRunner.prototype.clear = function () {
		this.stopGameLoop();
		this.world.clear();

		// detach the canvas from the page
		var gooCanvas = this.renderer.domElement;
		if (gooCanvas.parentNode) {
			gooCanvas.parentNode.removeChild(gooCanvas);
		}

		// a lot of stuff may reside in here
		SystemBus.clear();

		// clearing cached materials
		Material.store = [];
		Material.hash = [];

		// this should never have existed in the first place
		Renderer.mainCamera = null;

		// clears out whatever visibility-change listeners were attached to document
		GameUtils.clearVisibilityChangeListeners();

		// severe some more connections
		this.world = null;
		this.renderer = null;
		this.renderSystem = null;
		this.renderSystems = null;

		// and forget any scheduled callbacks as they can hold references too
		this.callbacks = null;
		this.callbacksPreProcess = null;
		this.callbacksPreRender = null;
		this.callbacksNextFrame = null;
		this._takeSnapshots = null;
		this._events = null;
	};

	return GooRunner;
})(goo.World,goo.Renderer,goo.TransformSystem,goo.RenderSystem,goo.BoundingUpdateSystem,goo.ScriptSystem,goo.LightingSystem,goo.CameraSystem,goo.ParticlesSystem,goo.Stats,goo.AudioContext,goo.SoundSystem,goo.TransformComponent,goo.MeshDataComponent,goo.MeshRendererComponent,goo.CameraComponent,goo.LightComponent,goo.ScriptComponent,goo.SoundComponent,goo.GameUtils,goo.Logo,goo.SystemBus,goo.Material);
goo.ComponentHandler = (function (
	PromiseUtils
) {
	'use strict';

	/**
	 * Base class for component handlers. All different types of components that an entity
	 * can have need to have a registered component handler. To handle a new type of component,
	 * create a class that inherits from this class, and override {_prepare}, {_create}, {update} and {remove}
	 * as needed ({update} must be overridden). In your class, call <code>@_register('yourComponentType')</code> to _register
	 * the handler with the loader.
	 *
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {DynamicLoader.update}.
	 * @returns {ComponentHandler}
	 * @hidden
	 */
	function ComponentHandler(world, getConfig, updateObject, loadObject) {
		//! schteppe: this._type seem to be assumed to be set by the subclass. Why not pass it as a parameter to this constructor?
		this.world = world;
		this.getConfig = getConfig;
		this.updateObject = updateObject;
		this.loadObject = loadObject;
	}

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @private
	 */
	ComponentHandler.prototype._prepare = function (/*config*/) {};

	/**
	 * Create engine component object based on the config. Should be overridden in subclasses.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @returns {Component} the created component object
	 * @private
	 * @abstract
	 */
	ComponentHandler.prototype._create = function () {
		throw new Error('ComponentHandler._create is abstract, use ComponentHandler.getHandler(type)');
	};

	/**
	 * Remove engine component object. Should be overridden in subclasses.
	 * @param {Entity} entity The entity from which this component should be removed.
	 * @private
	 */
	ComponentHandler.prototype._remove = function (entity) {
		entity.clearComponent(this._type);
	};

	/**
	 * Loads object for given ref
	 * @param {string} ref
	 * @param {Object} options
	 * @private
	 */
	ComponentHandler.prototype._load = function (ref, options) {
		return this.loadObject(ref, options);
	};

	/**
	 * Update engine component object based on the config. Should be overridden in subclasses.
	 * This method is called by #{EntityHandler} to load new component configs into the engine.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the created component when loading is done.
	 */
	ComponentHandler.prototype.update = function (entity, config/*, options*/) {
		if (!entity) {
			return PromiseUtils.reject('Entity is missing');
		}
		if (!config) {
			this._remove(entity);
			return PromiseUtils.resolve();
		}
		var component = entity.getComponent(this._type);
		if (!component) {
			component = this._create();
			entity.setComponent(component);
		}
		this._prepare(config);

		return PromiseUtils.resolve(component);
	};


	ComponentHandler.handlerClasses = {};

	/**
	 * Get a handler class for the specified type of component. The type can be e.g. 'camera', 'transform', etc.
	 * The type name should not end with "Component".
	 * @param {string} type
	 * @returns {Class} A subclass of {ComponentHandler}, or null if no registered handler for the given type was found.
	 */
	ComponentHandler.getHandler = function (type) {
		return ComponentHandler.handlerClasses[type];
	};

	/**
	 * Register a handler for a component type. Called in the class body of subclasses.
	 * @param {string} type
	 * @param {Class} klass the class to register for this component type
	 */
	ComponentHandler._registerClass = function (type, klass) {
		ComponentHandler.handlerClasses[type] = klass;
	};

	return ComponentHandler;
})(goo.PromiseUtils);
goo.ArrayUtils = (function () {
	'use strict';

	/**
	 * Utilities for arrays and typed arrays
	 */
	function ArrayUtils() {}

	/**
	 * Create a typed array view on an ArrayBuffer, using the supplied pointer. Notice that this
	 * does not copy any elements, if you make changes to the returned array, the original
	 * ArrayBuffer will be modified.
	 *
	 * @param {ArrayBuffer} arrayBuffer
	 * @param {Array} pointer Array [start, length, format] where start is the start byte offset
	 * in the buffer, length is the number of values of the given format, and format is a string
	 * denoting the data format:
	 * 'float32' creates a Float32Array
	 * 'uint32'
	 * 'uint16'
	 * 'uint8'
	 *
	 * @returns Typed array
	 */
	ArrayUtils.getTypedArray = function(arrayBuffer, pointer) {
		var start = pointer[0];
		var length = pointer[1];
		var format = pointer[2];

		if (format === 'float32') {
			return new Float32Array(arrayBuffer, start, length);
		}
		else if (format === 'uint8') {
			return new Uint8Array(arrayBuffer, start, length);
		}
		else if (format === 'uint16') {
			return new Uint16Array(arrayBuffer, start, length);
		}
		else if (format === 'uint32') {
			return new Uint32Array(arrayBuffer, start, length);
		}
		else {
			throw new Error('Binary format ' + format + ' is not supported');
		}
	};

	ArrayUtils.remove = function(array, value, equals) {
		var idx = -1;
		if (typeof equals === 'function') {
			for (var i = 0; i < array.length; i++) {
				if (equals(array[i], value)) {
					idx = i;
					break;
				}
			}
		}
		else {
			idx = array.indexOf(value);
		}
		if (idx > -1) {
			array.splice(idx, 1);
		}
	};

	/**
	 * Returns the first element in the supplied array for which the supplied predicate is true
	 * @param array
	 * @param predicate
	 * @returns {*}
	 */
	ArrayUtils.find = function(array, predicate) {
		for (var i = 0; i < array.length; i++) {
			if (predicate(array[i])) {
				return array[i];
			}
		}
		return null;
	};

	/**
	 * Returns an array of keys for the given Set or Map
	 * @param {(Set|Map)} collection
	 * @returns {Array}
	 */
	ArrayUtils.fromKeys = function (collection) {
		var array = [];

		collection.forEach(function (value, key) {
			array.push(key);
		});
//		var iterator = collection.keys();
//		var entry = iterator.next();
//		while (!entry.done) {
//			array.push(entry.value);
//			entry = iterator.next();
//		}
		return array;
	};

	/**
	 * Returns an array of values for the given Set or Map
	 * @param {(Set|Map)} collection
	 * @returns {Array}
	 */
	ArrayUtils.fromValues = function (collection) {
		var array = [];

		collection.forEach(function (value) {
			array.push(value);
		});
//		var iterator = collection.values();
//		var entry = iterator.next();
//		while (!entry.done) {
//			array.push(entry.value);
//			entry = iterator.next();
//		}
		return array;
	};

	return ArrayUtils;
})();
goo.Box = (function (
	MeshData,
	ObjectUtils
) {
	'use strict';

	/**
	 * An axis-aligned rectangular prism defined by a center point and x-, y- and z-extents (radii)
	 * from that center (a box).
	 * @extends MeshData
	 * @param {number} [width=1] Total width of box.
	 * @param {number} [height=1] Total height of box.
	 * @param {number} [length=1] Total length of box.
	 * @param {number} [tileX=1] Number of texture repetitions in the texture's x direction.
	 * @param {number} [tileY=1] Number of texture repetitions in the texture's y direction.
	 * @param {Enum} [textureMode=Box.TextureModes.Uniform] Texture wrapping mode.
	 */
	function Box(width, height, length, tileX, tileY, textureMode) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			width = props.width;
			height = props.height;
			length = props.length;
			tileX = props.tileX;
			tileY = props.tileY;
			textureMode = props.textureMode;
		}

		/**
		 * Extent along the local x axis.
		 * @type {number}
		 * @default 0.5
		 */
		this.xExtent = width !== undefined ? width * 0.5 : 0.5;

		/**
		 * Extent along the local y axis.
		 * @type {number}
		 * @default 0.5
		 */
		this.yExtent = height !== undefined ? height * 0.5 : 0.5;

		/**
		 * Extent along the local z axis.
		 * @type {number}
		 * @default 0.5
		 */
		this.zExtent = length !== undefined ? length * 0.5 : 0.5;

		/**
		 * Number of texture repetitions in the texture's x direction.
		 * @type {number}
		 * @default 1
		 */
		this.tileX = tileX || 1;

		/**
		 * Number of texture repetitions in the texture's y direction.
		 * @type {number}
		 * @default 1
		 */
		this.tileY = tileY || 1;

		/**
		 * Texture wrapping mode.
		 * @type {Enum}
		 * @default Box.TextureModes.Uniform
		 */
		this.textureMode = textureMode !== undefined ? textureMode : Box.TextureModes.Uniform;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		MeshData.call(this, attributeMap, 24, 36);

		this.rebuild();
	}

	Box.prototype = Object.create(MeshData.prototype);
	Box.prototype.constructor = Box;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Box} Self for chaining.
	 */
	Box.prototype.rebuild = function () {
		var xExtent = this.xExtent;
		var yExtent = this.yExtent;
		var zExtent = this.zExtent;
		var tileX = this.tileX;
		var tileY = this.tileY;

		var verts = [
			-xExtent, -yExtent, -zExtent,
			 xExtent, -yExtent, -zExtent,
			 xExtent,  yExtent, -zExtent,
			-xExtent,  yExtent, -zExtent,
			 xExtent, -yExtent,  zExtent,
			-xExtent, -yExtent,  zExtent,
			 xExtent,  yExtent,  zExtent,
			-xExtent,  yExtent,  zExtent
		];

		var vertices = [];
		function fillV(fillIndices) {
			for (var i = 0; i < fillIndices.length; i++) {
				var index = fillIndices[i] * 3;
				vertices.push(verts[index]);
				vertices.push(verts[index + 1]);
				vertices.push(verts[index + 2]);
			}
		}

		fillV([
			0, 1, 2, 3,
			1, 4, 6, 2,
			4, 5, 7, 6,
			5, 0, 3, 7,
			2, 6, 7, 3,
			0, 5, 4, 1
		]);

		this.getAttributeBuffer(MeshData.POSITION).set(vertices);

		var norms = [
			 0, 0, -1,
			 1, 0, 0,
			 0, 0, 1,
			-1, 0, 0,
			 0, 1, 0,
			 0, -1, 0
		];

		var normals = [];
		function fillN() {
			for (var i = 0; i < norms.length / 3; i++) {
				for (var j = 0; j < 4; j++) {
					var index = i * 3;
					normals.push(norms[index]);
					normals.push(norms[index + 1]);
					normals.push(norms[index + 2]);
				}
			}
		}
		fillN();

		this.getAttributeBuffer(MeshData.NORMAL).set(normals);

		var tex = [];
		if (this.textureMode === Box.TextureModes.Uniform) {
			for (var i = 0; i < 6; i++) {
				tex.push(tileX);
				tex.push(0);

				tex.push(0);
				tex.push(0);

				tex.push(0);
				tex.push(tileY);

				tex.push(tileX);
				tex.push(tileY);
			}
		} else {
			tex.push(4 / 4, 1 / 3,   3 / 4, 1 / 3,   3 / 4, 2 / 3,   4 / 4, 2 / 3); // 5
			tex.push(3 / 4, 1 / 3,   2 / 4, 1 / 3,   2 / 4, 2 / 3,   3 / 4, 2 / 3); // 4
			tex.push(2 / 4, 1 / 3,   1 / 4, 1 / 3,   1 / 4, 2 / 3,   2 / 4, 2 / 3); // 3
			tex.push(1 / 4, 1 / 3,   0 / 4, 1 / 3,   0 / 4, 2 / 3,   1 / 4, 2 / 3); // 2
			tex.push(2 / 4, 3 / 3,   2 / 4, 2 / 3,   1 / 4, 2 / 3,   1 / 4, 3 / 3); // 1
			tex.push(1 / 4, 0 / 3,   1 / 4, 1 / 3,   2 / 4, 1 / 3,   2 / 4, 0 / 3); // 6
		}

		this.getAttributeBuffer(MeshData.TEXCOORD0).set(tex);

		this.getIndexBuffer().set([
			 2,  1,  0,  3,  2,  0,
			 6,  5,  4,  7,  6,  4,
			10,  9,  8, 11, 10,  8,
			14, 13, 12, 15, 14, 12,
			18, 17, 16, 19, 18, 16,
			22, 21, 20, 23, 22, 20
		]);

		return this;
	};

	/**
	 * Returns a clone of this box
	 * @returns {Box}
	 */
	Box.prototype.clone = function () {
		var options = ObjectUtils.shallowSelectiveClone(this, ['tileX', 'tileY', 'textureMode']);

		// converting xExtent to width so the constructor will convert it the other way around again
		options.width = this.xExtent * 2;
		options.height = this.yExtent * 2;
		options.length = this.zExtent * 2;

		return new Box(options);
	};

	/** Possible texture wrapping modes: Uniform, Unfolded
	 * @type {Object}
	 */
	Box.TextureModes = {
		Uniform: 'Uniform',
		Unfolded: 'Unfolded'
	};

	return Box;
})(goo.MeshData,goo.ObjectUtils);
goo.Sphere = (function (
	MeshData,
	Vector3,
	MathUtils,
	_
) {
	'use strict';

	/**
	 * A 3D object with all points equi-distance from a center point.
	 * @extends MeshData
	 * @param {number} [zSamples=8] Number of segments.
	 * @param {number} [radialSamples=8] Number of slices.
	 * @param {number} [radius=0.5] Radius.
	 * @param {Enum} [textureMode=Sphere.TextureModes.Polar] Texture wrapping mode.
	 */
	function Sphere(zSamples, radialSamples, radius, textureMode) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			zSamples = props.zSamples;
			radialSamples = props.radialSamples;
			radius = props.radius;
			textureMode = props.textureMode;
		}
		/** Number of segments.
		 * @type {number}
		 * @default 8
		 */
		this.zSamples = (zSamples !== undefined ? zSamples : 8) + 1;
		/** Number of slices.
		 * @type {number}
		 * @default 8
		 */
		this.radialSamples = radialSamples !== undefined ? radialSamples : 8;
		/** @type {number}
		 * @default 0.5
		 */
		this.radius = radius !== undefined ? radius : 0.5;

		if (typeof textureMode === 'string') {
			textureMode = Sphere.TextureModes[textureMode];
		}
		/** Texture wrapping mode.
		 * @type {Enum}
		 * @default Sphere.TextureModes.Polar
		 */
		this.textureMode = textureMode !== undefined ? textureMode : Sphere.TextureModes.Polar;

		/** Inward-facing normals, for skydomes.
		 * @type {boolean}
		 * @default false
		 */
		this.viewInside = false;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);

		var samples = (this.textureMode === Sphere.TextureModes.Chromeball) ? this.zSamples + 1 : this.zSamples;

		// If Projected & Linear use shared pole vertices the uv-mapping will get too distorted, so let them
		// have full 'rings' of vertices for a straighter texture mapping.
		this._useSharedPoleVertices = (this.textureMode !== Sphere.TextureModes.Projected) &&
			(this.textureMode !== Sphere.TextureModes.Linear);

		// sharedVert = pole vertex that represents a whole layer. When not using shared vertices,
		// full layers are used for both poles.
		var sharedVerts = this._useSharedPoleVertices ? 2 : 0;
		var verts = (samples - sharedVerts) * (this.radialSamples + 1) + sharedVerts;
		var tris = 6 * ((samples) - 2) * this.radialSamples;

		MeshData.call(this, attributeMap, verts, tris);

		this.rebuild();
	}

	Sphere.prototype = Object.create(MeshData.prototype);
	Sphere.prototype.constructor = Sphere;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Sphere} Self for chaining.
	 */
	Sphere.prototype.rebuild = function () {
		var vbuf = this.getAttributeBuffer(MeshData.POSITION);
		var norms = this.getAttributeBuffer(MeshData.NORMAL);
		var texs = this.getAttributeBuffer(MeshData.TEXCOORD0);
		var indices = this.getIndexBuffer();

		// generate geometry
		var fInvRS = 1.0 / this.radialSamples;
		var fZFactor = 2.0 / (this.zSamples - 1);

		// Generate points on the unit circle to be used in computing the mesh
		// points on a sphere slice.
		var afSin = [];
		var afCos = [];
		for (var iR = 0; iR < this.radialSamples; iR++) {
			var fAngle = MathUtils.TWO_PI * fInvRS * iR;
			afCos[iR] = Math.cos(fAngle);
			afSin[iR] = Math.sin(fAngle);
		}
		afSin[this.radialSamples] = afSin[0];
		afCos[this.radialSamples] = afCos[0];

		// z range to generate vertices for. If sharing pole vertices, skip those layers.
		var zBegin = 0;
		var zEnd = this.zSamples;

		if (this._useSharedPoleVertices) {
			zBegin = 1;
			zEnd = this.zSamples - 1;
		}

		// generate the sphere itself
		var i = 0;
		var tempVa = new Vector3();
		var tempVb = new Vector3();
		var tempVc = new Vector3();
		for (var iZ = zBegin; iZ < zEnd; iZ++) {
			var fAFraction = MathUtils.HALF_PI * (-1.0 + fZFactor * iZ); // in (-pi / 2, pi / 2)
			var fZFraction = Math.sin(fAFraction); // in (-1, 1)
			var fZ = this.radius * fZFraction;

			// compute center of slice
			var kSliceCenter = tempVb.setDirect(0, 0, 0);
			kSliceCenter.z += fZ;

			// compute radius of slice
			var fSliceRadius = Math.sqrt(Math.abs(this.radius * this.radius - fZ * fZ));

			// compute slice vertices with duplication at end point
			var kNormal;
			var iSave = i;
			for (var iR = 0; iR < this.radialSamples; iR++) {
				var fRadialFraction = iR * fInvRS; // in [0, 1)
				var kRadial = tempVc.setDirect(afCos[iR], afSin[iR], 0);
				tempVa.copy(kRadial).scale(fSliceRadius);

				vbuf[i * 3 + 0] = kSliceCenter.x + tempVa.x;
				vbuf[i * 3 + 1] = kSliceCenter.y + tempVa.y;
				vbuf[i * 3 + 2] = kSliceCenter.z + tempVa.z;

				kNormal = tempVa.setDirect(vbuf[i * 3 + 0], vbuf[i * 3 + 1], vbuf[i * 3 + 2]);
				kNormal.normalize();
				if (!this.viewInside) {
					norms[i * 3 + 0] = kNormal.x;
					norms[i * 3 + 1] = kNormal.y;
					norms[i * 3 + 2] = kNormal.z;
				} else {
					norms[i * 3 + 0] = -kNormal.x;
					norms[i * 3 + 1] = -kNormal.y;
					norms[i * 3 + 2] = -kNormal.z;
				}

				// When not having shared pole vertices: ajustment of u at the poles for linear & projected modes.
				// This is because at the pole we squeeze a quad into a triangle, so this centers the pointy end of it.
				var uOffset = 0;
				if (!this._useSharedPoleVertices && (iZ === zBegin || iZ === (zEnd - 1))) {
					uOffset = 0.5 * fInvRS;
				}

				if (this.textureMode === Sphere.TextureModes.Linear) {
					texs[i * 2 + 0] = fRadialFraction + uOffset;
					texs[i * 2 + 1] = 0.5 * (fZFraction + 1.0);
				} else if (this.textureMode === Sphere.TextureModes.Projected) {
					texs[i * 2 + 0] = fRadialFraction + uOffset;
					texs[i * 2 + 1] = (MathUtils.HALF_PI + Math.asin(fZFraction)) / Math.PI;
				} else if (this.textureMode === Sphere.TextureModes.Polar) {
					var r = (MathUtils.HALF_PI - Math.abs(fAFraction)) / Math.PI;
					var u = r * afCos[iR] + 0.5;
					var v = r * afSin[iR] + 0.5;
					texs[i * 2 + 0] = u;
					texs[i * 2 + 1] = v;
				} else if (this.textureMode === Sphere.TextureModes.Chromeball) {
					var r = Math.sin((MathUtils.HALF_PI + fAFraction) / 2);
					r /= 2;
					var u = r * afCos[iR] + 0.5;
					var v = r * afSin[iR] + 0.5;
					texs[i * 2 + 0] = u;
					texs[i * 2 + 1] = v;
				}

				i++;
			}

			copyInternal(vbuf, iSave, i);
			copyInternal(norms, iSave, i);

			if (this.textureMode === Sphere.TextureModes.Linear) {
				texs[i * 2 + 0] = 1.0;
				texs[i * 2 + 1] = 0.5 * (fZFraction + 1.0);
			} else if (this.textureMode === Sphere.TextureModes.Projected) {
				texs[i * 2 + 0] = 1.0;
				texs[i * 2 + 1] = (MathUtils.HALF_PI + Math.asin(fZFraction)) / Math.PI;
			} else if (this.textureMode === Sphere.TextureModes.Polar) {
				var r = (MathUtils.HALF_PI - Math.abs(fAFraction)) / Math.PI;
				texs[i * 2 + 0] = r + 0.5;
				texs[i * 2 + 1] = 0.5;
			} else if (this.textureMode === Sphere.TextureModes.Chromeball) {
				var r = Math.sin((MathUtils.HALF_PI + fAFraction) / 2);
				r /= 2;
				texs[i * 2 + 0] = r + 0.5;
				texs[i * 2 + 1] = 0.5;
			}

			i++;
		}
		// We need to add an extra slice so the north pole doesn't look freake
		if (this.textureMode === Sphere.TextureModes.Chromeball) {
			var epsilonAngle = MathUtils.HALF_PI - 1e-3;
			var z = this.radius * Math.sin(epsilonAngle);
			var sliceR = Math.sqrt(Math.abs(this.radius * this.radius - z * z));
			var iSave = i;
			for (var iR = 0; iR < this.radialSamples; iR++) {
				vbuf[i * 3 + 0] = sliceR * afCos[iR];
				vbuf[i * 3 + 1] = sliceR * afSin[iR];
				vbuf[i * 3 + 2] = z;

				var kNormal = tempVa.setDirect(vbuf[i * 3 + 0], vbuf[i * 3 + 1], vbuf[i * 3 + 2]);
				kNormal.normalize();
				if (!this.viewInside) {
					norms[i * 3 + 0] = kNormal.x;
					norms[i * 3 + 1] = kNormal.y;
					norms[i * 3 + 2] = kNormal.z;
				} else {
					norms[i * 3 + 0] = -kNormal.x;
					norms[i * 3 + 1] = -kNormal.y;
					norms[i * 3 + 2] = -kNormal.z;
				}
				var r = Math.sin((MathUtils.HALF_PI + epsilonAngle) / 2);
				r /= 2;
				var u = r * afCos[iR] + 0.5;
				var v = r * afSin[iR] + 0.5;
				texs[i * 2 + 0] = u;
				texs[i * 2 + 1] = v;
				i++;
			}
			copyInternal(vbuf, iSave, i);
			copyInternal(norms, iSave, i);
			var r = Math.sin((MathUtils.HALF_PI + epsilonAngle) / 2);
			r /= 2;
			texs[i * 2 + 0] = r + 0.5;
			texs[i * 2 + 1] = 0.5;
			i++;
		}

		if (this._useSharedPoleVertices) {
			// south pole
			vbuf[i * 3 + 0] = 0;
			vbuf[i * 3 + 1] = 0;
			vbuf[i * 3 + 2] = -this.radius;

			if (!this.viewInside) {
				norms[i * 3 + 0] = 0;
				norms[i * 3 + 1] = 0;
				norms[i * 3 + 2] = -1;
			} else {
				norms[i * 3 + 0] = 0;
				norms[i * 3 + 1] = 0;
				norms[i * 3 + 2] = 1;
			}

			if (this.textureMode === Sphere.TextureModes.Polar || this.textureMode === Sphere.TextureModes.Chromeball) {
				texs[i * 2 + 0] = 0.5;
				texs[i * 2 + 1] = 0.5;
			} else {
				texs[i * 2 + 0] = 0.5;
				texs[i * 2 + 1] = 0.0;
			}

			i++;

			// north pole
			vbuf[i * 3 + 0] = 0;
			vbuf[i * 3 + 1] = 0;
			vbuf[i * 3 + 2] = this.radius;

			if (!this.viewInside) {
				norms[i * 3 + 0] = 0;
				norms[i * 3 + 1] = 0;
				norms[i * 3 + 2] = 1;
			} else {
				norms[i * 3 + 0] = 0;
				norms[i * 3 + 1] = 0;
				norms[i * 3 + 2] = -1;
			}

			if (this.textureMode === Sphere.TextureModes.Polar) {
				texs[i * 2 + 0] = 0.5;
				texs[i * 2 + 1] = 0.5;
			} else if (this.textureMode === Sphere.TextureModes.Chromeball) {
				texs[i * 2 + 0] = 1;
				texs[i * 2 + 1] = -0.5;
			} else {
				texs[i * 2 + 0] = 0.5;
				texs[i * 2 + 1] = 1.0;
			}
		}

		// generate connectivity
		var index = 0;

		var samples = (this.textureMode === Sphere.TextureModes.Chromeball) ? this.zSamples + 1 : this.zSamples;

		var iZStart = 0;
		if (!this._useSharedPoleVertices) {
			// When triangles at the pole dont use a shared vertices, there's an extra pole layer here that will be
			// used only for the pole.
			iZStart = this.radialSamples + 1;
		}

		for (var iZ = 0; iZ < samples - 3; iZ++) {
			var i0 = iZStart;
			var i1 = i0 + 1;
			iZStart += this.radialSamples + 1;
			var i2 = iZStart;
			var i3 = i2 + 1;
			for (var i = 0; i < this.radialSamples; i++) {
				if (!this.viewInside) {
					indices[index++] = i0++;
					indices[index++] = i1;
					indices[index++] = i2;
					indices[index++] = i1++;
					indices[index++] = i3++;
					indices[index++] = i2++;
				} else {
					indices[index++] = i0++;
					indices[index++] = i2;
					indices[index++] = i1;
					indices[index++] = i1++;
					indices[index++] = i2++;
					indices[index++] = i3++;
				}
			}
		}

		// south pole triangles
		for (var i = 0; i < this.radialSamples; i++) {
			var i0, i1, i2;

			if (!this._useSharedPoleVertices) {
				i0 = i;
				i1 = i + this.radialSamples + 2;
				i2 = i + this.radialSamples + 1;
			} else {
				i0 = i;
				i1 = this.vertexCount - 2;
				i2 = i + 1;
			}

			if (!this.viewInside) {
				indices[index++] = i0;
				indices[index++] = i1;
				indices[index++] = i2;
			} else {
				indices[index++] = i0;
				indices[index++] = i2;
				indices[index++] = i1;
			}
		}

		// north pole triangles
		// - point iOffset point to the start of the last generated ring of vertices
		var iOffset = (zEnd - zBegin - 1) * (this.radialSamples + 1);
		for (var i = 0; i < this.radialSamples; i++) {
			var i0, i1, i2;

			if (!this._useSharedPoleVertices) {
				// as we are in the last pole ring (with iOffset added), step back to the
				// next-to-last as there is no pole vertex in this mode.
				i0 = i + iOffset - this.radialSamples - 1;
				i1 = i + iOffset - this.radialSamples;
				i2 = i + iOffset;
			} else {
				i0 = i + iOffset;
				i1 = i + 1 + iOffset;
				i2 = this.vertexCount - 1;
			}

			if (!this.viewInside) {
				indices[index++] = i0;
				indices[index++] = i1;
				indices[index++] = i2;
			} else {
				indices[index++] = i0;
				indices[index++] = i2;
				indices[index++] = i1;
			}
		}
		return this;
	};

	//! AT: there's a method for doing this exact thing on typed arrays, copyWithin()
	function copyInternal(buf, from, to) {
		buf[to * 3 + 0] = buf[from * 3 + 0];
		buf[to * 3 + 1] = buf[from * 3 + 1];
		buf[to * 3 + 2] = buf[from * 3 + 2];
	}

	/**
	 * Returns a clone of this sphere
	 * @returns {Sphere}
	 */
	Sphere.prototype.clone = function () {
		var options = _.shallowSelectiveClone(this, ['zSamples', 'radialSamples', 'radius', 'textureMode']);

		return new Sphere(options);
	};

	/** Possible texture wrapping modes: Linear, Projected, Polar, Chromeball
	 * @type {Object}
	 */
	Sphere.TextureModes = {
		Linear: 'Linear',
		Projected: 'Projected',
		Polar: 'Polar',
		Chromeball: 'Chromeball'
	};

	return Sphere;
})(goo.MeshData,goo.Vector3,goo.MathUtils,goo.ObjectUtils);
goo.Cylinder = (function (
	MeshData,
	Vector3,
	_
) {
	'use strict';

	/**
	 * A 3D object representing a cylinder.
	 * @extends MeshData
	 * @param {number} [radialSamples=8] Number of slices
	 * @param {number} [radiusTop=0.5] Radius of the cylinder at the top.
	 * @param {number} [radiusBottom=radiusTop] Radius of the cylinder at the bottom. Defaults to radiusTop.
	 * @param {number} [height=1] Height
	 */
	function Cylinder(radialSamples, radiusTop, radiusBottom, height) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			radialSamples = props.radialSamples;
			radiusTop = props.radiusTop;
			radiusBottom = props.radiusBottom;
			height = props.height;
		}
		this.radialSamples = radialSamples || 8;
		this.radiusTop = typeof radiusTop === 'undefined' ? 0.5 : radiusTop;
		this.radiusBottom = typeof radiusBottom === 'undefined' ? this.radiusTop : radiusBottom;
		this.height = typeof height === 'undefined' ? 1 : height;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		MeshData.call(this, attributeMap, this.radialSamples * 4 + 2 + 2, (this.radialSamples * 3) * 4);

		// could be done better with 2 triangle fans and a triangle strip
		this.indexModes = ['Triangles'];

		this.rebuild();
	}

	Cylinder.prototype = Object.create(MeshData.prototype);
	Cylinder.prototype.constructor = Cylinder;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Cylinder} Self for chaining.
	 */
	Cylinder.prototype.rebuild = function () {
		var verts = [];
		var norms = [];
		var tex = [];
		var indices = [];
		var height = this.height;
		var halfHeight = height / 2;
		var radiusTop = this.radiusTop;
		var radiusBottom = this.radiusBottom;
		var radialSamples = this.radialSamples;

		var ak = Math.PI * 2 / radialSamples;
		var at = 1 / radialSamples;

		var lastIndex = radialSamples * 4 + 2 + 2 - 1;
		var normal = new Vector3();

		var tan = 0;
		if (height) {
			tan = Math.tan((radiusBottom - radiusTop) / height);
		}

		for (var i = 0, k = 0, t = 0; i < radialSamples; i++, k += ak, t += at) {
			var cos = Math.cos(k);
			var sin = Math.sin(k);
			var xTop = cos * radiusTop;
			var yTop = sin * radiusTop;
			var xBottom = cos * radiusBottom;
			var yBottom = sin * radiusBottom;

			verts.push(
				xTop, yTop, halfHeight, // disk top
				xBottom, yBottom, -halfHeight, // disk bottom
				xTop, yTop, halfHeight,  // side top
				xBottom, yBottom, -halfHeight  // side bottom
			);

			normal.setDirect(cos, sin, tan);
			normal.normalize();

			norms.push(
				0, 0, 1,
				0, 0, -1,
				normal.x, normal.y, normal.z,
				normal.x, normal.y, normal.z
				//cos, sin, 0,
				//cos, sin, 0
			);

			tex.push(
				cos / 4 + 0.25, sin / 4 + 0.75,
				cos / 4 + 0.25, sin / 4 + 0.25,
				0.5, t,
				1.0, t
			);
		}

		verts.push(
			radiusTop, 0.0, halfHeight,
			radiusBottom, 0.0, -halfHeight
		);

		norms.push(
			1.0, 0.0, 0.0,
			1.0, 0.0, 0.0
		);

		tex.push(
			0.5, 1.0,
			1.0, 1.0
		);

		for (var i = 0; i < radialSamples - 1; i++) {
			indices.push(
				lastIndex, i * 4 + 0, i * 4 + 4,
				i * 4 + 1, lastIndex - 1, i * 4 + 5,
				i * 4 + 4 + 2, i * 4 + 2, i * 4 + 4 + 3,
				i * 4 + 2, i * 4 + 3, i * 4 + 4 + 3
			);
		}

		indices.push(
			lastIndex, i * 4 + 0, 0,
			i * 4 + 1, lastIndex - 1, 0 + 1,
			i * 4 + 4, i * 4 + 2, i * 4 + 5,
			i * 4 + 2, i * 4 + 3, i * 4 + 5
		);

		verts.push(
			0, 0, -halfHeight,
			0, 0, halfHeight
		);

		norms.push(
			0, 0, -0.5,
			0, 0, 0.5
		);

		tex.push(
			0.25, 0.25,
			0.25, 0.75
		);

		this.getAttributeBuffer(MeshData.POSITION).set(verts);
		this.getAttributeBuffer(MeshData.NORMAL).set(norms);
		this.getAttributeBuffer(MeshData.TEXCOORD0).set(tex);
		this.getIndexBuffer().set(indices);

		return this;
	};

	/**
	 * Returns a clone of this cylinder
	 * @returns {Cylinder}
	 */
	Cylinder.prototype.clone = function () {
		var options = _.shallowSelectiveClone(this, ['radialSamples', 'radiusTop', 'radiusBottom', 'height']);

		return new Cylinder(options);
	};

	return Cylinder;
})(goo.MeshData,goo.Vector3,goo.ObjectUtils);
goo.Torus = (function (
	MeshData,
	Vector3,
	MathUtils,
	_
) {
	'use strict';

	/**
	 * A donut-shaped model.
	 * @extends MeshData
	 * @param {number} [circleSamples=8] Number of segments.
	 * @param {number} [radialSamples=8] Number of slices.
	 * @param {number} [tubeRadius=1] Radius of tube.
	 * @param {number} [centerRadius=2] Radius from center.
	 */
	function Torus(circleSamples, radialSamples, tubeRadius, centerRadius) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			circleSamples = props.circleSamples;
			radialSamples = props.radialSamples;
			tubeRadius = props.tubeRadius;
			centerRadius = props.centerRadius;
		}
		this.circleSamples = circleSamples !== undefined ? circleSamples : 8;
		this.radialSamples = radialSamples !== undefined ? radialSamples : 8;
		this.tubeRadius = tubeRadius !== undefined ? tubeRadius : 1;
		this.centerRadius = centerRadius !== undefined ? centerRadius : 2;

		/** Inward-facing normals.
		 * @type {boolean}
		 * @default
		 */
		this.viewInside = false;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		var vertices = (this.circleSamples + 1) * (this.radialSamples + 1);
		var indices = 6 * this.circleSamples * this.radialSamples;
		MeshData.call(this, attributeMap, vertices, indices);

		this.rebuild();
	}

	Torus.prototype = Object.create(MeshData.prototype);
	Torus.prototype.constructor = Torus;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Torus} Self for chaining.
	 */
	Torus.prototype.rebuild = function () {
		var vbuf = this.getAttributeBuffer(MeshData.POSITION);
		var norms = this.getAttributeBuffer(MeshData.NORMAL);
		var texs = this.getAttributeBuffer(MeshData.TEXCOORD0);
		var indices = this.getIndexBuffer();

		// generate geometry
		var inverseCircleSamples = 1.0 / this.circleSamples;
		var inverseRadialSamples = 1.0 / this.radialSamples;
		var i = 0;
		// generate the cylinder itself
		var radialAxis = new Vector3(), torusMiddle = new Vector3(), tempNormal = new Vector3();
		for (var circleCount = 0; circleCount < this.circleSamples; circleCount++) {
			// compute center point on torus circle at specified angle
			var circleFraction = circleCount * inverseCircleSamples;
			var theta = MathUtils.TWO_PI * circleFraction;
			var cosTheta = Math.cos(theta);
			var sinTheta = Math.sin(theta);
			radialAxis.setDirect(cosTheta, sinTheta, 0);
			torusMiddle.copy(radialAxis).scale(this.centerRadius);

			// compute slice vertices with duplication at end point
			var iSave = i;
			for (var radialCount = 0; radialCount < this.radialSamples; radialCount++) {
				var radialFraction = radialCount * inverseRadialSamples;
				// in [0, 1)
				var phi = MathUtils.TWO_PI * radialFraction;
				var cosPhi = Math.cos(phi);
				var sinPhi = Math.sin(phi);

				tempNormal.copy(radialAxis).scale(cosPhi);
				tempNormal.z += sinPhi;
				tempNormal.normalize();

				if (!this.viewInside) {
					norms[i * 3 + 0] = tempNormal.x;
					norms[i * 3 + 1] = tempNormal.y;
					norms[i * 3 + 2] = tempNormal.z;
				} else {
					norms[i * 3 + 0] = -tempNormal.x;
					norms[i * 3 + 1] = -tempNormal.y;
					norms[i * 3 + 2] = -tempNormal.z;
				}

				tempNormal.scale(this.tubeRadius).add(torusMiddle);

				vbuf[i * 3 + 0] = tempNormal.x;
				vbuf[i * 3 + 1] = tempNormal.y;
				vbuf[i * 3 + 2] = tempNormal.z;

				texs[i * 2 + 0] = radialFraction;
				texs[i * 2 + 1] = circleFraction;

				i++;
			}

			copyInternal(vbuf, iSave, i);
			copyInternal(norms, iSave, i);

			texs[i * 2 + 0] = 1.0;
			texs[i * 2 + 1] = circleFraction;

			i++;
		}

		// duplicate the cylinder ends to form a torus
		for (var iR = 0; iR <= this.radialSamples; iR++, i++) {
			copyInternal(vbuf, iR, i);
			copyInternal(norms, iR, i);
			copyInternal2(texs, iR, i);
			texs[i * 2 + 1] = 1.0;
		}

		// generate connectivity
		var index = 0;
		var connectionStart = 0;
		for (var circleCount = 0; circleCount < this.circleSamples; circleCount++) {
			var i0 = connectionStart;
			var i1 = i0 + 1;
			connectionStart += this.radialSamples + 1;
			var i2 = connectionStart;
			var i3 = i2 + 1;
			for (i = 0; i < this.radialSamples; i++) {
				if (!this.viewInside) {
					indices[index++] = i0++;
					indices[index++] = i2;
					indices[index++] = i1;
					indices[index++] = i1++;
					indices[index++] = i2++;
					indices[index++] = i3++;
				} else {
					indices[index++] = i0++;
					indices[index++] = i1;
					indices[index++] = i2;
					indices[index++] = i1++;
					indices[index++] = i3++;
					indices[index++] = i2++;
				}
			}
		}

		return this;
	};

	//! AT: there's a method for doing this exact thing on typed arrays, copyWithin()
	function copyInternal(buf, from, to) {
		buf[to * 3 + 0] = buf[from * 3 + 0];
		buf[to * 3 + 1] = buf[from * 3 + 1];
		buf[to * 3 + 2] = buf[from * 3 + 2];
	}

	function copyInternal2(buf, from, to) {
		buf[to * 2 + 0] = buf[from * 2 + 0];
		buf[to * 2 + 1] = buf[from * 2 + 1];
	}

	/**
	 * Returns a clone of this texture torus
	 * @returns {Torus}
	 */
	Torus.prototype.clone = function () {
		var options = _.shallowSelectiveClone(this,
			['circleSamples', 'radialSamples', 'tubeRadius', 'centerRadius']);

		return new Torus(options);
	};

	return Torus;
})(goo.MeshData,goo.Vector3,goo.MathUtils,goo.ObjectUtils);
goo.Disk = (function (
	MeshData,
	_
) {
	'use strict';

	/**
	 * A disk shape
	 * @extends MeshData
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/shapes/Disk/Disk-vtest.html Working example
	 * @param {number} [nSegments=8] Number of slices
	 * @param {number} [radius=1] Radius of the disk
	 * @param {number} [pointiness=0] The center of the disk can be offset in both directions from its outer edge by setting a positive or negative pointiness.
	 */
	function Disk(nSegments, radius, pointiness) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			nSegments = props.nSegments;
			radius = props.radius;
			pointiness = props.pointiness;
		}
		//! AT: in cylinder and cone this is called radialSamples
		this.nSegments = nSegments || 8;
		this.radius = radius || 1;
		this.pointiness = pointiness || 0;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		MeshData.call(this, attributeMap, this.nSegments + 1, this.nSegments * 3);

		this.indexModes = ['Triangles'];

		this.rebuild();
	}

	Disk.prototype = Object.create(MeshData.prototype);
	Disk.prototype.constructor = Disk;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Disk} Self for chaining.
	 */
	Disk.prototype.rebuild = function () {
		var verts = [];
		var norms = [];
		var tex = [];
		var indices = [];

		var slope = Math.atan2(this.radius, this.pointiness);

		var angleIncrement = Math.PI * 2 / this.nSegments;
		for (var i = 0, angle = 0; i < this.nSegments; i++, angle += angleIncrement) {
			verts.push(
				Math.cos(angle) * this.radius,
				Math.sin(angle) * this.radius,
				0);

			norms.push(
				Math.cos(angle) * Math.cos(slope),
				Math.sin(angle) * Math.cos(slope),
				Math.sin(slope));

			tex.push(
				Math.cos(angle) * 0.5 + 0.5,
				Math.sin(angle) * 0.5 + 0.5);

			indices.push(this.nSegments, i, (i + 1) % this.nSegments);
		}

		verts.push(0, 0, this.pointiness);
		norms.push(0, 0, 1);
		tex.push(0.5, 0.5);

		this.getAttributeBuffer(MeshData.POSITION).set(verts);
		this.getAttributeBuffer(MeshData.NORMAL).set(norms);
		this.getAttributeBuffer(MeshData.TEXCOORD0).set(tex);
		this.getIndexBuffer().set(indices);

		return this;
	};

	/**
	 * Returns a clone of this disk
	 * @returns {Disk}
	 */
	Disk.prototype.clone = function () {
		var options = _.shallowSelectiveClone(this, ['nSegments', 'radius', 'pointiness']);

		return new Disk(options);
	};

	return Disk;
})(goo.MeshData,goo.ObjectUtils);
goo.Cone = (function (
	MeshData,
	_
) {
	'use strict';

	/**
	 * Cone mesh data
	 * @extends MeshData
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/shapes/Cone/Cone-vtest.html Working example
	 * @param {number} [radialSamples=8] Number of slices
	 * @param {number} [radius=1] Radius of the cone
	 * @param {number} [height=2] The height of the cone
	 */
	function Cone(radialSamples, radius, height) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			radialSamples = props.radialSamples;
			radius = props.radius;
			height = props.height;
		}
		this.radialSamples = radialSamples || 8;
		this.radius = radius || 1;
		this.height = typeof height === 'undefined' ? 2 : height;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		MeshData.call(this, attributeMap, this.radialSamples * 3 + this.radialSamples + 1, this.radialSamples * 3 * 2);

		this.indexModes = ['Triangles'];

		this.rebuild();
	}

	Cone.prototype = Object.create(MeshData.prototype);
	Cone.prototype.constructor = Cone;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {Cone} Self for chaining.
	 */
	Cone.prototype.rebuild = function () {
		var verts = [];
		var norms = [];
		var tex = [];
		var indices = [];

		// pointy part
		var slope = Math.atan2(this.radius, this.height);

		var ak = Math.PI * 2 / this.radialSamples;
		var at = 1 / this.radialSamples;
		for (var i = 0, k = 0, t = 0; i < this.radialSamples; i++, k += ak, t += at) {
			verts.push(
				0, 0, this.height,
				Math.cos(k) * this.radius, Math.sin(k) * this.radius, 0,
				Math.cos(k + ak) * this.radius, Math.sin(k + ak) * this.radius, 0
			);

			norms.push(
				0, 0, 1,
				Math.cos(k) * Math.cos(slope), Math.sin(k) * Math.cos(slope), Math.sin(slope),
				Math.cos(k + ak) * Math.cos(slope), Math.sin(k + ak) * Math.cos(slope), Math.sin(slope)
			);

			tex.push(
				t + at / 2, 1.0,
				t, 0.5,
				t + at, 0.5
			);

			indices.push(i * 3 + 0, i * 3 + 1, i * 3 + 2);
		}

		var baseCenterIndex = i * 3 + 0;

		verts.push(0, 0, 0);
		norms.push(0, 0, -1);
		tex.push(0.25, 0.25);

		// base
		for (var i = 1, k = 0; i <= this.radialSamples - 1; i++, k += ak) {
			verts.push(Math.cos(k) * this.radius, Math.sin(k) * this.radius, 0);
			norms.push(0, 0, -1);
			tex.push(Math.cos(k) * 0.25 + 0.25, Math.sin(k) * 0.25 + 0.25);

			indices.push(baseCenterIndex + i, baseCenterIndex, baseCenterIndex + i + 1);
		}

		verts.push(Math.cos(k) * this.radius, Math.sin(k) * this.radius, 0);
		norms.push(0, 0, -1);
		tex.push(Math.cos(k) * 0.25 + 0.25, Math.sin(k) * 0.25 + 0.25);

		indices.push(baseCenterIndex + this.radialSamples, baseCenterIndex, baseCenterIndex + 1);

		this.getAttributeBuffer(MeshData.POSITION).set(verts);
		this.getAttributeBuffer(MeshData.NORMAL).set(norms);
		this.getAttributeBuffer(MeshData.TEXCOORD0).set(tex);
		this.getIndexBuffer().set(indices);

		return this;
	};

	/**
	 * Returns a clone of this cone
	 * @returns {Cone}
	 */
	Cone.prototype.clone = function () {
		var options = _.shallowSelectiveClone(this, ['radialSamples', 'radius', 'height']);

		return new Cone(options);
	};

	return Cone;
})(goo.MeshData,goo.ObjectUtils);
goo.ShapeCreatorMemoized = (function (
	Box,
	Quad,
	Sphere,
	Cylinder,
	Torus,
	Disk,
	Cone,
	ObjectUtil
) {
	'use strict';

	/**
	 * Factory for shape creation.
	 * Only used to define the class. Should never be instantiated.
	 */
	function ShapeCreatorMemoized() {}

	var _cache = {};
	//var hits = 0, requests = 0;

	function computeHash(name, options) {
		var keys = Object.keys(options);
		var optionsStr = keys.map(function (key) {
			return key + '' + options[key];
		}).join('');
		return name + optionsStr;
	}

	function cacheOrCreate(name, options, createShape) {
		var hash = computeHash(name, options);
		//requests++;
		if (_cache[hash]) {
			//hits++;
			//console.log('HIT, ratio: ', hits/requests);
			return _cache[hash];
		} else {
			//console.log('MISS, ratio: ', hits/requests);
			var shape = createShape();
			_cache[hash] = shape;
			return shape;
		}
	}

	ShapeCreatorMemoized.createQuad = function (options, oldMeshData) {
		var width = 1, height = 1, tileX = 1, tileY = 1;
		if (!oldMeshData ||
			width !== oldMeshData.xExtent ||
			height !== oldMeshData.yExtent ||
			tileX !== oldMeshData.tileX ||
			tileY !== oldMeshData.tileY) {
			return cacheOrCreate('quad', {}, function () {
				return new Quad(width, height, tileX, tileY);
			});
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.createBox = function (options, oldMeshData) {
		options = options || {};
		ObjectUtil.defaults(options, {
			textureMode: 'Uniform'
		});

		var width = 1, height = 1, length = 1, tileX = 1, tileY = 1;
		if (!oldMeshData ||
			width !== oldMeshData.xExtent ||
			height !== oldMeshData.yExtent ||
			length !== oldMeshData.zExtent ||
			tileX !== oldMeshData.tileX ||
			tileY !== oldMeshData.tileY ||
			options.textureMode !== oldMeshData.textureMode.name) {
			return cacheOrCreate('box', options, function () {
				return new Box(width, height, length, tileX, tileY, options.textureMode);
			});
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.createSphere = function (options, oldMeshData) {
		options = options || {};
		ObjectUtil.defaults(options, {
			zSamples: 8,
			radialSamples: 8,
			textureMode: 'Projected',
			radius: 1
		});

		if (!oldMeshData ||
			options.zSamples !== oldMeshData.zSamples - 1 ||
			options.radialSamples !== oldMeshData.radialSamples ||
			options.textureMode !== oldMeshData.textureMode.name ||
			options.radius !== oldMeshData.radius) {
			return cacheOrCreate('sphere', options, function () {
				return new Sphere(options.zSamples, options.radialSamples, options.radius, options.textureMode);
			});
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.createCylinder = function (options, oldMeshData) {
		options = options || {};
		ObjectUtil.defaults(options, {
			radialSamples: 8,
			radius: 1
		});

		if (!oldMeshData ||
			options.radialSamples !== oldMeshData.radialSamples ||
			options.radius !== oldMeshData.radius) {
			return cacheOrCreate('cylinder', options, function () {
				return new Cylinder(options.radialSamples, options.radius);
			});
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.createTorus = function (options, oldMeshData) {
		options = options || {};
		ObjectUtil.defaults(options, {
			radialSamples: 8,
			circleSamples: 12,
			tubeRadius: 0.2,
			centerRadius: 1
		});

		if (!oldMeshData ||
			options.radialSamples !== oldMeshData._radialSamples ||
			options.circleSamples !== oldMeshData._circleSamples ||
			options.tubeRadius !== oldMeshData._tubeRadius ||
			options.centerRadius !== oldMeshData._centerRadius) {
			//return cacheOrCreate('torus', options, function () { // cannot cache torus because of real typed tubeRadius
			return new Torus(options.circleSamples, options.radialSamples, options.tubeRadius, options.centerRadius);
			//});
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.createDisk = function (options, oldMeshData) {
		options = options || {};
		ObjectUtil.defaults(options, {
			radialSamples: 8,
			pointiness: 0,
			radius: 1
		});

		if (!oldMeshData ||
			options.radialSamples !== oldMeshData.nSegments ||
			options.pointiness !== oldMeshData.pointiness ||
			options.radius !== oldMeshData.radius) {
			if (options.pointiness === Math.floor(options.pointiness)) {
				return cacheOrCreate('disk', options, function () {
					return new Disk(options.radialSamples, options.radius, options.pointiness);
				});
			} else {
				return new Disk(options.radialSamples, options.radius, options.pointiness);
			}
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.createCone = function (options, oldMeshData) {
		options = options || {};
		ObjectUtil.defaults(options, {
			radialSamples: 8,
			height: 0,
			radius: 1
		});

		if (!oldMeshData ||
			options.radialSamples !== oldMeshData.radialSamples ||
			options.height !== oldMeshData.height ||
			options.radius !== oldMeshData.radius) {
			if (options.height === Math.floor(options.height)) {
				return cacheOrCreate('cone', options, function () {
					return new Cone(options.radialSamples, options.radius, options.height);
				});
			} else {
				return new Cone(options.radialSamples, options.radius, options.height);
			}
		} else {
			return oldMeshData;
		}
	};

	ShapeCreatorMemoized.clearCache = function (context) {
		var keys = Object.keys(_cache);
		for (var i = 0; i < keys[i]; i++) {
			var key = keys[i];
			var shape = _cache[key];
			if (context) {
				shape.destroy(context);
			}
			delete _cache[key];
		}
	};

	return ShapeCreatorMemoized;
})(goo.Box,goo.Quad,goo.Sphere,goo.Cylinder,goo.Torus,goo.Disk,goo.Cone,goo.ObjectUtil);
goo.CameraComponentHandler = (function (
	ComponentHandler,
	CameraComponent,
	Camera,
	RSVP,
	pu,
	_
) {
	'use strict';

	/**
	 * For handling loading of camera components
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function CameraComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'CameraComponent';
	}

	CameraComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	ComponentHandler._registerClass('camera', CameraComponentHandler);
	CameraComponentHandler.prototype.constructor = CameraComponentHandler;

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @returns {Object}
	 * @private
	 */
	CameraComponentHandler.prototype._prepare = function (config) {
		_.defaults(config, {
			near: 1,
			far: 10000,
			projectionMode: 'Perspective',
			aspect: 1,
			lockedRatio: false
		});
		if (config.projectionMode === 'Perspective' && config.fov === undefined) {
			config.fov = 45;
		}
		if (config.projectionMode === 'Parallel' && config.size === undefined) {
			config.size = 100;
		}
		if (config.projectionMode !== 'Perspective' && config.projectionMode !== 'Parallel') {
			config.projectionMode = 'Perspective';
		}
	};

	/**
	 * Create camera component object.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @returns {CameraComponent} the created component object
	 * @private
	 */
	CameraComponentHandler.prototype._create = function () {
		var camera = new Camera(45, 1, 1, 1000);
		var component = new CameraComponent(camera);
		return component;
	};

	// TODO: Handle if cameracomponent is removed and camera is active

	/**
	 * Update engine cameracomponent object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	CameraComponentHandler.prototype.update = function (entity, config, options) {
		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }
			component.camera.setProjectionMode(Camera[config.projectionMode]);
			component.camera.lockedRatio = false;
			if (config.projectionMode === 'Perspective') {
				component.camera.setFrustumPerspective(config.fov, null, config.near, config.far);
			} else {
				var size = config.size;
				component.camera.setFrustum(config.near, config.far, -size, size, size, -size, null);
				component.camera.size = size;
			}
			return component;
		});
	};

	return CameraComponentHandler;
})(goo.ComponentHandler,goo.CameraComponent,goo.Camera,goo.rsvp,goo.PromiseUtils,goo.ObjectUtils);
goo.EntityHandler = (function (
	ConfigHandler,
	ComponentHandler,
	RSVP,
	StringUtils,
	PromiseUtils
) {
	'use strict';

	/**
	 * Handler for loading entities into engine
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function EntityHandler() {
		ConfigHandler.apply(this, arguments);
		this._componentHandlers = {};
	}

	EntityHandler.prototype = Object.create(ConfigHandler.prototype);
	EntityHandler.prototype.constructor = EntityHandler;
	ConfigHandler._registerClass('entity', EntityHandler);

	/**
	 * Creates an empty entity
	 * @param {string} ref will be the entity's id
	 * @returns {Entity}
	 * @private
	 */
	EntityHandler.prototype._create = function () {
		return this.world.createEntity();
	};

	/**
	 * Removes an entity
	 * @param {ref}
	 * @private
	 */
	EntityHandler.prototype._remove = function (ref) {
		var entity = this._objects.get(ref);
		var that = this;
		if (entity) {
			// Remove components
			var promises = [];
			var components = entity._components.slice(0);
			for (var i = 0; i < components.length; i++) {
				var type = this._getComponentType(components[i]);
				var p = this._updateComponent(entity, type, null);
				if (p instanceof RSVP.Promise) {
					promises.push(p);
				}
			}
			return RSVP.all(promises)
			.then(function () {
				entity.removeFromWorld();
				that._objects.delete(ref);
			});
		}
	};

	function updateTags(entity, tags) {
		entity._tags.clear();
		if (!tags) { return; }

		for (var tag in tags) {
			entity.setTag(tag);
		}
	}

	function updateAttributes(entity, attributes) {
		entity._attributes.clear();
		if (!attributes) { return; }

		for (var attribute in attributes) {
			entity.setAttribute(attribute, attributes[attribute]);
		}
	}

	/**
	 * Adds/updates/removes an entity
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated entity or null if removed
	 */
	EntityHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (entity) {
			if (!entity) { return; }
			entity.id = ref;
			entity.name = config.name;
			entity.static = !!config.static;

			updateTags(entity, config.tags);
			updateAttributes(entity, config.attributes);

			var promises = [];

			// Adding/updating components
			for (var type in config.components) {
				if (config.components[type]) {
					var p = that._updateComponent(entity, type, config.components[type], options);
					if (p) { promises.push(p); }
					else {
						console.error('Error handling component ' + type);
					}
				}
			}

			// Removing components
			var components = entity._components;
			for (var i = 0; i < components.length; i++) {
				var type = that._getComponentType(components[i]);
				if (!config.components[type]) {
					that._updateComponent(entity, type, null, options);
				}
			}
			// When all is done, hide or show and return
			return PromiseUtils.optimisticAll(promises).then(function (/*components*/) {
				if (config.hidden) {
					entity.hide();
				} else {
					entity.show();
				}
				return entity;
			});
		});
	};

	/**
	 * Adds/updates/removes a component on an entity
	 * @param {Entity} entity
	 * @param {string} type
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with updated entity
	 * @private
	 */
	EntityHandler.prototype._updateComponent = function (entity, type, config, options) {
		var handler = this._getHandler(type);
		if (!handler) { return null; }

		var p = handler.update(entity, config, options);
		if (!p || !p.then) { return null; }

		return p;
	};

	/**
	 * Get the type for the component. Needed to match engine components against data model
	 * component types.
	 * @param {Component} component
	 * @returns {string}
	 * @private
	 */
	EntityHandler.prototype._getComponentType = function (component) {
		var type = component.type;
		type = type.slice(0, type.lastIndexOf('Component'));
		type = StringUtils.uncapitalize(type);
		if (type === 'howler') { type = 'sound'; } // HowlerComponent should be renamed
		return type;
	};

	/**
	 * Gets the handler for a component type or creates a new one if necessary
	 * @param {string} type
	 * @returns {ComponentHandler}
	 */
	EntityHandler.prototype._getHandler = function (type) {
		if (!this._componentHandlers[type]) {
			var Handler = ComponentHandler.getHandler(type);
			if (Handler) {
				this._componentHandlers[type] = new Handler(
					this.world,
					this.getConfig,
					this.updateObject,
					this.loadObject
				);
			}
		}
		return this._componentHandlers[type];
	};

	return EntityHandler;
})(goo.ConfigHandler,goo.ComponentHandler,goo.rsvp,goo.StringUtils,goo.PromiseUtils);
goo.LightComponentHandler = (function (
	ComponentHandler,
	LightComponent,
	PointLight,
	SpotLight,
	DirectionalLight,
	Vector3,
	ObjectUtils
) {
	'use strict';

	/**
	 * For handling loading of light components
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function LightComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'LightComponent';
	}

	LightComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	LightComponentHandler.prototype.constructor = LightComponentHandler;
	ComponentHandler._registerClass('light', LightComponentHandler);


	//! AT: would be nice to have a FuncUtil.memoize()
	var cachedSupportsShadows;
	var supportsShadows = function () {
		if (cachedSupportsShadows === undefined) {
			var isIos = /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
			cachedSupportsShadows = !isIos;
		}
		return cachedSupportsShadows;
	};


	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @private
	 */
	LightComponentHandler.prototype._prepare = function (config) {
		ObjectUtils.defaults(config, {
			direction: [0, 0, 0],
			color: [1, 1, 1],
			shadowCaster: false,
			lightCookie: null
		});

		if (config.type !== 'DirectionalLight') {
			config.range = (config.range !== undefined) ? config.range : 1000;
		}

		if (config.shadowCaster && supportsShadows()) {
			config.shadowSettings = config.shadowSettings || {};
			ObjectUtils.defaults(config.shadowSettings, {
				shadowType: 'Basic',
				near: 1,
				far: 1000,
				resolution: [512, 512],
				darkness: 0.5
			});

			var settings = config.shadowSettings;

			if (settings.projection === 'Parallel') {
				settings.size = (settings.size !== undefined) ? settings.size : 400;
			} else {
				settings.fov = (settings.fov !== undefined) ? settings.fov : 55;
			}
		}
	};

	/**
	 * Create light component object based on the config.
	 * @returns {LightComponent} the created component object
	 * @private
	 */
	LightComponentHandler.prototype._create = function () {
		return new LightComponent();
	};

	/**
	 * Update engine cameracomponent object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	LightComponentHandler.prototype.update = function (entity, config, options) {
		var that = this;
		var Light = {
			SpotLight: SpotLight,
			DirectionalLight: DirectionalLight,
			PointLight: PointLight
		};

		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }
			var light = component.light;
			if (!light || Light[config.type] !== light.constructor) {
				light = new Light[config.type]();
				component.light = light;
			}

			for (var key in config) {
				var value = config[key];
				if (light.hasOwnProperty(key)) {
					if (key === 'shadowSettings') {
						for (var key in value) {
							var shadowVal = value[key];
							if (light.shadowSettings[key] instanceof Vector3) {
								light.shadowSettings[key].setDirect(shadowVal[0], shadowVal[1], shadowVal[2]);
							} else {
								light.shadowSettings[key] = ObjectUtils.clone(shadowVal);
							}
						}
					} else if (light[key] instanceof Vector3) {
						light[key].setDirect(value[0], value[1], value[2]);
					} else {
						light[key] = ObjectUtils.clone(value);
					}
				}
			}

			if (config.type === 'PointLight' || !supportsShadows()) {
				light.shadowCaster = false;
			}

			if (config.lightCookie && config.type !== 'PointLight') {
				var textureObj = config.lightCookie;

				if (!textureObj || !textureObj.textureRef || textureObj.enabled === false) {
					light.lightCookie = null;
					return component;
				} else {
					return that._load(textureObj.textureRef, options).then(function (texture) {
						light.lightCookie = texture;
						return component;
					});
				}
			} else {
				light.lightCookie = null;
				return component;
			}
		});
	};

	return LightComponentHandler;
})(goo.ComponentHandler,goo.LightComponent,goo.PointLight,goo.SpotLight,goo.DirectionalLight,goo.Vector3,goo.ObjectUtils);
goo.MaterialHandler = (function (
	ConfigHandler,
	Material,
	ShaderLib,
	RenderQueue,
	RSVP,
	ObjectUtils
) {
	'use strict';

	/**
	 * Handler for loading materials into engine
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function MaterialHandler() {
		ConfigHandler.apply(this, arguments);
	}

	MaterialHandler.prototype = Object.create(ConfigHandler.prototype);
	MaterialHandler.prototype.constructor = MaterialHandler;
	ConfigHandler._registerClass('material', MaterialHandler);

	MaterialHandler.ENGINE_SHADER_PREFIX = 'GOO_ENGINE_SHADERS/';

	/**
	 * Preparing material config by populating it with defaults.
	 * @param {Object} config
	 * @private
	 */
	MaterialHandler.prototype._prepare = function (config) {
		ObjectUtils.defaults(config, {
			blendState: {},
			cullState: {},
			depthState: {},
			renderQueue: -1,
			dualTransparency: false,
			wireframe: false,
			flat: false
		});

		ObjectUtils.defaults(config.blendState, {
			blending: 'NoBlending',
			blendEquation: 'AddEquation',
			blendSrc: 'SrcAlphaFactor',
			blendDst: 'OneMinusSrcAlphaFactor'
		});

		ObjectUtils.defaults(config.cullState, {
			enabled: true,
			cullFace: 'Back',
			frontFace: 'CCW'
		});

		ObjectUtils.defaults(config.depthState, {
			enabled: true,
			write: true
		});
	};

	/**
	 * Creates a (somewhat) empty material.
	 * @returns {Material}
	 * @private
	 */
	MaterialHandler.prototype._create = function () {
		return new Material();
	};

	MaterialHandler.prototype._remove = function (ref) {
		var material = this._objects.get(ref);
		if (!material) {
			return;
		}
		// material.shader.destroy(); // don't destroy the shader; it may be used by some other material
		material.empty();
		this._objects.delete(ref);
	};

	/**
	 * Adds/updates/removes a a material
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated material or null if removed
	 */
	MaterialHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (material) {
			if (!material) { return; }

			var promises = [];

			// Material settings
			ObjectUtils.extend(material.blendState, config.blendState);
			ObjectUtils.extend(material.cullState, config.cullState);
			ObjectUtils.extend(material.depthState, config.depthState);

			material.id = config.id;
			material.name = config.name;
			material.wireframe = config.wireframe;
			material.flat = config.flat;
			material.dualTransparency = config.dualTransparency;

			if (config.renderQueue === -1) {
				if (config.blendState.blending !== 'NoBlending') {
					material.renderQueue = RenderQueue.TRANSPARENT;
				} else {
					material.renderQueue = null;
				}
			} else {
				material.renderQueue = config.renderQueue;
			}

			material.uniforms = {};
			for (var name in config.uniforms) {
				if (config.uniforms[name].enabled === undefined) {
					material.uniforms[name] = ObjectUtils.clone(config.uniforms[name]);
				} else if (config.uniforms[name].enabled) {
					material.uniforms[name] = ObjectUtils.clone(config.uniforms[name].value);
				}
			}

			// TODO: This is a temporary hack until we fully moved shininess into the last entry of specular [r, g, b, spec_power]
			if (material.uniforms.materialSpecular !== undefined && material.uniforms.materialSpecularPower !== undefined) {
				material.uniforms.materialSpecular[3] = material.uniforms.materialSpecularPower;
			}

			// Shader
			var shaderRef = config.shaderRef;
			if (!shaderRef) {
				material.shader = Material.createShader(ShaderLib.texturedLit, 'DefaultShader');
			}
			else if (shaderRef.indexOf(MaterialHandler.ENGINE_SHADER_PREFIX) === 0) {
				var shaderName = shaderRef.slice(MaterialHandler.ENGINE_SHADER_PREFIX.length);
				material.shader = Material.createShader(ShaderLib[shaderName]);
			} else {
				var p = that._load(shaderRef, options).then(function (shader) {
					material.shader = shader;
				}).then(null, function (err) {
					throw new Error('Error loading shader: ' + err);
				});
				promises.push(p);
			}

			// Textures
			function addTexture(type, ref, options) {
				return that._load(ref, options).then(function (texture) {
					material.setTexture(type, texture);
				}).then(null, function (err) {
					throw new Error('Error loading texture: ' + ref + ' - ' + err);
				});
			}
			var textureRef;
			for (var type in config.texturesMapping) {
				textureRef = config.texturesMapping[type];
				if (!textureRef || !textureRef.textureRef || textureRef.enabled === false) {
					material.removeTexture(type);
				} else {
					promises.push(addTexture(type, textureRef.textureRef, options));
				}
			}
			for (var type in material._textureMaps) {
				if (!config.texturesMapping[type]) {
					material.removeTexture(type);
				}
			}
			return RSVP.all(promises).then(function () {
				return material;
			});
		});
	};

	return MaterialHandler;
})(goo.ConfigHandler,goo.Material,goo.ShaderLib,goo.RenderQueue,goo.rsvp,goo.ObjectUtils);
goo.MeshDataComponentHandler = (function (
	ComponentHandler,
	MeshDataComponent,
	BoundingBox,
	ShapeCreatorMemoized,
	RSVP,
	_,
	StringUtils
) {
	'use strict';

	/**
	 * For handling loading of meshdatacomponents
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function MeshDataComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'MeshDataComponent';
	}

	MeshDataComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	MeshDataComponentHandler.prototype.constructor = MeshDataComponentHandler;
	ComponentHandler._registerClass('meshData', MeshDataComponentHandler);

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @returns {Object}
	 * @private
	 */
	MeshDataComponentHandler.prototype._prepare = function (config) {
		return _.defaults(config, {
		});
	};

	/**
	 * Create meshdata component.
	 * @returns {MeshDataComponent} the created component object
	 * @private
	 */
	MeshDataComponentHandler.prototype._create = function () {
		return new MeshDataComponent();
	};

	/**
	 * Removes the meshdata component
	 * @param {string} ref
	 */
	MeshDataComponentHandler.prototype._remove = function (entity) {
		//! AT: why is this check needed?
		if (entity.meshDataComponent && entity.meshDataComponent.meshData && this.world.gooRunner) {
			entity.meshDataComponent.meshData.destroy(this.world.gooRunner.renderer.context);
		}
		entity.clearComponent('MeshDataComponent');
	};

	/**
	 * Update engine meshdatacomponent object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	MeshDataComponentHandler.prototype.update = function (entity, config, options) {
		var that = this;
		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }
			if (config.shape) {
				var shapeCreator = ShapeCreatorMemoized['create' + StringUtils.capitalize(config.shape)];
				if (shapeCreator) {
					component.meshData = shapeCreator(config.shapeOptions, component.meshData);
					component.autoCompute = true;
					return component;
				}
			} else if (config.meshRef) {
				var promises = [];
				// MeshData
				promises.push(that._load(config.meshRef, options).then(function (meshData) {
					component.meshData = meshData;
					if (meshData.boundingBox) {
						var min = meshData.boundingBox.min;
						var max = meshData.boundingBox.max;
						var size = [max[0] - min[0], max[1] - min[1], max[2] - min[2]];
						var center = [(max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5];
						var bounding = new BoundingBox();
						bounding.xExtent = size[0] / 2;
						bounding.yExtent = size[1] / 2;
						bounding.zExtent = size[2] / 2;
						bounding.center.setDirect(center[0], center[1], center[2]);
						component.modelBound = bounding;
						component.autoCompute = false;
					}
				}));
				// Skeleton pose
				if (config.poseRef) {
					promises.push(that._load(config.poseRef, options).then(function (pose) {
						component.currentPose = pose;
					}));
				} else {
					component.currentPose = null;
				}
				return RSVP.all(promises).then(function () {
					return component;
				});
			} else {
				console.warn('MeshDataComponent config does not contain a primitive spec or a reference to a mesh');
			}
		});
	};

	return MeshDataComponentHandler;
})(goo.ComponentHandler,goo.MeshDataComponent,goo.BoundingBox,goo.ShapeCreatorMemoized,goo.rsvp,goo.ObjectUtils,goo.StringUtils);
goo.MeshDataHandler = (function (
	ConfigHandler,
	MeshData,
	BufferUtils,
	Capabilities,
	PromiseUtils,
	ArrayUtils
) {
	'use strict';

	var WEIGHTS_PER_VERT = 4;

	/*jshint eqeqeq: false, -W041, bitwise: false */
	/**
	 * Handler for meshdata. Will not update, only create once
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function MeshDataHandler() {
		ConfigHandler.apply(this, arguments);
	}

	MeshDataHandler.prototype = Object.create(ConfigHandler.prototype);
	MeshDataHandler.prototype.constructor = MeshDataHandler;
	ConfigHandler._registerClass('mesh', MeshDataHandler);

	/**
	 * Removes the meshdata from the objects config
	 * @param {string} ref
	 */
	MeshDataHandler.prototype._remove = function (ref) {
		var meshData = this._objects.get(ref);
		if (meshData && this.world.gooRunner) {
			meshData.destroy(this.world.gooRunner.renderer.context);
		}
		this._objects.delete(ref);
	};

	/**
	 * Creates a MeshData once, then reuses that one without updating
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the Meshdata or null if removed
	 */
	MeshDataHandler.prototype._update = function (ref, config, options) {
		// Don't call ConfigHandler.prototype.update, since we don't want to do ._create in the normal way
		if (!config) {
			this._remove(ref);
			return PromiseUtils.resolve();
		}

		var meshData = this._objects.get(ref);
		if (meshData) {
			return PromiseUtils.resolve(meshData);
		}

		return this.loadObject(config.binaryRef, options).then(function (bindata) {
			if (!bindata) {
				throw new Error('Binary mesh data was empty');
			}
			var meshData = this._createMeshData(config, bindata);
			this._fillMeshData(meshData, config, bindata);

			this._objects.set(ref, meshData);
			return meshData;
		}.bind(this));
	};

	/**
	 * Creates a MeshData object with attributeMap according to config
	 * @param {Object} config
	 * @returns {MeshData}
	 * @private
	 */
	MeshDataHandler.prototype._createMeshData = function (config) {
		var skinned = config.type === 'SkinnedMesh';
		var vertexCount = config.vertexCount;
		if (vertexCount === 0) {
			return null;
		}

		var indexCount = 0;
		if (config.indexLengths) {
			indexCount = config.indexLengths.reduce(function (store, val) { return store + val; });
		} else if (config.indices) {
			indexCount = config.indices.wordLength;
		}

		var typeMatch = {
			'float32': 'Float',
			'uint8': 'UnsignedByte',
			'uint16': 'UnsignedShort',
			// Not yet supported
			'uint32': 'UnsignedInt'
		};

		if (BufferUtils.browserType === 'Trident') {
			typeMatch.uint8 = 'UnsignedShort';
		}

		var attributeMap = {};
		for (var key in config.attributes) {
			var map = config.attributes[key];
			var type = map.value[2];
			attributeMap[key] = MeshData.createAttribute(map.dimensions, typeMatch[type]);
		}

		var meshData = new MeshData(attributeMap, vertexCount, indexCount);
		meshData.type = skinned ? MeshData.SKINMESH : MeshData.MESH;
		return meshData;
	};

	/**
	 * Fills MeshData object from config
	 * @param {MeshData} meshData
	 * @param {Object} config
	 * @param {ArrayBuffer} bindata
	 * @returns {MeshData}
	 * @private
	 */
	MeshDataHandler.prototype._fillMeshData = function (meshData, config, bindata) {
		var skinned = meshData.type === MeshData.SKINMESH;

		for (var key in config.attributes) {
			if (key === 'JOINTIDS') {
				//Special handling later
				continue;
			}
			var data = config.attributes[key].value;
			meshData.getAttributeBuffer(key).set(ArrayUtils.getTypedArray(bindata, data));
		}

		/**Remapping the joints. This will enable us to have skeleton with hundreds of joints even
		 * though meshes can only have ~70
		 */
		if (skinned && config.attributes.JOINTIDS) {
			var buffer = meshData.getAttributeBuffer(MeshData.JOINTIDS);
			var jointData = ArrayUtils.getTypedArray(bindata, config.attributes.JOINTIDS.value);

			// Map skeleton joint index local joint index
			var localJointMap = [];

			var localIndex = 0;
			for (var idx = 0; idx < jointData.length; idx++) {
				var jointIndex = jointData[idx];
				if (localJointMap[jointIndex] === undefined) {
					// If vertex has joint index, add to localmap
					localJointMap[jointIndex] = localIndex++;
				}
				// Set vertex joint index to local index
				buffer.set([localJointMap[jointIndex]], idx);
			}
			// Make a reverse map from local joint to skeleton joint
			// We will use this later in animation shader code
			var localMap = [];
			for (var jointIndex = 0; jointIndex < localJointMap.length; jointIndex++) {
				var localIndex = localJointMap[jointIndex];
				if (localIndex !== null) {
					localMap[localIndex] = jointIndex;
				}
			}
			meshData.paletteMap = localMap;
			meshData.weightsPerVertex = WEIGHTS_PER_VERT;
		}

		meshData.getIndexBuffer().set(ArrayUtils.getTypedArray(bindata, config.indices));
		meshData.indexModes = config.indexModes.slice();
		meshData.indexLengths = config.indexLengths.slice();

		// TODO Put somewhere else
		if (config.boundingVolume) {
			if (config.boundingVolume.type === 'BoundingBox') {
				meshData.boundingBox = { min: config.boundingVolume.min, max: config.boundingVolume.max };
			} else {
				throw new Error('Bounding volume was not BoundingBox');
			}
		}

		if (!Capabilities.ElementIndexUInt && meshData.vertexCount > 65536) {
			meshData.deIndex();
		}

		return meshData;
	};

	return MeshDataHandler;

})(goo.ConfigHandler,goo.MeshData,goo.BufferUtils,goo.Capabilities,goo.PromiseUtils,goo.ArrayUtils);
goo.MeshRendererComponentHandler = (function (
	ComponentHandler,
	MeshRendererComponent,
	Material,
	ShaderLib,
	RSVP,
	pu,
	_
) {
	'use strict';

	/**
	 * For handling loading of meshrenderercomponents
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function MeshRendererComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'MeshRendererComponent';
	}

	MeshRendererComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	MeshRendererComponentHandler.prototype.constructor = MeshRendererComponentHandler;
	ComponentHandler._registerClass('meshRenderer', MeshRendererComponentHandler);

	MeshRendererComponentHandler.DEFAULT_MATERIAL = new Material(ShaderLib.uber, 'Default material');

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @returns {Object}
	 * @private
	 */
	MeshRendererComponentHandler.prototype._prepare = function (config) {
		return _.defaults(config, {
			cullMode: 'Dynamic',
			castShadows: true,
			receiveShadows: true,
			reflectable: true
		});
	};

	/**
	 * Create meshrenderer component.
	 * @returns {MeshRendererComponent} the created component object
	 * @private
	 */
	MeshRendererComponentHandler.prototype._create = function () {
		return new MeshRendererComponent();
	};

	/**
	 * Update engine meshrenderercomponent object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	 MeshRendererComponentHandler.prototype.update = function (entity, config, options) {
		var that = this;

		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }
			// Component settings
			component.cullMode = config.cullMode;
			component.castShadows = config.castShadows;
			component.receiveShadows = config.receiveShadows;
			component.isReflectable = config.reflectable;
			//component.isPickable = config.pickable;

			// Materials
			var materials = config.materials;
			if (!materials || !Object.keys(materials).length) {
				var selectionMaterial = component.materials.filter(function (material) {
					return material.name === 'gooSelectionIndicator';
				});
				component.materials = [MeshRendererComponentHandler.DEFAULT_MATERIAL].concat(selectionMaterial);
				return component;
			}

			var promises = [];
			_.forEach(materials, function (item) {
				promises.push(that._load(item.materialRef, options));
			}, null, 'sortValue');
			return RSVP.all(promises).then(function (materials) {
				var selectionMaterial = component.materials.filter(function (material) {
					return material.name === 'gooSelectionIndicator';
				});
				component.materials = materials.concat(selectionMaterial);
				return component;
			});
		});
	};

	return MeshRendererComponentHandler;
})(goo.ComponentHandler,goo.MeshRendererComponent,goo.Material,goo.ShaderLib,goo.rsvp,goo.PromiseUtils,goo.ObjectUtils);
goo.SceneHandler = (function (
	ConfigHandler,
	SystemBus,
	ArrayUtils,
	_,
	RSVP
) {
	'use strict';

	/**
	 * Handler for loading scene into engine
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function SceneHandler() {
		ConfigHandler.apply(this, arguments);
	}

	SceneHandler.prototype = Object.create(ConfigHandler.prototype);
	SceneHandler.prototype.constructor = SceneHandler;
	ConfigHandler._registerClass('scene', SceneHandler);

	/**
	 * Removes the scene, i e removes all entities in scene from engine world
	 * @param {ref}
	 */
	SceneHandler.prototype._remove = function (ref) {
		//Todo Clear engine
		var scene = this._objects.get(ref);
		if (scene) {
			for (var i = 0; i < scene.entities.length; i++) {
				scene.entities[i].removeFromWorld();
			}
		}
		// Remove posteffects
		// Remove environment

		this._objects.delete(ref);
	};

	/**
	 * Creates an empty scene which will hold some scene data
	 * @returns {Entity}
	 * @private
	 */
	SceneHandler.prototype._create = function () {
		return {
			id: null,
			entities: {},
			posteffects: [],
			environment: null,
			initialCameraRef: null
		};
	};

	/**
	 * Creates/updates/removes a scene
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated scene or null if removed
	 */
	SceneHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (scene) {
			if (!scene) { return; }
			scene.id = ref;
			var promises = [];
			promises.push(that._handleEntities(config, scene, options));
			if (config.posteffectsRef) {
				promises.push(that._load(config.posteffectsRef, options));
			}
			if (config.environmentRef) {
				promises.push(that._load(config.environmentRef, options));
			}
			if (!options.scene || !options.scene.dontSetCamera) {
				if (config.initialCameraRef && config.initialCameraRef !== scene.initialCameraRef) {
					promises.push(that._load(config.initialCameraRef, options).then(function (cameraEntity) {
						if (cameraEntity && cameraEntity.cameraComponent) {
							SystemBus.emit('goo.setCurrentCamera', {
								camera: cameraEntity.cameraComponent.camera,
								entity: cameraEntity
							});
						}
						scene.initialCameraRef = config.initialCameraRef;
					}));
				}
			}
			return RSVP.all(promises).then(function () {
				return scene;
			});
		});
	};

	/**
	 * Adding and removing entities to the engine and thereby the scene
	 * @param {Object} config
	 * @param {Object} scene
	 * @param {Object} options
	 */
	SceneHandler.prototype._handleEntities = function (config, scene, options) {
		var that = this;
		var promises = [];

		var addedEntityIds = _.clone(config.entities);
		var removedEntityIds = [];

		for (var id in scene.entities) {
			//var engineEntity = scene.entities[id];
			if (addedEntityIds[id]) {
				delete addedEntityIds[id];
			}
			else {
				removedEntityIds[id] = id;
			}
		}

		_.forEach(config.entities, function (entityConfig) {
			promises.push(that._load(entityConfig.entityRef, options));
		}, null, 'sortValue');

		return RSVP.all(promises).then(function (entities) {
			// Adding new entities
			for (var i = 0; i < entities.length; i++) {
				var entity = entities[i];
				if (addedEntityIds[entity.id]) {
					entity.addToWorld();
				}

				// readding back entities removed by the scripts/fsm
				if (!addedEntityIds[entity.id] &&
					!removedEntityIds[entity.id] &&
					!entity._world.entityManager.containsEntity(entity)) {
					entity.addToWorld();
				}

				scene.entities[entity.id] = entity;
			}

			// Removing old entities from the handler cache
			// Removing them from the world is handled by the EntityHandler
			for (var id in removedEntityIds) {
				delete scene.entities[id];
			}
		});
	};

	/**
	 * Handling posteffects
	 * @param {Object} config
	 * @param {Object} scene
	 * @param {Object} options
	 */
	SceneHandler.prototype._handlePosteffects = function (config, scene, options) {
		return this._load(config.posteffectsRef, options);
	};

	/**
	 * Handling environment, to be implemented
	 * @param {Object} config
	 * @param {Object} scene
	 * @param {Object} options
	 */
	SceneHandler.prototype._handleEnvironment = function (config, scene, options) {
		return this._load(config.environmentRef, options);
	};

	return SceneHandler;
})(goo.ConfigHandler,goo.SystemBus,goo.ArrayUtils,goo.ObjectUtils,goo.rsvp);
goo.ShaderHandler = (function (
	ConfigHandler,
	Material,
	MeshData,
	Shader,
	ShaderBuilder,
	RSVP,
	PromiseUtils
) {
	'use strict';

	/**
	 * Handler for loading shaders into engine
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function ShaderHandler() {
		ConfigHandler.apply(this, arguments);
	}

	ShaderHandler.prototype = Object.create(ConfigHandler.prototype);
	ShaderHandler.prototype.constructor = ShaderHandler;
	ConfigHandler._registerClass('shader', ShaderHandler);

	/**
	 * Removes a shader
	 * @param {ref}
	 * @private
	 */
	ShaderHandler.prototype._remove = function (ref) {
		var shader = this._objects.get(ref);
		if (shader && this.world.gooRunner) {
			shader.destroy(this.world.gooRunner.renderer.context);
			this._objects.delete(ref);
		}
	};

	/**
	 * Adds/updates/removes a shader
	 * Currently it is not possible to update a shader, so we create a new one every time
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated shader or null if removed
	 */
	ShaderHandler.prototype._update = function (ref, config, options) {
		if (!config) {
			this._remove(ref);
			return PromiseUtils.resolve();
		}
		if (!config.vshaderRef) {
			return PromiseUtils.reject('Shader error, missing vertex shader ref');
		}
		if (!config.fshaderRef) {
			return PromiseUtils.reject('Shader error, missing fragment shader ref');
		}

		var promises = [
			this.loadObject(config.vshaderRef, options),
			this.loadObject(config.fshaderRef, options)
		];

		return RSVP.all(promises).then(function (shaders) {
			var vshader = shaders[0];
			var fshader = shaders[1];

			if (!vshader) {
				return PromiseUtils.reject('Vertex shader' + config.vshaderRef + 'in shader' + ref + 'not found');
			}
			if (!fshader) {
				return PromiseUtils.reject('Fragment shader' + config.fshaderRef + 'in shader' + ref + 'not found');
			}

			var shaderDefinition = {
				defines: config.defines || {},
				attributes: config.attributes || {},
				uniforms: config.uniforms || {},
				vshader: vshader,
				fshader: fshader
			};

			if (config.processors) {
				shaderDefinition.processors = [];
				for (var i = 0; i < config.processors.length; i++) {
					var processor = config.processors[i];
					if (ShaderBuilder[processor]) {
						shaderDefinition.processors.push(ShaderBuilder[processor].processor);
					} else {
						console.error('Unknown processor ' + processor);
					}
				}
			}

			var shader = Material.createShader(shaderDefinition, ref);

			this._objects.set(ref, shader);

			return shader;
		}.bind(this));
	};

	return ShaderHandler;
})(goo.ConfigHandler,goo.Material,goo.MeshData,goo.Shader,goo.ShaderBuilder,goo.rsvp,goo.PromiseUtils);
goo.TransformComponentHandler = (function (
	ComponentHandler,
	TransformComponent,
	MathUtils,
	_,
	RSVP
) {
	'use strict';

	/**
	 * For handling loading of transform component
	 * @extends ComponentHandler
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @hidden
	 */
	function TransformComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'TransformComponent';
	}

	TransformComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	TransformComponentHandler.prototype.constructor = TransformComponentHandler;
	ComponentHandler._registerClass('transform', TransformComponentHandler);

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @private
	 */
	TransformComponentHandler.prototype._prepare = function (config) {
		return _.defaults(config, {
			translation: [0, 0, 0],
			rotation: [0, 0, 0],
			scale: [1, 1, 1]
		});
	};

	/**
	 * Create transform component object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @returns {TransformComponent} the created component object
	 * @private
	 */
	TransformComponentHandler.prototype._create = function () {
		return new TransformComponent();
	};

	/**
	 * Remove engine component object. TransformComponents can't be removed, so we reset.
	 * @param {Entity} entity The entity from which this component should be removed.
	 * @private
	 */
	TransformComponentHandler.prototype._remove = function (entity) {
		var component = entity.transformComponent;
		// Reset
		component.transform.translation.setDirect(0, 0, 0);
		component.transform.setRotationXYZ(0, 0, 0);
		component.transform.scale.setDirect(1, 1, 1);

		// Detach all children
		for (var i = 0; i < component.children.length; i++) {
			var child = component.children[i];
			component.detachChild(child);
		}
		component.setUpdated();
	};

	/**
	 * Update engine transform component object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	TransformComponentHandler.prototype.update = function (entity, config, options) {
		var that = this;

		function attachChild(component, ref) {
			return that.loadObject(ref, options).then(function (entity) {
				if (entity && entity.transformComponent) {
					component.attachChild(entity.transformComponent);
					var entityInWorld = that.world.entityManager.containsEntity(entity) ||
						that.world._addedEntities.indexOf(entity) !== -1; //! AT: most probably not needed anymore
						// entities are added synchronously to the managers
					var parentInWorld = that.world.entityManager.containsEntity(component.entity) ||
						that.world._addedEntities.indexOf(component.entity) > -1; //! AT: most probably not needed anymore
					// also, why the inconsistency: "!== -1" vs "> -1" ?

					if (!entityInWorld && parentInWorld) {
						entity.addToWorld();
					}
				} else {
					console.error('Failed to add child to transform component');
				}
				return component;
			});
		}

		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) {
				// Component was removed
				return;
			}

			// Translation
			component.transform.translation.setDirect(config.translation[0], config.translation[1], config.translation[2]);
			// Rotation
			component.transform.setRotationXYZ(
				MathUtils.DEG_TO_RAD * config.rotation[0],
				MathUtils.DEG_TO_RAD * config.rotation[1],
				MathUtils.DEG_TO_RAD * config.rotation[2]
			);
			// Scale
			component.transform.scale.setDirect(config.scale[0], config.scale[1], config.scale[2]);

			var promises = [];
			if (config.children) {
				// Attach children
				// TODO: Watch out for circular dependencies
				// TODO: Use sort values
				var keys = Object.keys(config.children);
				for (var i = 0; i < keys.length; i++) {
					var childRef = config.children[keys[i]].entityRef;
					promises.push(attachChild(component, childRef));
				}
				for (var i = 0; i < component.children.length; i++) {
					var child = component.children[i];
					var id = child.entity.id;
					if (!config.children[id]) {
						component.detachChild(child);
					}
				}
			} else {
				// Detach all children
				for (var i = 0; i < component.children.length; i++) {
					var child = component.children[i];
					component.detachChild(child);
				}
			}

			// When all children are attached, return component
			return RSVP.all(promises).then(function () {
				component.setUpdated();
				return component;
			});
		});
	};

	return TransformComponentHandler;
})(goo.ComponentHandler,goo.TransformComponent,goo.MathUtils,goo.ObjectUtils,goo.rsvp);
goo.ProjectHandler = (function (
	ConfigHandler
) {
	'use strict';

	/*jshint eqeqeq: false, -W041 */
	/**
	 * Handler for loading project into engine (actually loading mainScene)
	 * @private
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 */
	function ProjectHandler() {
		ConfigHandler.apply(this, arguments);
		/**
		this._skybox = null;
		this._skyboxTexture = null;
		this._skyboxGeographic = false;

		this._composer = null;
		this._passes = [];
		this.weatherState = {};
		*/
	}

	ProjectHandler.prototype = Object.create(ConfigHandler.prototype);
	ProjectHandler.prototype.constructor = ProjectHandler;
	ConfigHandler._registerClass('project', ProjectHandler);

	/**
	 * Removes project from engine, i e removes mainScene, i e removes scene entities from world
	 * @param {string} ref}
	 * @param {Object} options
	 */
	ProjectHandler.prototype._remove = function (ref, options) {
		var project = this._objects.get(ref);
		if (project) {
			this.updateObject(project.mainScene.id, null, options);
		}
	};

	/**
	 * Creates an empty project object
	 * @returns {Object}
	 * @private
	 */
	ProjectHandler.prototype._create = function () {
		return {
			mainScene: null
		};
	};

	/**
	 * Creates/updates/removes a project
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated scene or null if removed
	 */
	ProjectHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (project) {
			if (!project) { return; }
			function loadPromise() {
				return that._load(config.mainSceneRef, options).then(function (scene) {
					project.mainScene = scene;
					return project;
				});
			}

			if (project.mainScene && config.mainSceneRef !== project.mainScene.id) {
				return that.updateObject(project.mainScene.id, null, options).then(loadPromise);
			} else {
				return loadPromise();
			}
		});
	};

	return ProjectHandler;
})(goo.ConfigHandler);
goo.SoundComponentHandler = (function (
	ComponentHandler,
	SoundComponent,
	AudioContext,
	RSVP,
	PromiseUtils,
	_
) {
	'use strict';

	/**
	 * For handling loading of sound components
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function SoundComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'SoundComponent';
	}

	SoundComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	SoundComponentHandler.prototype.constructor = SoundComponentHandler;
	ComponentHandler._registerClass('sound', SoundComponentHandler);

	/**
	 * Removes the souncomponent and stops all connected sounds
	 * @param {Entity} entity
	 * @private
	 */
	SoundComponentHandler.prototype._remove = function (entity) {
		var component = entity.soundComponent;
		if (component && component.sounds) {
			var sounds = component.sounds;
			for (var i = 0; i < sounds.length; i++) {
				sounds[i].stop();
			}
		}
	};

	/**
	 * Prepares the config
	 * @param {Object} config
	 */
	SoundComponentHandler.prototype._prepare = function (config) {
		_.defaults(config, {
			volume: 1.0,
			reverb: 0.0
		});
	};

	/**
	 * Creates sound component
	 * @returns {SoundComponent} Should be soundcomponent
	 * @private
	 */
	SoundComponentHandler.prototype._create = function () {
		return new SoundComponent();
	};

	/**
	 * Update engine sound component object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	SoundComponentHandler.prototype.update = function (entity, config, options) {
		if (!AudioContext.isSupported()) {
			return PromiseUtils.resolve(); //! AT: we're not really using reject
		}

		var that = this;
		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }
			component.updateConfig(config);

			// Remove old sounds
			for (var i = 0; i < component.sounds.length; i++) {
				var sound = component.sounds[i];
				if (!config.sounds[sound.id]) {
					component.removeSound(sound);
				}
			}

			var promises = [];
			// Load all sounds
			_.forEach(config.sounds, function (soundCfg) {
				promises.push(that._load(soundCfg.soundRef, options));
			}, null, 'sortValue');

			return RSVP.all(promises).then(function (sounds) {
				// Add new sounds
				for (var i = 0; i < sounds.length; i++) {
					if (component.sounds.indexOf(sounds[i]) === -1) {
						component.addSound(sounds[i]);
					}
				}
				return component;
			});
		});
	};

	return SoundComponentHandler;
})(goo.ComponentHandler,goo.SoundComponent,goo.AudioContext,goo.rsvp,goo.PromiseUtils,goo.ObjectUtils);
goo.PromiseUtil = (function (PromiseUtils) {

	/**
	 * Promise-related utilities
	 * @target-class PromiseUtil PromiseUtil constructor
	 * @require-path goo/util/PromiseUtil
	 * @group util
	 * @deprecated Deprecated as of 0.14.x and scheduled for removal in 0.16.0; The class has been renamed to `goo/util/PromiseUtils`
	 */
	return PromiseUtils;
})(goo.PromiseUtils);
goo.Sound = (function (
	AudioContext,
	MathUtils,
	PromiseUtil,
	RSVP
) {
	'use strict';

	/**
	 * A representation of a sound in the engine
	 */
	function Sound() {
		/** @type {string}
		 */
		this.id = null;
		/** @type {string}
		 */
		this.name = null;
		this._loop = false;
		this._rate = 1.0;
		this._offset = 0;
		this._duration = null;
		this._volume = 1.0;

		// Nodes
		this._buffer = null;
		this._stream = null;
		this._streamSource = null;
		this._currentSource = null;
		this._outNode = AudioContext.getContext().createGain();
		this.connectTo();

 			// Playback memory
		this._playStart = 0;
		this._pausePos = 0;
		//this._endTimer = null;
		this._endPromise = null;

		this._paused = false;

		/**
		 * @type {boolean}
		 * @readonly
		 */
		this.spatialize = true;

		/**
		 * If true, it will start playing when the SoundSystem runs play().
		 * @type {boolean}
		 * @readonly
		 */
		this.autoPlay = false;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	/**
	 * Plays the sound if it's not playing
	 * @param {number} when Time in seconds according to [AudioContext.currentTime]{@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/currentTime} when sound should start to play.
	 * @returns {RSVP.Promise} Resolves when sound has played through or when it's stopped.
	 * Looping sounds will never resolve
	 */
	Sound.prototype.play = function (when) {
		when = when || 0;
		if (this._currentSource) {
			return this._endPromise;
		}
		this._endPromise = new RSVP.Promise(); //! AT: this needs refactoring
		if (!this._buffer || this._stream) {
			return this._endPromise;
		}

		var currentSource = this._currentSource = AudioContext.getContext().createBufferSource();

		this._paused = false;
		this._currentSource.onended = function () {
			if (this._currentSource === currentSource && !this._paused) {
				this.stop();
			}
		}.bind(this);

		this._currentSource.playbackRate.value = this._rate;
		this._currentSource.connect(this._outNode);
		this._currentSource.buffer = this._buffer;
		this._currentSource.loop = this._loop;
		if (this._loop) {
			this._currentSource.loopStart = this._offset;
			this._currentSource.loopEnd = this._duration + this._offset;
		}

		this._playStart = AudioContext.getContext().currentTime - this._pausePos;
		var duration = this._duration - this._pausePos;

		if (this._loop) {
			this._currentSource.start(when, this._pausePos + this._offset);
		} else {
			this._currentSource.start(when, this._pausePos + this._offset, duration);
		}

		return this._endPromise;
	};

	/**
	 * Pauses the sound if it's playing
	 */
	Sound.prototype.pause = function () {
		if (!this._currentSource) {
			return;
		}

		this._paused = true;

		this._pausePos = (AudioContext.getContext().currentTime - this._playStart) % this._duration;
		this._pausePos /= this._rate;
		this._stop();
	};

	/**
	 * Stops the sound if it's playing
	 * @param {number} when Time in seconds according to [AudioContext.currentTime]{@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/currentTime} when sound should stop.
	 */
	Sound.prototype.stop = function (when) {
		this._paused = false;
		this._pausePos = 0;
		if (this._endPromise) {
			this._endPromise.resolve();
		}
		if (this._currentSource) {
			this._stop(when);
		}
	};

	Sound.prototype.fadeIn = function (time) {
		this.stop();
		var volume = this._volume;
		this._outNode.gain.value = 0;
		var p = this.fade(volume, time);
		this.play();
		return p;
	};

	Sound.prototype.fadeOut = function (time) {
		return this.fade(0, time);
	};

	Sound.prototype.fade = function (volume, time) {
		this._outNode.gain.setValueAtTime(this._outNode.gain.value, AudioContext.getContext().currentTime);
		this._outNode.gain.linearRampToValueAtTime(volume, AudioContext.getContext().currentTime + time);
		return PromiseUtil.delay(time * 1000);
	};

	Sound.prototype.isPlaying = function () {
		return !!this._currentSource;
	};

	/**
	 * Does the actual stopping of the sound
	 * @param {number} when Time in seconds according to [AudioContext.currentTime]{@link https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/currentTime} when sound should stop.
	 * @private
	 */
	Sound.prototype._stop = function (when) {
		when = when || 0;
		this._currentSource.stop(when);
		this._currentSource = null;
	};

	/**
	 * Updates the sound according to config
	 * @param {Object} [config]
	 * @param {boolean} [config.loop]
	 * @param {number} [config.volume]
	 * @param {number} [config.name] The sound name
	 * @param {number} [config.start] Start offset in seconds.
	 * Will be clamped to be in actual soundclip duration
	 * @param {number} [config.duration] Duration of the sound.
	 * Will be clamped to be in actual soundclip duration
	 * @param {number} [config.timeScale] Playback rate of the sound
	 */
	Sound.prototype.update = function (config) {
		config = config || {};
		if (config.id !== undefined) {
			this.id = config.id;
		}
		if (config.name !== undefined) {
			this.name = config.name;
		}
		if (config.loop !== undefined) {
			this._loop = !!config.loop;
			if (this._currentSource) {
				this._currentSource.loop = this._loop;
			}
		}
		if (config.volume !== undefined) {
			this._volume = MathUtils.clamp(config.volume, 0, 1);
			this._outNode.gain.value = this._volume;
		}
		if (config.offset !== undefined) {
			this._offset = config.offset;
		}
		if (config.duration !== undefined) {
			this._duration = config.duration;
		}
		if (config.timeScale !== undefined) {
			this._rate = config.timeScale;
			//! AT: should have the same name if they are the same thing
			// problem is that there are plenty of projects out there that have timeScale instead of rate
			// timeScale was considered because it's the same as for animations
			// rate would have been preferred to timeScale as it's the term used by WebAudio
			if (this._currentSource) {
				this._currentSource.playbackRate.value = config.timeScale;
			}
		}
		if (config.spatialize !== undefined) {
			this.spatialize = config.spatialize;
		}
		if (config.autoPlay !== undefined) {
			this.autoPlay = config.autoPlay;
		}
		if (this._buffer) {
			this._clampInterval();
		}
	};

	/**
	 * Clamps the start offset and duration to be in sound range
	 * @private
	 */
	Sound.prototype._clampInterval = function () {
		this._offset = Math.min(this._offset, this._buffer.duration);
		if (this._duration !== null) {
			this._duration = Math.min(this._buffer.duration - this._offset, this._duration);
		} else {
			this._duration = this._buffer.duration - this._offset;
		}
		this._pausePos = MathUtils.clamp(this._pausePos, 0, this._duration);
	};

	/**
	 * Connect output of sound to audionodes
	 * @param {(Array<AudioNode> | AudioNode)} nodes
	 */
	Sound.prototype.connectTo = function (nodes) {
		if (!nodes) {
			return;
		}
		if (!(nodes instanceof Array)) {
			nodes = [nodes];
		}
		for (var i = 0; i < nodes.length; i++) {
			this._outNode.connect(nodes[i]);
		}
	};

	/**
	 * Disconnect output of sound from audionodes
	 * @param {(Array<AudioNode>|AudioNode)} nodes
	 */
	Sound.prototype.disconnectFrom = function (nodes) {
		if (!nodes) {
			return;
		}
		if (!(nodes instanceof Array)) {
			nodes = [nodes];
		}
		for (var i = 0; i < nodes.length; i++) {
			this._outNode.disconnect(nodes[i]);
		}
	};

	/**
	 * Sets the audio buffer which will be the sound source
	 * @param {AudioBuffer} buffer
	 */
	Sound.prototype.setAudioBuffer = function (buffer) {
		this.setAudioStream(null);
		this._buffer = buffer;
		this._clampInterval();
	};

	Sound.prototype.setAudioStream = function (stream) {
		if (!stream) {
			if (this._streamSource) {
				this._streamSource.disconnect();
				this._streamSource = null;
			}
			return;
		}
		this.stop();
		this._stream = stream;
		this._streamSource = AudioContext.getContext().createMediaStreamSource(stream);
		this._streamSource.connect(this._outNode);
	};

	return Sound;
})(goo.AudioContext,goo.MathUtils,goo.PromiseUtil,goo.rsvp);
goo.SoundHandler = (function (
	ConfigHandler,
	AudioContext,
	Sound,
	RSVP,
	PromiseUtils,
	_
) {
	'use strict';
	/**
	 * Handler for loading sounds into engine
	 * @extends ConfigHandler
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function SoundHandler() {
		ConfigHandler.apply(this, arguments);
		this._audioCache = {};

		if (window.Audio !== undefined) {
			var audioTest = new Audio();

			this._codecs = [
				{
					type: 'mp3',
					enabled: !!audioTest.canPlayType('audio/mpeg;')
				}, {
					type: 'ogg',
					enabled: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"')
				}, {
					type: 'wav',
					enabled: !!audioTest.canPlayType('audio/wav; codecs="1"')
				}
			];
		} else {
			this._codecs = [];
		}
	}

	SoundHandler.prototype = Object.create(ConfigHandler.prototype);
	SoundHandler.prototype.constructor = SoundHandler;
	ConfigHandler._registerClass('sound', SoundHandler);

	/**
	 * Removes a sound
	 * @param {ref}
	 * @private
	 */
	SoundHandler.prototype._remove = function (ref) {
		var sound = this._objects.get(ref);
		if (!sound) { return; }

		sound.stop();
		this._objects.delete(ref);
	};

	/**
	 * Preparing sound config by populating it with defaults.
	 * @param {Object} config
	 * @private
	 */
	SoundHandler.prototype._prepare = function (config) {
		_.defaults(config, {
			loop: false,
			audioRefs: {},
			volume: 1.0,
			spatialize: false,
			autoPlay: false,
			name: 'A Sound'
		});
	};

	/**
	 * Creates an empty sound.
	 * @returns {Howl}
	 * @private
	 */
	SoundHandler.prototype._create = function () {
		return new Sound();
	};

	/**
	 * Adds/updates/removes a sound
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated sound or null if removed
	 */
	SoundHandler.prototype._update = function (ref, config, options) {
		if (!AudioContext.isSupported()) {
			return PromiseUtils.resolve();
		}
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (sound) {
			if (!sound) { return; }
			sound.update(config);
			for (var i = 0; i < that._codecs.length; i++) {
				var codec = that._codecs[i];
				var ref = config.audioRefs[codec.type];

				if (ref && codec.enabled) {
					if (that._audioCache[ref]) {
						sound.setAudioBuffer(that._audioCache[ref]);
						return sound;
					} else {
						/*jshint -W083 */
						return that.loadObject(ref).then(function (buffer) {
							return PromiseUtils.createPromise(function (resolve, reject) {
								AudioContext.getContext().decodeAudioData(buffer, function (audioBuffer) {
									resolve(audioBuffer);
								}, function (/*err*/) {
									console.error('Could not decode audio ' + ref);
									// shouldn't this just reject?
									resolve(null);
								});
							});
						}).then(function (audioBuffer) {
							if (audioBuffer) {
								that._audioCache[ref] = audioBuffer;
								sound.setAudioBuffer(audioBuffer);
							}
							return sound;
						});
					}
				}
			}
			console.warn('No supported audioformat was found');
			return sound;
		});
	};

	return SoundHandler;
})(goo.ConfigHandler,goo.AudioContext,goo.Sound,goo.rsvp,goo.PromiseUtils,goo.ObjectUtils);
goo.ParticleLib = (function () {
	'use strict';

	/**
	 * Library of particles
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/misc/ParticleLib/ParticleLib-vtest.html Working example
	 */
	function ParticleLib() {}

	/**
	 * Returns a set of parameters for a smoke particle emitter
	 */
	ParticleLib.getSmoke = function (options) {
		options = options || {};
		options.scale = typeof options.scale !== 'undefined' ? options.scale : 1;
		options.spread = typeof options.spread !== 'undefined' ? options.spread : 2;
		options.rate = typeof options.spread !== 'undefined' ? options.rate : 25;
		options.velocity = typeof options.velocity !== 'undefined' ? options.velocity :
			function (particle/*, particleEntity*/) {
				// not nice, will end up a square
				var vec3 = particle.velocity;
				vec3.x = (Math.random() - 0.5) * 2 * options.spread * options.scale;
				vec3.y = (Math.random() + 4.0) * 2 * options.scale;
				vec3.z = (Math.random() - 0.5) * 2 * options.spread * options.scale;
				return vec3;
			};
		options.color = options.color || [0, 0, 0];

		return {
			totalParticlesToSpawn: -1,
			releaseRatePerSecond: options.rate,
			minLifetime: 0.5,
			maxLifetime: 4.0,
			getEmissionVelocity: options.velocity,
			timeline: [{
				timeOffset: 0.0,
				spin: 0,
				mass: 1,
				size: 3.0 * options.scale,
				color: [options.color[0], options.color[1], options.color[2], 1]
			}, {
				timeOffset: 1.0,
				size: 6.0 * options.scale,
				color: [options.color[0], options.color[1], options.color[2], 0]
			}]
		};
	};

	/**
	 * Returns a set of parameters for a fire particle emitter
	 */
	ParticleLib.getFire = function (options) {
		options = options || {};
		options.scale = typeof options.scale !== 'undefined' ? options.scale : 1;
		options.spread = typeof options.spread !== 'undefined' ? options.spread : 2;
		options.velocity = typeof options.velocity !== 'undefined' ? options.velocity : 10;
		options.startColor = options.startColor || [1, 1, 0];
		options.endColor = options.endColor || [1, 0, 0];

		return {
			totalParticlesToSpawn: -1,
			releaseRatePerSecond: 30,
			minLifetime: 0.5,
			maxLifetime: 2.0,
			getEmissionVelocity: function (particle/*, particleEntity*/) {
				// not nice, will end up a square
				var vec3 = particle.velocity;
				vec3.x = (Math.random() - 0.5) * 2 * options.spread * options.scale;
				vec3.y = (Math.random() + 1.0) * options.velocity * options.scale;
				vec3.z = (Math.random() - 0.5) * 2 * options.spread * options.scale;
				return vec3;
			},
			timeline: [{
				timeOffset: 0.0,
				spin: 0,
				mass: 1,
				size: 2.0 * options.scale,
				color: [options.startColor[0], options.startColor[1], options.startColor[2], 0]
			}, {
				timeOffset: 0.05,
				color: [options.startColor[0], options.startColor[1], options.startColor[2], 1.0]
			}, {
				timeOffset: 0.45,
				color: [options.endColor[0], options.endColor[1], options.endColor[2], 0.8]
			}, {
				timeOffset: 0.5,
				size: 3.0 * options.scale,
				color: [0, 0, 0, 0]
			}]
		};
	};

	/**
	 * Returns a set of parameters for a snow particle emitter
	 */
	ParticleLib.getSnow = function (options) {
		options = options || {};
		options.scale = typeof options.scale !== 'undefined' ? options.scale : 2;
		options.spread = typeof options.spread !== 'undefined' ? options.spread : 50;
		options.velocity = typeof options.velocity !== 'undefined' ? options.velocity : 3;
		options.color = options.color || [1, 1, 1];

		return {
			particleCount: 1000,
			totalParticlesToSpawn: -1,
			releaseRatePerSecond: 50,
			minLifetime: 15.0,
			maxLifetime: 25.0,
			getEmissionPoint: function (particle/*, particleEntity*/) {
				var vec3 = particle.position;
				options.getEmissionPoint(vec3);
				return vec3;
			},
			getEmissionVelocity: function (particle/*, particleEntity*/) {
				var vec3 = particle.velocity;
				options.getEmissionVelocity(vec3);
				return vec3;
			},
			timeline: [{
				timeOffset: 0.0,
				spin: 0,
				mass: 1,
				size: 1.0 * options.scale,
				color: [options.color[0], options.color[1], options.color[2], 0.0]
			}, {
				timeOffset: 0.05,
				color: [options.color[0], options.color[1], options.color[2], 1.0]
			}, {
				timeOffset: 0.70,
				color: [options.color[0], options.color[1], options.color[2], 0.8]
			}, {
				timeOffset: 0.25,
				spin: 5,
				size: 0.5 * options.scale,
				color: [options.color[0], options.color[1], options.color[2], 0]
			}]
		};
	};

	return ParticleLib;
})();
goo.ParticleUtils = (function (
	Vector3
) {
	'use strict';

	/**
	 * Various helper utils for particle systems.
	 */
	function ParticleUtils() {}

	ParticleUtils.getRandomVelocityOffY = function (store, minOffsetAngle, maxOffsetAngle, scale, particleEntity) {
		var randomAngle = minOffsetAngle + Math.random() * (maxOffsetAngle - minOffsetAngle);
		var randomDir = Math.PI * 2 * Math.random();

		store.x = Math.cos(randomDir) * Math.sin(randomAngle);
		store.y = Math.cos(randomAngle);
		store.z = Math.sin(randomDir) * Math.sin(randomAngle);

		if (particleEntity) {
			ParticleUtils.applyEntityTransformVector(store, particleEntity);
		}

		store.scale(scale);
		return store;
	};

	ParticleUtils.randomPointInCube = function (store, xRadius, yRadius, zRadius, center) {
		store.x = Math.random() * 2 * xRadius - xRadius + (center ? center.x : 0);
		store.y = Math.random() * 2 * yRadius - yRadius + (center ? center.y : 0);
		store.z = Math.random() * 2 * zRadius - zRadius + (center ? center.z : 0);
		return store;
	};

	ParticleUtils.createConstantForce = function (force) {
		var applyForce = new Vector3(force);
		return {
			enabled: true,
			/* Was: function (particleEntity, emitter) */
			prepare: function () {},
			/* Was: function (tpf, particle, particleIndex) */
			apply: function (tpf, particle) {
				particle.velocity.x += applyForce.x * tpf;
				particle.velocity.y += applyForce.y * tpf;
				particle.velocity.z += applyForce.z * tpf;
			}
		};
	};

	ParticleUtils.applyEntityTransformPoint = function (vec3, entity) {
		if (!entity.transformComponent || !entity.transformComponent.worldTransform) {
			return vec3;
		}

		return entity.transformComponent.worldTransform.applyForward(vec3, vec3);
	};

	ParticleUtils.applyEntityTransformVector = function (vec3, entity) {
		if (!entity.transformComponent || !entity.transformComponent.worldTransform) {
			return vec3;
		}

		return entity.transformComponent.worldTransform.applyForwardVector(vec3, vec3);
	};

	ParticleUtils.applyTimeline = function (particle, timeline) {
		var age = particle.age, lifeSpan = particle.lifeSpan;
		var prevCAge = 0, prevMAge = 0, prevSiAge = 0, prevSpAge = 0;
		var nextCAge = lifeSpan, nextMAge = lifeSpan, nextSiAge = lifeSpan, nextSpAge = lifeSpan;
		var trAge = 0, ratio;
		var prevCEntry = null, prevMEntry = null, prevSiEntry = null, prevSpEntry = null, prevUVEntry = null;
		var nextCEntry = null, nextMEntry = null, nextSiEntry = null, nextSpEntry = null;

		for (var i = 0, max = timeline.length; i < max; i++) {
			var entry = timeline[i];
			trAge += (entry.timeOffset ? entry.timeOffset : 0.0) * lifeSpan;
			// Color
			if (nextCEntry === null && entry.color !== undefined) {
				if (trAge > age) {
					nextCAge = trAge;
					nextCEntry = entry;
				} else {
					prevCAge = trAge;
					prevCEntry = entry;
				}
			}

			// mass
			if (nextMEntry === null && entry.mass !== undefined) {
				if (trAge > age) {
					nextMAge = trAge;
					nextMEntry = entry;
				} else {
					prevMAge = trAge;
					prevMEntry = entry;
				}
			}

			// uvIndex
			if (trAge <= age && entry.uvIndex !== undefined) {
				prevUVEntry = entry;
			}

			// size
			if (nextSiEntry === null && entry.size !== undefined) {
				if (trAge > age) {
					nextSiAge = trAge;
					nextSiEntry = entry;
				} else {
					prevSiAge = trAge;
					prevSiEntry = entry;
				}
			}

			// spin
			if (nextSpEntry === null && entry.spin !== undefined) {
				if (trAge > age) {
					nextSpAge = trAge;
					nextSpEntry = entry;
				} else {
					prevSpAge = trAge;
					prevSpEntry = entry;
				}
			}
		}

		// color
		ratio = (age - prevCAge) / (nextCAge - prevCAge);
		var start = prevCEntry !== null ? prevCEntry.color : [1, 1, 1, 1];
		var end = nextCEntry !== null ? nextCEntry.color : start;
		particle.color.x = (1.0 - ratio) * start[0] + ratio * end[0];
		particle.color.y = (1.0 - ratio) * start[1] + ratio * end[1];
		particle.color.z = (1.0 - ratio) * start[2] + ratio * end[2];
		particle.color.w = (1.0 - ratio) * start[3] + ratio * end[3];

		// mass
		ratio = (age - prevMAge) / (nextMAge - prevMAge);
		var start = prevMEntry !== null ? prevMEntry.mass : 1.0;
		var end = nextMEntry !== null ? nextMEntry.mass : start;
		particle.mass = (1 - ratio) * start + ratio * end;

		// uvIndex
		particle.uvIndex = prevUVEntry !== null ? prevUVEntry.uvIndex : 0;

		// Size
		ratio = (age - prevSiAge) / (nextSiAge - prevSiAge);
		var start = prevSiEntry !== null ? prevSiEntry.size : 1.0;
		var end = nextSiEntry !== null ? nextSiEntry.size : start;
		particle.size = (1 - ratio) * start + ratio * end;

		// Spin
		ratio = (age - prevSpAge) / (nextSpAge - prevSpAge);
		var start = prevSpEntry !== null ? prevSpEntry.spin : 0.0;
		var end = nextSpEntry !== null ? nextSpEntry.spin : start;
		particle.spin = (1 - ratio) * start + ratio * end;
	};

	return ParticleUtils;
})(goo.Vector3);
goo.Particle = (function (
	ParticleUtils,
	Vector,
	Vector3,
	Vector4,
	MeshData
) {
	'use strict';

	var calcVec = new Vector3();

	/**
	 * Data object tracking a single particle in a particle component
	 */
	function Particle(particleComponent, index) {
		this.alive = false;
		this.position = new Vector3();
		this.velocity = new Vector3();
		this.lifeSpan = 0;
		this.parent = particleComponent;
		this.age = 0;
		this.index = index;
		this.color = new Vector4(1, 0, 0, 1);
		this.size = 0.0;
		this.spin = 0.0;
		this.mass = 1.0;
		this.emitter = null;
		this.uvIndex = 0;
		this.lastUVIndex = -1;
		this.bbX = new Vector3();
		this.bbY = new Vector3();
		this.lastColor = new Vector4();
	}

	/**
	 * Called by the particle system to 'respawn' this particle
	 * @private
	 * @param emitter
	 */
	Particle.prototype.respawnParticle = function (emitter) {
		this.emitter = emitter;
		this.lifeSpan = emitter.nextParticleLifeSpan();
		this.alive = true;
		this.age = 0;
	};

	var tmpArray = [];

	/**
	 * Called by the particle system each frame to update the position and other properties of the particle
	 * @private
	 * @param tpf
	 * @param particleEntity
	 */
	Particle.prototype.update = function (tpf, particleEntity) {
		if (!this.alive) {
			return;
		}

		this.age += tpf;

		if (this.age > this.lifeSpan) {
			this.kill();
			return;
		}

		this.position.addDirect(this.velocity.x * tpf, this.velocity.y * tpf, this.velocity.z * tpf);

		// set values from component timeline
		ParticleUtils.applyTimeline(this, this.emitter && this.emitter.timeline ? this.emitter.timeline : this.parent.timeline);

		// apply current color to mesh
		if (!this.lastColor.equals(this.color)) {
			var colorBuffer = this.parent.meshData.getAttributeBuffer(MeshData.COLOR);

			var offset = this.index * 16;

			colorBuffer[offset + 0 + 0] = this.color.r;
			colorBuffer[offset + 0 + 1] = this.color.g;
			colorBuffer[offset + 0 + 2] = this.color.b;
			colorBuffer[offset + 0 + 3] = this.color.a;

			colorBuffer[offset + 4 + 0] = this.color.r;
			colorBuffer[offset + 4 + 1] = this.color.g;
			colorBuffer[offset + 4 + 2] = this.color.b;
			colorBuffer[offset + 4 + 3] = this.color.a;

			colorBuffer[offset + 8 + 0] = this.color.r;
			colorBuffer[offset + 8 + 1] = this.color.g;
			colorBuffer[offset + 8 + 2] = this.color.b;
			colorBuffer[offset + 8 + 3] = this.color.a;

			colorBuffer[offset + 12 + 0] = this.color.r;
			colorBuffer[offset + 12 + 1] = this.color.g;
			colorBuffer[offset + 12 + 2] = this.color.b;
			colorBuffer[offset + 12 + 3] = this.color.a;

			this.lastColor.set(this.color);
		}

		// determine our particle plane
		if (this.emitter) {
			this.emitter.getParticleBillboardVectors(this, particleEntity);
		}
		if (this.spin === 0) {
			this.bbX.scale(this.size);
			this.bbY.scale(this.size);
		} else {
			var cA = Math.cos(this.spin) * this.size;
			var sA = Math.sin(this.spin) * this.size;
			var upX = this.bbY.x, upY = this.bbY.y, upZ = this.bbY.z;
			this.bbY.set(this.bbX);
			this.bbX.scale(cA).addDirect(upX * sA, upY * sA, upZ * sA);
			this.bbY.scale(-sA).addDirect(upX * cA, upY * cA, upZ * cA);
		}

		// apply billboard vectors to mesh verts
		var vertexBuffer = this.parent.meshData.getAttributeBuffer(MeshData.POSITION);

		var offset = this.index * 12;

		// bottom right point
		calcVec.set(this.position).sub(this.bbX).sub(this.bbY);
		vertexBuffer[offset + 0 + 0] = calcVec.x;
		vertexBuffer[offset + 0 + 1] = calcVec.y;
		vertexBuffer[offset + 0 + 2] = calcVec.z;

		// top right point
		calcVec.set(this.position).sub(this.bbX).add(this.bbY);
		vertexBuffer[offset + 3 + 0] = calcVec.x;
		vertexBuffer[offset + 3 + 1] = calcVec.y;
		vertexBuffer[offset + 3 + 2] = calcVec.z;

		// top left point
		calcVec.set(this.position).add(this.bbX).add(this.bbY);
		vertexBuffer[offset + 6 + 0] = calcVec.x;
		vertexBuffer[offset + 6 + 1] = calcVec.y;
		vertexBuffer[offset + 6 + 2] = calcVec.z;

		// bottom left corner
		calcVec.set(this.position).add(this.bbX).sub(this.bbY);
		vertexBuffer[offset + 9 + 0] = calcVec.x;
		vertexBuffer[offset + 9 + 1] = calcVec.y;
		vertexBuffer[offset + 9 + 2] = calcVec.z;

		if (this.lastUVIndex !== this.uvIndex) {
			var uvBuffer = this.parent.meshData.getAttributeBuffer(MeshData.TEXCOORD0);
			var uIndex = (this.uvIndex % this.parent.uRange) / this.parent.uRange;
			var vIndex = 1.0 - (Math.floor(this.uvIndex / this.parent.vRange) / this.parent.vRange);
			var uDelta = 1.0 / this.parent.uRange;
			var vDelta = 1.0 / this.parent.vRange;

			//! AT: why go through this array?! there's only 2 values; what's the point?
			tmpArray[0] = uIndex + uDelta;
			tmpArray[1] = vIndex - vDelta;
			uvBuffer.set(tmpArray, this.index * 8 + 0);

			tmpArray[0] = uIndex + uDelta;
			tmpArray[1] = vIndex;
			uvBuffer.set(tmpArray, this.index * 8 + 2);

			tmpArray[0] = uIndex;
			tmpArray[1] = vIndex;
			uvBuffer.set(tmpArray, this.index * 8 + 4);

			tmpArray[0] = uIndex;
			tmpArray[1] = vIndex - vDelta;
			uvBuffer.set(tmpArray, this.index * 8 + 6);

			this.lastUVIndex = this.uvIndex;
		}
	};

	/**
	 * Called by update to mark this particle as dead/reusable
	 * @private
	 */
	Particle.prototype.kill = function () {
		this.alive = false;
		// collapse particle to a single point, effectively hiding it from view.
		var vertexBuffer = this.parent.meshData.getAttributeBuffer(MeshData.POSITION);
		var pointA = vertexBuffer.subarray(this.index * 12, this.index * 12 + 3);
		vertexBuffer.set(pointA, this.index * 12 + 3);
		vertexBuffer.set(pointA, this.index * 12 + 6);
		vertexBuffer.set(pointA, this.index * 12 + 9);
	};

	return Particle;
})(goo.ParticleUtils,goo.Vector,goo.Vector3,goo.Vector4,goo.MeshData);
goo.ParticleEmitter = (function (
	ParticleUtils,
	Renderer,
	ObjectUtil
) {
	'use strict';

	/**
	 * A Particle Emitter spawns particles - controlling spawn rate, lifetime, initial velocity vector and position of each particle.
	 * @param {Object} [options] Particle emitter options passed as an object
	 * @param {number} [options.totalParticlesToSpawn=-1] Specifies how many particles this emitter should spawn (-1 for an unlimited amount)
	 * @param {number} [options.maxLifetime=3.0] The maximum lifetime of a particle emitted by this emitter (in seconds)
	 * @param {number} [options.minLifetime=2.0] The minimum lifetime of a particle emitted by this emitter (in seconds)
	 * @param {Array<{ color, mass, uvIndex, color, size, spin }>} [options.timeline] A timeline object describing the transformations that a particle should go through while it 'ages'. This overrides the timeline set on the particle component
	 * @param {Array<ParticleInfluence>} [options.influences] An array of objects providing functions that alter the particle
	 * @param {function (particle, particleEntity) : Vector3} [options.emissionPoint] A function returning an emission point for a particle
	 * @param {function (particle, particleEntity) : Vector3} [options.getEmissionVelocity] A function returning an emission velocity for a particle
	 * @param {function (particle)} [options.getParticleBillboardVectors=ParticleEmitter.CAMERA_BILLBOARD_FUNC] A function that sets the orientation of the particle's billboard
	 * @param {number} [options.releaseRatePerSecond=10] Target number of particles per second to spawn
	 */
	function ParticleEmitter(options) {
		ObjectUtil.copyOptions(this, options, {
			totalParticlesToSpawn: -1,
			maxLifetime: 3.0,
			minLifetime: 2.0,
			timeline: undefined,
			influences: [],
			getEmissionPoint: function (particle, particleEntity) {
				var vec3 = particle.position;
				vec3.setDirect(0, 0, 0);
				return ParticleUtils.applyEntityTransformPoint(vec3, particleEntity);
			},
			getEmissionVelocity: function (particle, particleEntity) {
				var vec3 = particle.velocity;
				vec3.setDirect(0, 1, 0);
				return ParticleUtils.applyEntityTransformVector(vec3, particleEntity);
			},
			getParticleBillboardVectors: ParticleEmitter.CAMERA_BILLBOARD_FUNC,
			releaseRatePerSecond: 10,
			enabled: true
		});

		// used to track fractional parts of particles waiting to be released between frames.
		this.particlesWaitingToRelease = 0.0;
	}

	/**
	 * Sets the billboard coordinates of the particle to face the camera
	 * @param particle
	 */
	// Was: function (particle, particleEntity)
	ParticleEmitter.CAMERA_BILLBOARD_FUNC = function (particle) {
		var camera = Renderer.mainCamera;
		if (camera) {
			particle.bbX.set(camera._left);
			particle.bbY.set(camera._up);
		}
	};

	/**
	 * Returns a number between this.minLifeTime and this.maxLifeTime
	 * @private
	 * @returns {number}
	 */
	//! AT: is it just a glorified rand(min, max) function?
	ParticleEmitter.prototype.nextParticleLifeSpan = function () {
		return this.minLifetime + (this.maxLifetime - this.minLifetime) * Math.random();
	};

	return ParticleEmitter;
})(goo.ParticleUtils,goo.Renderer,goo.ObjectUtil);
goo.ParticleComponent = (function (
	Component,
	Particle,
	ParticleEmitter,
	MeshData
) {
	'use strict';

	/**
	 * Creates and modifies {@link MeshData} to simulate particle effects.<br /><br />ParticleComponents may have one or
	 * more emitters. Each emitter spawns particles, controlling spawn rate, lifetime, initial velocity vector and
	 * position of each particle. Each Particle System also contains a timeline describing changes each particle should
	 * perform over its lifetime, including:
	 * <ul>
	 * <li>Size of particle</li>
	 * <li>Color of particle</li>
	 * <li>Orientation of particle (rotation on screen plane)</li>
	 * <li>Texture coords used.</li>
	 * <li>Other user defined params.</li>
	 * </ul><br />
	 * External influences can exert on particles via a defined callback function system.<br /><br />
	 * Particles billboard toward the screen using a provided Camera as reference.
	 * @param {Object} [settings]
	 * @param {Array} [settings.emitters] Array of emitter settings
	 * @param {Array} [settings.timeline]
	 * @param {number} [settings.uRange=1]
	 * @param {number} [settings.vRange=1]
	 * @param {number} [settings.particleCount=100]
	 * @extends Component
	 */
	function ParticleComponent (settings) {
		Component.apply(this, arguments);

		this.type = 'ParticleComponent';

		Component.call(this);

		settings = settings || {};

		this.emitters = [];
		if (settings.emitters) {
			for ( var i = 0, max = settings.emitters.length; i < max; i++) {
				this.emitters.push(new ParticleEmitter(settings.emitters[i]));
			}
		}

		this.timeline = settings.timeline ? settings.timeline : [];

		this.uRange = isNaN(settings.uRange) ? 1 : settings.uRange;
		this.vRange = isNaN(settings.vRange) ? 1 : settings.vRange;

		var particleCount = isNaN(settings.particleCount) ? 100 : settings.particleCount;
		this.recreateParticles(particleCount);

		this.enabled = true;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	ParticleComponent.type = 'ParticleComponent';

	ParticleComponent.prototype = Object.create(Component.prototype);
	ParticleComponent.prototype.constructor = ParticleComponent;

	ParticleComponent.prototype.generateMeshData = function () {
		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.COLOR, MeshData.TEXCOORD0]);
		this.meshData = new MeshData(attributeMap, this.particleCount * 4, this.particleCount * 6);
		this.meshData.vertexData.setDataUsage('DynamicDraw');

		// setup texture coords
		var uvBuffer = this.meshData.getAttributeBuffer(MeshData.TEXCOORD0);
		var indexBuffer = this.meshData.getIndexBuffer();
		for ( var i = 0, max = this.particleCount; i < max; i++) {
			uvBuffer.set([1.0, 0.0], i * 8 + 0);
			uvBuffer.set([1.0, 1.0], i * 8 + 2);
			uvBuffer.set([0.0, 1.0], i * 8 + 4);
			uvBuffer.set([0.0, 0.0], i * 8 + 6);

			indexBuffer.set([i * 4 + 0, i * 4 + 3, i * 4 + 1, i * 4 + 1, i * 4 + 3, i * 4 + 2], i * 6);
		}
	};

	ParticleComponent.prototype.recreateParticles = function (particleCount) {
		this.particleCount = particleCount;
		this.particles = [];
		for ( var i = 0; i < this.particleCount; i++) {
			this.particles[i] = new Particle(this, i);
		}
		this.generateMeshData();
	};

	return ParticleComponent;
})(goo.Component,goo.Particle,goo.ParticleEmitter,goo.MeshData);
goo.ParticleSystemUtils = (function (
	ParticleComponent,
	MeshRendererComponent,
	MeshDataComponent,
	Texture,
	ParticleEmitter
) {
	'use strict';

	/**
	 * Provides utility methods for particle systems
	 */
	function ParticleSystemUtils() {}

	/**
	 * Creates an Entity based on an object holding particle emitter parameters and a material
	 * @hidden
	 * @param world
	 * @param particleParameters
	 * @param material
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/misc/ParticleLib/ParticleLib-vtest.html Working example
	 * @returns {Entity}
	 */
	ParticleSystemUtils.createParticleSystemEntity = function (world, particleParameters, material) {
		// Create the particle cloud entity
		var particleSystemEntity = world.createEntity();

		// Set particle component
		var particleComponent = new ParticleComponent({
			particleCount: particleParameters.particleCount || 500
		});

		particleComponent.emitters.push(new ParticleEmitter(particleParameters));
		particleSystemEntity.setComponent(particleComponent);

		// Create meshData component using particle data
		var meshDataComponent = new MeshDataComponent(particleComponent.meshData);
		particleSystemEntity.setComponent(meshDataComponent);

		// Create meshRenderer component with material and shader
		var meshRendererComponent = new MeshRendererComponent();
		meshRendererComponent.materials.push(material);
		meshRendererComponent.cullMode = 'Never';
		particleSystemEntity.setComponent(meshRendererComponent);

		return particleSystemEntity;
	};

	/**
	 * Generates a radial gradient with multiple color stops; useful for water simple fire, snowflakes, water ripples and shockwaves
	 * @param {number} [size=64]
	 * @param {Object} [options]
	 * @returns {Texture}
	 */
	ParticleSystemUtils.createFlareTexture = function (size, options) {
		size = size || 64;

		//! AT: this modifies the original options object which is intrusive and bad
		options = options || {};
		options.startRadius = typeof options.startRadius !== 'undefined' ? options.startRadius : 0;
		options.endRadius = typeof options.endRadius !== 'undefined' ? options.endRadius : size / 2;
		options.steps = options.steps || [{ fraction: 0, value: 1 }, { fraction: 1, value: 0 }];
		// options array of (fraction, alpha)

		var canvas = document.createElement('canvas');
		canvas.width = size;
		canvas.height = size;
		var con2d = canvas.getContext('2d');

		var gradient = con2d.createRadialGradient(
			size / 2, size / 2, options.startRadius, size / 2, size / 2, options.endRadius);

		for (var i = 0; i < options.steps.length; i++) {
			var step = options.steps[i];
			gradient.addColorStop(step.fraction, 'rgba(255, 255, 255, ' + step.value + ')');
		}

		con2d.fillStyle = gradient;
		con2d.fillRect(0, 0, size, size);

		var imageData = con2d.getImageData(0, 0, size, size).data;
		imageData = new Uint8Array(imageData);

		var texture = new Texture(imageData, null, size, size);
		return texture;
	};

	/**
	 * Generates a texture of multiple trailing particles; useful for water splashes and sparks
	 * @param {number} [size=64]
	 * @param {Object} [options]
	 * @returns {Texture}
	 */
	ParticleSystemUtils.createSplashTexture = function (size, options) {
		size = size || 64;

		//! AT: this modifies the original options object which is intrusive and bad
		options = options || {};
		options.nTrails = typeof options.nTrails !== 'undefined' ? options.nTrails : 8;
		options.trailStartRadius = typeof options.trailStartRadius !== 'undefined' ? options.trailStartRadius : 1;
		options.trailEndRadius = typeof options.trailEndRadius !== 'undefined' ? options.trailEndRadius : 4;

		var canvas = document.createElement('canvas');
		canvas.width = size;
		canvas.height = size;
		var con2d = canvas.getContext('2d');

		// ----
		function circle(x, y, r) {
			var grad = con2d.createRadialGradient(x, y, 0, x, y, r);
			grad.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
			grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
			con2d.fillStyle = grad;
			con2d.fillRect(x - r, y - r, 2 * r, 2 * r);
		}

		var nSteps = 30;
		function trail(sx, sy, ex, ey, sr, er) {
			var ax = (ex - sx) / nSteps;
			var ay = (ey - sy) / nSteps;
			var ar = (er - sr) / nSteps;
			for (var i = 0, x = sx, y = sy, r = sr; i < nSteps; i++, x += ax, y += ay, r += ar) {
				circle(x, y, r);
			}
		}

		function splash(x, y, minInnerRadius, maxOuterRadius, startTrailRadius, endTrailRadius, n) {
			for (var i = 0; i < n; i++) {
				var angle = Math.random() * Math.PI * 2;
				var innerRadius = Math.random() * 4 + minInnerRadius;
				var outerRadius = Math.random() * 4 - maxOuterRadius;
				trail(
					x + Math.cos(angle) * innerRadius,
					y + Math.sin(angle) * innerRadius,
					x + Math.cos(angle) * outerRadius,
					y + Math.sin(angle) * outerRadius,
					startTrailRadius,
					endTrailRadius
				);
			}
		}
		// ----

		splash(size / 2, size / 2, ((size / 2) / 10) * 1, ((size / 2) / 10) * 9, options.trailStartRadius, options.trailEndRadius, options.nTrails);

		var imageData = con2d.getImageData(0, 0, size, size).data;
		imageData = new Uint8Array(imageData);

		var texture = new Texture(imageData, null, size, size);
		return texture;
	};

	/**
	 * Generates a texture of random fuzzy dots; useful for dust and plankton
	 * @param {number} [size=64]
	 * @param {Object} [options]
	 * @returns {Texture}
	 */
	ParticleSystemUtils.createPlanktonTexture = function (size, options) {
		size = size || 64;

		//! AT: this modifies the original options object which is intrusive and bad
		options = options || {};
		options.nPoints = typeof options.nPoints !== 'undefined' ? options.nPoints : 10;
		options.minRadius = typeof options.minRadius !== 'undefined' ? options.minRadius : 2;
		options.maxRadius = typeof options.maxRadius !== 'undefined' ? options.maxRadius : 5;

		var canvas = document.createElement('canvas');
		canvas.width = size;
		canvas.height = size;
		var con2d = canvas.getContext('2d');

		function circle(x, y, r) {
			var grad = con2d.createRadialGradient(x, y, 0, x, y, r);
			grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
			grad.addColorStop(0.3, 'rgba(255, 255, 255, 1)');
			grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
			con2d.fillStyle = grad;
			con2d.fillRect(x - r, y - r, 2 * r, 2 * r);
		}

		function soup(n) {
			for (var i = 0; i < n; i++) {
				var x = Math.random() * (size - options.maxRadius * 2) + options.maxRadius;
				var y = Math.random() * (size - options.maxRadius * 2) + options.maxRadius;
				circle(x, y, Math.random() * (options.maxRadius - options.minRadius) + options.minRadius);
			}
		}

		soup(options.nPoints);

		var imageData = con2d.getImageData(0, 0, size, size).data;
		imageData = new Uint8Array(imageData);

		var texture = new Texture(imageData, null, size, size);
		return texture;
	};

	/**
	 * Generates a texture of complex hexagonal snowflakes
	 * @param {number} [size=64]
	 * @param {Object} [options]
	 * @returns {Texture}
	 */
	ParticleSystemUtils.createSnowflakeTexture = function (size, options) {
		size = size || 64;

		//! AT: this modifies the original options object which is intrusive and bad
		// also, unused
		options = options || {};

		var canvas = document.createElement('canvas');
		canvas.width = size;
		canvas.height = size;
		var con2d = canvas.getContext('2d');

		function replicateRotated(n, fun) {
			var ak = 2 * Math.PI / n;
			for (var i = 0; i < n; i++) {
				con2d.rotate(ak);
				fun();
			}
		}

		function subSnow1() {
			con2d.beginPath();
			con2d.moveTo(0, 0);
			con2d.lineTo(0, 90);

			for (var i = 0; i < 6; i++) {
				con2d.moveTo(0, 25 + i * 10); con2d.lineTo(16 - i * 1.5, 35 + i * 10);
				con2d.moveTo(0, 25 + i * 10); con2d.lineTo(-(16 - i * 1.5), 35 + i * 10);
			}

			con2d.stroke();
		}

		con2d.strokeStyle = '#FFF';
		con2d.lineWidth = 4;
		con2d.lineCap = 'round';

		con2d.translate(size / 2, size / 2);
		con2d.scale(size / 100 / 2, size / 100 / 2);
		replicateRotated(7, subSnow1);


		var imageData = con2d.getImageData(0, 0, size, size).data;
		imageData = new Uint8Array(imageData);

		var texture = new Texture(imageData, null, size, size);
		return texture;
	};

	return ParticleSystemUtils;
})(goo.ParticleComponent,goo.MeshRendererComponent,goo.MeshDataComponent,goo.Texture,goo.ParticleEmitter);
goo.Snow = (function (
	SystemBus,
	Material,
	ShaderLib,
	TextureCreator,
	ParticleLib,
	ParticleSystemUtils,
	Renderer,
	Vector3
) {
	'use strict';

	/**
	 * Snow
	 * @param {GooRunner} gooRunner
	 */
	function Snow(gooRunner) {
		this.velocity = 10;
		this.height = 25;

		// put this in some subroutine
		this.material = new Material(ShaderLib.particles);
		var texture = ParticleSystemUtils.createFlareTexture(64); //Snowflake
		texture.generateMipmaps = true;
		this.material.setTexture('DIFFUSE_MAP', texture);
		this.material.blendState.blending = 'AdditiveBlending';
		this.material.cullState.enabled = false;
		this.material.depthState.write = false;
		this.material.renderQueue = 2002;

		// actually needed
		var that = this;

		// and this too
		this.particleCloudEntity = ParticleSystemUtils.createParticleSystemEntity(
			gooRunner.world,
			ParticleLib.getSnow({
				getEmissionPoint: function (vec3) {
					// either camera or some predefined area

					// camera
					vec3.copy(Renderer.mainCamera ? Renderer.mainCamera.translation : new Vector3());
					vec3.x += Math.random() * 1000 - 500;
					vec3.y += that.height; // put higher than camera
					vec3.z += Math.random() * 1000 - 500;
				},
				getEmissionVelocity: function (vec3) {
					vec3.x = (Math.random() - 0.5) * 2;
					vec3.y = -(Math.random() + 1) * that.velocity;
					vec3.z = (Math.random() - 0.5) * 2;
				}
			}),
			this.material
		);
		this.particleCloudEntity.name = '_ParticleSystemSnow';

		this.onCameraChange = function (newCam) {
			newCam.entity.attachChild(this.particleCloudEntity);
		}.bind(this);

		this.particleCloudEntity.transformComponent.transform.translation.copy(Renderer.mainCamera ? Renderer.mainCamera.translation : new Vector3());

		this.particleCloudEntity.addToWorld();
		//SystemBus.addListener('goo.setCurrentCamera', this.onCameraChange);
	}

	Snow.prototype.setEmissionVelocity = function (velocity) {
		if (velocity) {
			this.velocity = velocity;

			// change velocity of all particles in the particle system
			// hack, but necessary for this particular situation
			var particleComponent = this.particleCloudEntity.particleComponent;
			var particles = particleComponent.particles;

			for (var i = 0; i < particles.length; i++) {
				particles[i].velocity.y = -(Math.random() + 1) * this.velocity; //this.velocity;
			}
		}
	};

	Snow.prototype.setEmissionHeight = function (height) {
		if (height) {
			this.height = height;
		}
	};

	Snow.prototype.setReleaseRatePerSecond = function (releaseRatePerSecond) {
		if (releaseRatePerSecond) {
			var particleComponent = this.particleCloudEntity.particleComponent;
			var emitter = particleComponent.emitters[0];
			emitter.releaseRatePerSecond = releaseRatePerSecond;
		}
	};

	Snow.prototype.remove = function () {
		//SystemBus.removeListener('goo.setCurrentCamera', this.onCameraChange);
		this.particleCloudEntity.removeFromWorld();
	};

	return Snow;
})(goo.SystemBus,goo.Material,goo.ShaderLib,goo.TextureCreator,goo.ParticleLib,goo.ParticleSystemUtils,goo.Renderer,goo.Vector3);
goo.EnvironmentHandler = (function (
	ConfigHandler,
	_,
	SystemBus,
	ShaderBuilder,
	Snow,
	RSVP
) {
	'use strict';

	var defaults = {
		backgroundColor: [0.3, 0.3, 0.3, 1],
		globalAmbient: [0, 0, 0],
		fog: {
			enabled: false,
			color: [1, 1, 1],
			near: 10,
			far: 1000
		}
	};
	var soundDefaults = {
		volume: 1,
		reverb: 0,
		dopplerFactor: 1,
		rolloffFactor: 0.4,
		maxDistance: 100
	};

	/**
	 * Handling environments
	 * @param {World} world
	 * @param {Function} getConfig
	 * @param {Function} updateObject
	 * @private
	 */
	function EnvironmentHandler() {
		ConfigHandler.apply(this, arguments);
	}

	EnvironmentHandler.prototype = Object.create(ConfigHandler.prototype);
	EnvironmentHandler.prototype.constructor = EnvironmentHandler;
	ConfigHandler._registerClass('environment', EnvironmentHandler);

	EnvironmentHandler.prototype._prepare = function (config) {
		_.defaults(config, defaults);
	};

	EnvironmentHandler.prototype._create = function () {
		return {
			weatherState: {}
		};
	};

	EnvironmentHandler.prototype._remove = function (ref) {
		var object = this._objects.get(ref);
		this._objects.delete(ref);
		if (!object) {
			return;
		}

		// Remove weather
		for (var key in object.weatherState) {
			EnvironmentHandler.weatherHandlers[key].remove(object.weatherState);
		}

		// Reset environment
		SystemBus.emit('goo.setClearColor', defaults.backgroundColor);
		ShaderBuilder.CLEAR_COLOR = defaults.backgroundColor;
		ShaderBuilder.GLOBAL_AMBIENT = defaults.globalAmbient.slice(0, 3);
		ShaderBuilder.USE_FOG = defaults.fog.enabled;
		ShaderBuilder.FOG_COLOR = defaults.fog.color.slice(0, 3);
		ShaderBuilder.FOG_SETTINGS = [defaults.fog.near, defaults.fog.far];

		// Reset Sound
		var soundSystem = this.world.getSystem('SoundSystem');
		if (soundSystem) {
			soundSystem.updateConfig(soundDefaults);
			soundSystem.setReverb(null);
		}
	};

	/**
	 * Adds/updates/removes an environment
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} Resolves with the updated environment or null if removed
	 */
	EnvironmentHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (object) {
			if (!object) { return; }

			var backgroundColor = config.backgroundColor;
			var alpha = backgroundColor[3];
			object.backgroundColor = [
				backgroundColor[0] * alpha,
				backgroundColor[1] * alpha,
				backgroundColor[2] * alpha,
				backgroundColor[3]
			];
			object.globalAmbient = config.globalAmbient.slice(0, 3);

			object.fog = _.deepClone(config.fog);

			// Background color
			SystemBus.emit('goo.setClearColor', object.backgroundColor);

			// Fog and ambient
			ShaderBuilder.CLEAR_COLOR = object.backgroundColor;
			ShaderBuilder.GLOBAL_AMBIENT = object.globalAmbient;
			ShaderBuilder.USE_FOG = object.fog.enabled;
			ShaderBuilder.FOG_COLOR = object.fog.color.slice(0, 3);
			ShaderBuilder.FOG_SETTINGS = [object.fog.near, config.fog.far];

			// Weather
			for (var key in config.weather) {
				var handler = EnvironmentHandler.weatherHandlers[key];
				if (handler) {
					handler.update.call(that, config.weather[key], object.weatherState);
				}
			}

			var promises = [];

			// Skybox
			if (config.skyboxRef) {
				EnvironmentHandler.currentSkyboxRef = config.skyboxRef;
				promises.push(that._load(config.skyboxRef, { reload: true }));
			} else if (EnvironmentHandler.currentSkyboxRef) {
				var p = that.updateObject(EnvironmentHandler.currentSkyboxRef, null)
				.then(function () {
					delete EnvironmentHandler.currentSkyboxRef;
				});
				promises.push(p);
			}

			// Sound
			var soundSystem = that.world.getSystem('SoundSystem');
			if (config.sound && soundSystem) {
				soundSystem.updateConfig(config.sound);
				if (config.sound.reverbRef) {
					var p = that._load(config.sound.reverbRef, options).then(function (sound) {
						soundSystem.setReverb(sound._buffer);
					});
					promises.push(p);
				} else {
					soundSystem.setReverb(null);
				}
			}
			return RSVP.all(promises).then(function () { return object; });
		});
	};


	EnvironmentHandler.weatherHandlers = {
		snow: {
			update: function (config, weatherState) {
				if (config.enabled) {
					if (!weatherState.snow || !weatherState.snow.enabled) {
						// add snow
						weatherState.snow = weatherState.snow || {};
						weatherState.snow.enabled = true;
						weatherState.snow.snow = new Snow(this.world.gooRunner);
					}

					weatherState.snow.snow.setEmissionVelocity(config.velocity);
					weatherState.snow.snow.setReleaseRatePerSecond(config.rate);
					weatherState.snow.snow.setEmissionHeight(config.height);
				} else if (weatherState.snow && weatherState.snow.enabled) {
					// remove snow
					weatherState.snow.snow.remove();
					weatherState.snow.enabled = false;
					delete weatherState.snow.snow;
				}
			},
			remove: function (weatherState) {
				if (weatherState.snow && weatherState.snow.snow) {
					weatherState.snow.snow.remove();
					weatherState.snow.enabled = false;
					delete weatherState.snow.snow;
				}
			}
		}
	};

	return EnvironmentHandler;
})(goo.ConfigHandler,goo.ObjectUtils,goo.SystemBus,goo.ShaderBuilder,goo.Snow,goo.rsvp);
goo.Skybox = (function (
	Box,
	Sphere,
	MeshData,
	Material,
	Shader,
	TextureCreator,
	Transform
) {
	'use strict';

	/**
	 * Skybox
	 * @param type
	 * @param images
	 * @param textureMode
	 * @param yRotation
	 */
	function Skybox(type, images, textureMode, yRotation) {
		var promise;
		if (type === Skybox.SPHERE) {
			this.meshData = new Sphere(48, 48, 1, textureMode || Sphere.TextureModes.Projected);
			if (images instanceof Array) {
				images = images[0];
			}
			if (images) {
				promise = new TextureCreator().loadTexture2D(images);
			}
		} else if (type === Skybox.BOX) {
			this.meshData = new Box(1, 1, 1);
			if (images.length) {
				promise = new TextureCreator().loadTextureCube(images, {
					flipY: false,
					wrapS: 'EdgeClamp',
					wrapT: 'EdgeClamp'
				});
			}
		} else {
			throw new Error('Unknown geometry type');
		}
		var material = new Material(shaders[type], 'Skybox material');

		if (promise) {
			promise.then(function (texture) {
				material.setTexture(Shader.DIFFUSE_MAP, texture);
			});
		}

		material.cullState.cullFace = 'Front';
		material.depthState.enabled = false;

		material.renderQueue = 1;

		this.materials = [material];
		this.transform = new Transform();
		var xAngle = (type === Skybox.SPHERE) ? Math.PI / 2 : 0;
		this.transform.rotation.fromAngles(xAngle, yRotation, 0);
		this.transform.update();
		this.active = true;
	}

	Skybox.SPHERE = 'sphere';
	Skybox.BOX = 'box';

	var shaders = {};
	shaders.box = {
		attributes: {
			vertexPosition: MeshData.POSITION
		},
		uniforms: {
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			cameraPosition: Shader.CAMERA,
			near: Shader.NEAR_PLANE,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
			'attribute vec3 vertexPosition;',

			'uniform mat4 viewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 worldMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform float near;',

			'varying vec3 eyeVec;',

			'void main(void) {',
			'	vec4 worldPos = worldMatrix * vec4(vertexPosition * near * 10.0, 1.0);',
			' worldPos += vec4(cameraPosition, 0.0);',
			'	gl_Position = projectionMatrix * viewMatrix * worldPos;',
			'	eyeVec = worldPos.xyz - cameraPosition;',
			' eyeVec.x = -eyeVec.x;',
			' eyeVec = (worldMatrix * vec4(eyeVec, 0.0)).xyz;',
			'}'//
		].join('\n'),
		fshader: [
			'precision mediump float;',

			'uniform samplerCube diffuseMap;',

			'varying vec3 eyeVec;',

			'void main(void)',
			'{',
			'	vec4 cube = textureCube(diffuseMap, eyeVec);',
			' if (cube.a < 0.05) discard;',
			'	gl_FragColor = cube;',

			//' gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);',
			'}'//
		].join('\n')
	};
	shaders.sphere = {
		attributes: {
			vertexPosition: MeshData.POSITION,
			vertexUV0: MeshData.TEXCOORD0
		},
		uniforms: {
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			cameraPosition: Shader.CAMERA,
			near: Shader.NEAR_PLANE,
			diffuseMap: Shader.DIFFUSE_MAP
		},
		vshader: [
			'attribute vec3 vertexPosition;',
			'attribute vec2 vertexUV0;',

			'uniform mat4 viewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 worldMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform float near;',

			'varying vec2 texCoord0;',
			'varying vec3 eyeVec;',

			'void main(void) {',
			'	texCoord0 = vertexUV0;',
			'	vec4 worldPos = worldMatrix * vec4(vertexPosition * near * 10.0, 1.0);',
			' worldPos += vec4(cameraPosition, 0.0);',
			'	gl_Position = projectionMatrix * viewMatrix * worldPos;',
			'	eyeVec = cameraPosition - worldPos.xyz;',
			'}'//
		].join('\n'),
		fshader: [
			'precision mediump float;',

			'uniform sampler2D diffuseMap;',

			'varying vec2 texCoord0;',

			'void main(void)',
			'{',
			' vec4 sphere = texture2D(diffuseMap, texCoord0);',
			' if (sphere.a < 0.05) discard;',
			'	gl_FragColor = sphere;',
			'}'//
		].join('\n')
	};

	return Skybox;
})(goo.Box,goo.Sphere,goo.MeshData,goo.Material,goo.Shader,goo.TextureCreator,goo.Transform);
goo.SkyboxHandler = (function (
	ConfigHandler,
	EnvironmentHandler,
	Texture,
	ShaderBuilder,
	Skybox,
	RSVP,
	PromiseUtils,
	SystemBus
) {
	'use strict';

	function SkyboxHandler() {
		ConfigHandler.apply(this, arguments);

		this._activeSkyboxRef = null;

		// Skybox entity
		var skybox = new Skybox('box', [], null, 0);
		this._skybox = this.world.createEntity(skybox.meshData, skybox.materials[0], skybox.transform);
		this._skybox.transformComponent.updateWorldTransform();
		this._skybox.isSkybox = true;
		this._skybox.name = 'Skybox_box';

		// Skybox texture
		this._skyboxTexture = new Texture(null, { flipY: false });
		this._skyboxTexture.variant = 'CUBE';
		this._skyboxTexture.wrapS = 'EdgeClamp';
		this._skyboxTexture.wrapT = 'EdgeClamp';
		this._skybox.meshRendererComponent.materials[0].setTexture('DIFFUSE_MAP', this._skyboxTexture);

		// Skysphere entity
		var skysphere = new Skybox('sphere', [], null, 0);
		this._skysphere = this.world.createEntity(skysphere.meshData, skysphere.materials[0], skysphere.transform);
		this._skysphere.transformComponent.updateWorldTransform();
		this._skysphere.isSkybox = true;
		this._skysphere.name = 'Skybox_sphere';

		// Skysphere texture
		this._skysphereTexture = new Texture(null, { flipY: false, wrapS: 'EdgeClamp', wrapT: 'EdgeClamp' });
		this._skysphere.meshRendererComponent.materials[0].setTexture('DIFFUSE_MAP', this._skysphereTexture);

		this._activeSkyshape = null;
	}

	SkyboxHandler.prototype = Object.create(ConfigHandler.prototype);
	SkyboxHandler.prototype.constructor = SkyboxHandler;
	ConfigHandler._registerClass('skybox', SkyboxHandler);

	SkyboxHandler.prototype._remove = function (ref) {
		this._objects.delete(ref);

		// We can only remove the skybox if it is the one that is currently
		// active. Otherwise the scene will be left with no skybox in cases
		// where it shouldn't be.
		if (this._activeSkyboxRef === ref) {
			this._hide(this._skybox);
			this._hide(this._skysphere);
			this._skyboxTexture.setImage(null);
			this._activeSkyshape = null;
			ShaderBuilder.SKYBOX = null;
			ShaderBuilder.SKYSPHERE = null;
			this._activeSkyboxRef = null;
		}
	};

	SkyboxHandler.prototype._create = function () {
		return {
			textures: [],
			enabled: false
		};
	};

	SkyboxHandler.prototype._update = function (ref, config, options) {
		var that = this;
		return ConfigHandler.prototype._update.call(this, ref, config, options).then(function (skybox) {
			if (!skybox) {
				return PromiseUtils.resolve([]);
			}

			var promises = [];
			if (config.box) {
				promises.push(that._updateBox(ref, config.box, options, skybox));
			}
			if (config.sphere) {
				promises.push(that._updateSphere(ref, config.sphere, options, skybox));
			}

			return RSVP.all(promises).then(function (skyboxes) {
				if (config.box || config.sphere) {
					that._activeSkyboxRef = ref;
				}

				return skyboxes;
			});
		});
	};

	SkyboxHandler.prototype._updateSphere = function (ref, config, options, skybox) {
		var that = this;

		if (config.sphereRef) {
			return this._load(config.sphereRef, options).then(function (texture) {
				if (!texture || !texture.image) {
					SystemBus.emit('goo.error.skybox', {
						type: 'Sphere',
						message: 'The skysphere needs an image to display.'
					});
					that._hide(that._skysphere);
					return;
				}

				if (ref === EnvironmentHandler.currentSkyboxRef && config.enabled) {
					var skyTex = that._skysphereTexture;
					skybox.textures = [texture];
					skyTex.setImage(texture.image);

					that._show(that._skysphere);
				} else if (!config.enabled) {
					that._hide(that._skysphere);
				}
				return that._skysphere;
			});
		} else {
			that._skysphereTexture.setImage(null);
			that._hide(that._skysphere);
		}
		return PromiseUtils.resolve(that._skysphere);
	};

	var sides = ['rightRef', 'leftRef', 'topRef', 'bottomRef', 'frontRef', 'backRef'];

	//! AT: this can definitely be moved elsewhere
	function isEqual(a, b) {
		var len = a.length;
		if (len !== b.length) {
			return false;
		}
		while (len--) {
			if (a[len] !== b[len]) {
				return false;
			}
		}
		return true;
	}


	SkyboxHandler.prototype._updateBox = function (ref, config, options, skybox) {
		var that = this;

		var promises = sides.map(function (side) {
			return config[side] ? that._load(config[side], options) : PromiseUtils.resolve();
		});

		// Load all textures
		return RSVP.all(promises).then(function (textures) {
			// Check if skybox is the same
			if (isEqual(textures, skybox.textures) && that._activeSkyShape === that._skybox) {
				return that._skybox;
			}

			var images = textures.map(function (texture) { return texture ? texture.image : null; });

			// If no textures were found, clear skybox and return
			if (images.filter(Boolean).length === 0) {
				that._skyboxTexture.setImage(null);
				that._hide(that._skybox);
				return that._skybox;
			}


			var w = 1;
			var h = 1;
			for (var i = 0; i < images.length; i++) {
				if (images[i]) {
					w = Math.max(w, images[i].width);
					h = Math.max(h, images[i].width);
				}
			}

			if (ref === EnvironmentHandler.currentSkyboxRef && config.enabled) {
				skybox.textures = textures;
				var skyTex = that._skyboxTexture;
				skyTex.setImage(images);
				skyTex.image.width = w;
				skyTex.image.height = h;
				skyTex.image.dataReady = true;
				skyTex.setNeedsUpdate();

				that._show(that._skybox);
			} else if (!config.enabled) {
				that._hide(that._skybox);
			}

			return that._skybox;
		});
	};

	SkyboxHandler.prototype._hide = function (skyshape) {
		var renderSystem = this.world.getSystem('RenderSystem');
		renderSystem.removed(skyshape);
		if (skyshape === this._skybox) {
			ShaderBuilder.SKYBOX = null;
		} else if (skyshape === this._skysphere) {
			ShaderBuilder.SKYSPHERE = null;
		}
	};

	SkyboxHandler.prototype._show = function (skyshape) {
		var renderSystem = this.world.getSystem('RenderSystem');
		if (this._activeSkyshape) {
			renderSystem.removed(this._activeSkyshape);
		}
		renderSystem.added(skyshape);
		this._activeSkyshape = skyshape;
		ShaderBuilder.SKYBOX = skyshape === this._skybox ? this._skyboxTexture : null;
		ShaderBuilder.SKYSPHERE = skyshape === this._skysphere ? this._skysphereTexture : null;
	};

	return SkyboxHandler;
})(goo.ConfigHandler,goo.EnvironmentHandler,goo.Texture,goo.ShaderBuilder,goo.Skybox,goo.rsvp,goo.PromiseUtils,goo.SystemBus);
goo.HtmlComponent = (function (
	Component
) {
	'use strict';

	/**
	 * HTML Component.
	 * @extends Component
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/HTMLComponent/HTMLComponent-vtest.html Working example
	 */
	function HtmlComponent(domElement) {
		Component.apply(this, arguments);

		this.type = 'HtmlComponent';

		/**
		 * DOM element.
		 */
		this.domElement = domElement;

		/**
		 * @type {boolean}
		 */
		this.hidden = false;

		/**
		 * @type {boolean}
		 */
		this.useTransformComponent = true;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	HtmlComponent.type = 'HtmlComponent';

	HtmlComponent.prototype = Object.create(Component.prototype);
	HtmlComponent.prototype.constructor = HtmlComponent;

	return HtmlComponent;
})(goo.Component);
goo.HtmlComponentHandler = (function (
	ComponentHandler,
	HtmlComponent,
	RSVP,
	PromiseUtils
) {
	'use strict';

	/**
	 * For handling loading of HTML components
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function HtmlComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'HtmlComponent';
	}

	HtmlComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	ComponentHandler._registerClass('html', HtmlComponentHandler);
	HtmlComponentHandler.prototype.constructor = HtmlComponentHandler;

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @returns {Object}
	 * @private
	 */
	HtmlComponentHandler.prototype._prepare = function (/*config*/) {};

	/**
	 * Create camera component object.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @returns {CameraComponent} the created component object
	 * @private
	 */
	HtmlComponentHandler.prototype._create = function () {
		return new HtmlComponent();
	};

	var regex = /\W/g;
	function getSafeEntityId(id) {
		// fancy chars (like '.') are allowed in ids in HTML but are not allowed in CSS
		return '__' + id.replace(regex, '-');
	}

	/**
	 * Update engine cameracomponent object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	HtmlComponentHandler.prototype.update = function (entity, config, options) {
		var that = this;
		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }

			// ids and classes can contain '.' or start with digits in html but not in css selectors
			// could have prefixed it with a simple '-' but that's sort of reserved for '-moz', '-webkit' and the like
			var safeEntityId = getSafeEntityId(entity.id);

			var domElement = component.domElement;
			if (!domElement) {
				domElement = document.createElement('div');
				domElement.id = safeEntityId;
				domElement.className = 'goo-entity';
				domElement.addEventListener('mousedown', function (domEvent) {
					var gooRunner = entity._world.gooRunner;
					var evt = {
						entity: entity,
						depth: 0,
						x: domEvent.pageX,
						y: domEvent.pageY,
						domEvent: domEvent,
						id: entity.id,
						type: 'mousedown'
					};
					gooRunner.triggerEvent('mousedown', evt);
				});
				domElement.addEventListener('mouseup', function (domEvent) {
					var gooRunner = entity._world.gooRunner;
					var evt = {
						entity: entity,
						depth: 0,
						x: domEvent.pageX,
						y: domEvent.pageY,
						domEvent: domEvent,
						id: entity.id,
						type: 'mouseup'
					};
					gooRunner.triggerEvent('mouseup', evt);
				});
				domElement.addEventListener('click', function (domEvent) {
					var gooRunner = entity._world.gooRunner;
					var evt = {
						entity: entity,
						depth: 0,
						x: domEvent.pageX,
						y: domEvent.pageY,
						domEvent: domEvent,
						id: entity.id,
						type: 'click'
					};
					gooRunner.triggerEvent('click', evt);
				});
				component.domElement = domElement;
				domElement.style.position = 'absolute';
				domElement.style.top = 0;
				domElement.style.left = 0;
				domElement.style.zIndex = 1;
				domElement.style.display = 'none';

				var parentEl = entity._world.gooRunner.renderer.domElement.parentElement || document.body;

				parentEl.appendChild(domElement);
			}

			var innerHtmlChanged = config.innerHtml !== domElement.prevInnerHtml;
			var styleChanged = config.style !== domElement.prevStyle;
			domElement.prevInnerHtml = config.innerHtml;
			domElement.prevStyle = config.style;

			component.useTransformComponent = config.useTransformComponent !== false;

			if (!innerHtmlChanged && !styleChanged) {
				return PromiseUtils.resolve();
			}

			var wrappedStyle = '';
			if (config.style) {
				var processedStyle = config.style.replace('__entity', '#' + safeEntityId);
				wrappedStyle = '<style>\n' + processedStyle + '\n</style>';
			}

			domElement.innerHTML = wrappedStyle + config.innerHtml;

			function loadImage(htmlImage, imageRef) {
				return that.loadObject(imageRef, options)
				.then(function (image) {
					htmlImage.src = image.src;
					return htmlImage;
				}, function (e) {
					console.error(e);
					delete htmlImage.src;
					return htmlImage;
				});
			}

			// Fix images.
			var images = domElement.getElementsByTagName('IMG');
			var imagePromises = [];
			for (var i = 0; i < images.length; i++) {
				var htmlImage = images[i];
				var imageRef = htmlImage.getAttribute('data-id');
				if (imageRef) {
					var promise = loadImage(htmlImage, imageRef);
					imagePromises.push(promise);
				}
			}

			return RSVP.all(imagePromises);
		});
	};

	HtmlComponentHandler.prototype._remove = function (entity) {
		var component = entity.htmlComponent;
		ComponentHandler.prototype._remove.call(this, entity);
		if (component.domElement) {
			component.domElement.parentNode.removeChild(component.domElement);
		}
	};

	return HtmlComponentHandler;
})(goo.ComponentHandler,goo.HtmlComponent,goo.rsvp,goo.PromiseUtils);
goo.DynamicLoader = (function (
	ConfigHandler,
	ComponentHandler,
	Ajax,
	RSVP,
	StringUtils,
	PromiseUtils,
	ArrayUtils,
	ShapeCreatorMemoized
) {
	/*jshint eqeqeq: false, -W041, -W099 */
	'use strict';

	/**
	 * Class to load objects into the engine, or to update objects based on the data model.
	 * @param {Object} options
	 * @param {World} options.world The target World object.
	 * @param {string} options.rootPath The root path from where to get resources.
	 * @param {Ajax} [options.ajax=new Ajax(options.rootPath)]
	 * Can be used to overwrite how the loader fetches refs. Good for testing.
	 */
	function DynamicLoader(options) {
		if (options.world) {
			this._world = options.world;
		} else {
			throw new Error('World argument cannot be null');
		}

		if (options.ajax) {
			this._ajax = options.ajax;
		} else if (options.rootPath) {
			this._ajax = new Ajax(options.rootPath);
		} else {
			throw new Error('ajax or rootPath must be defined');
		}

		// Will hold the engine objects
		this._objects = new Map();
		// Will hold instances of handler classes by type
		this._handlers = {};
	}

	/**
	 * Load configs into the loader cache without loading anything into the engine.
	 * Subsequent calls to load and update will draw configs from the prefilled cache.
	 *
	 * @param {Object} configs Configs object. Keys should be refs, and values are the config objects. If a config is null,
	 * the loader will search for the appropriate config in the loader's internal cache.
	 * @param {boolean} [clear=false] If true, possible previous cache will be cleared. Otherwise the existing cache is extended.
	 *
	 **/
	DynamicLoader.prototype.preload = function (bundle, clear) {
		this._ajax.prefill(bundle, clear);
	};

	/**
	 * Clears the cache of all the handlers. Also clears the engine.
	 * @returns {RSVP.Promise} Promise resolves when handlers are cleared.
	 */
	DynamicLoader.prototype.clear = function () {
		var promises = [];
		for (var type in this._handlers) {
			promises.push(this._handlers[type].clear());
		}
		if (this._ajax.clear instanceof Function) {
			this._ajax.clear();
		}
		if (this._world && this._world.gooRunner) {
			ShapeCreatorMemoized.clearCache(this._world.gooRunner.renderer.context);
			for (var i = 0; i < this._world.gooRunner.renderSystems.length; i++) {
				var lights = this._world.gooRunner.renderSystems[i].lights;
				if (lights) {
					for (var j = 0; j < lights.length; j++) {
						lights[j].destroy(this._world.gooRunner.renderer);
					}
				}
			}

			this._world.gooRunner.renderer.clearShaderCache();
		}
		return RSVP.all(promises);
	};

	/**
	 * Load an object with the specified path into the engine. The object can be of any
	 * type, what loading does is determined by the ref type and the
	 * registered {@link ConfigHandler}.
	 *
	 * @param {string} ref Ref of object to load.
	 * @param {Object} options
	 * @param {function(handled, total)} [options.progressCallback] Function called while loading the world.
	 * Arguments handled and total are both integer numbers and represent the loaded elements so far as well as the total elements.
	 * @param {boolean} [options.preloadBinaries=false] Load the binary data as soon as the reference is loaded.
	 * @param {boolean} [options.noCache=false] Ignore cache, i.e. always load files fresh from the server.
	 * @returns {RSVP.Promise} The promise is resolved when the object is loaded into the world. The parameter is an object
	 * mapping all loaded refs to their configuration, like so: <code>{sceneRef: sceneConfig, entity1Ref: entityConfig...}</code>.
	 */
	DynamicLoader.prototype.load = function (ref, options) {
		options = options || {};
		var load = this._loadObject.bind(this, ref, options);
		if (options.preloadBinaries === true) {
			return this._loadBinariesFromRefs(ref, options).then(load);
		} else {
			return load();
		}
	};

	/**
	 * Update an object in the world with an updated config. The object can be of any
	 * type, updating behavior is determined by the registered {ConfigHandler}.
	 *
	 * @param {string} ref Ref of object to update.
	 * @param {Object} [config] New configuration (formatted according to data model).
	 * If omitted, works the same as {DynamicLoader.load}.
	 * @param {Object} options
	 * @param {boolean} [options.noCache=false] Ignore cache, i.e. always load files fresh from the server.
	 * @returns {RSVP.Promise} The promise is resolved when the object is updated, with the config data as argument.
	 */
	DynamicLoader.prototype.update = function (ref, config, options) {
		var that = this;
		options = options || {};

		return this._ajax.update(ref, config).then(function (config) {
			return that._updateObject(ref, config, options);
		})
		.then(null, function (err) {
			console.error('Error updating ' + ref + ' ' + err);
			throw err;
		});
	};

	/*
	 **** Loader functions ****
	 */

	/**
	 * Loads the object specified by the ref. If an object is already loaded,
	 * it will return that object without updating it.
	 * @param {string} ref
	 * @param {Object} options
	 * @returns {Object} Depending on what type of ref was loaded.
	 * @private
	 */
	DynamicLoader.prototype._loadObject = function (ref, options) {
		var type = DynamicLoader.getTypeForRef(ref);
		var handler = this._getHandler(type);
		if (handler) {
			return handler.load(ref, options);
		} else {
			return this._loadRef(ref, options);
		}
	};

	DynamicLoader.prototype.remove = function (ref) {
		this._objects.delete(ref);
		return this.update(ref, null);
	};

	/**
	 * Updates object identified by ref according to config
	 * @param {string} ref
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {Object} Depending on what's being updated
	 * @private
	 */
	DynamicLoader.prototype._updateObject = function (ref, config, options) {
		var type = DynamicLoader.getTypeForRef(ref);
		var handler = this._getHandler(type);
		if (handler) {
			return handler.update(ref, config, options);
		} else if (DynamicLoader._isRefTypeInGroup(ref, 'binary') || type !== 'bundle') {
			return PromiseUtils.resolve(config);
		} else {
			console.warn('No handler for type ' + type);
			return PromiseUtils.resolve(config);
		}
	};

	/**
	 * Fetch a file from the server, and parse JSON if needed.
	 *
	 * @param {string} ref Ref of the config to load
	 * @param {boolean} [noCache] If true, ignore cached config and fetch everything from the server
	 * @returns {RSVP.Promise} Promise that resolves with the loaded config
	 * @private
	 */
	DynamicLoader.prototype._loadRef = function (ref, options) {
		return this._ajax.load(ref, (options == null) ? false : options.noCache);
	};

	/**
	 * Recursively traverses all configs and preloads the binary files referenced.
	 * @param {Object} references one-level object of references, like in datamodel
	 * @param {Object} options See {DynamicLoader.load}
	 * @returns {RSVP.Promise} Promise resolving when the binary files are loaded.
	 * @private
	 */
	DynamicLoader.prototype._loadBinariesFromRefs = function (references, options) {
		if (typeof references === 'string') {
			var reference = references;
			references = {};
			references[reference] = reference;
		}

		var that = this;
		function loadBinaryRefs(refs) {
			var handled = 0;

			// Load the binary and increase progress tick on finished loading
			function load(ref) {
				return that._loadRef(ref, options).then(function () {
					handled++;
					if (options.progressCallback instanceof Function) {
						options.progressCallback(handled, refs.length);
					}
				});
			}
			// When all binary refs are loaded, we're done
			return RSVP.all(refs.map(load));
		}

		function traverse(refs) {
			var binaryRefs = new Set();
			var jsonRefs = new Set();

			// Loads config for traversal
			function loadFn(ref) {
				return that._loadRef(ref, options).then(traverseFn);
			}

			// Looks through config for binaries
			function traverseFn(config) {
				var promises = [];
				if (config.lazy === true) {
					return PromiseUtils.resolve();
				}

				var refs = DynamicLoader._getRefsFromConfig(config);

				for (var i = 0, len = refs.length; i < len; i++) {
					var ref = refs[i];
					if (DynamicLoader._isRefTypeInGroup(ref, 'asset') && !binaryRefs.has(ref)) {
						// If it's a binary ref, store it in the list
						binaryRefs.add(ref);
					} else if (DynamicLoader._isRefTypeInGroup(ref, 'json') && !jsonRefs.has(ref)) {
						// If it's a json-config, look deeper
						jsonRefs.add(ref);
						promises.push(loadFn(ref));
					}
				}
				return RSVP.all(promises);
			}

			// Resolved when everything is loaded and traversed
			return traverseFn({ collectionRefs: refs }).then(function () {
				return ArrayUtils.fromValues(binaryRefs);
			});
		}

		return traverse(references).then(loadBinaryRefs);
	};

	/**
	 * Gets cached handler for type or creates a new one.
	 * @param {string} type Type.
	 * @returns {ConfigHandler} Config handler.
	 * @private
	 */
	DynamicLoader.prototype._getHandler = function (type) {
		var handler = this._handlers[type];
		if (handler) { return handler; }
		var Handler = ConfigHandler.getHandler(type);
		if (Handler) {
			this._handlers[type] = new Handler(
				this._world,
				this._loadRef.bind(this),
				this._updateObject.bind(this),
				this._loadObject.bind(this)
			);
			return this._handlers[type];
		}
		return null;
	};


	var BINARY_HASH_LENGTH = 40;
	var JSON_HASH_LENGTH = 32;

	/**
	 * Determine if a string is a valid goo data model id
	 *
	 * @param {string} id
	 * @returns {boolean}
	 * @private
	 */
	var isValidId = function(id) {
		if (typeof id !== 'string') {
			return false;
		}
		var tokens = id.split('.');
		return tokens[0] &&
			(tokens[0].length === BINARY_HASH_LENGTH || tokens[0].length === JSON_HASH_LENGTH) &&
			tokens[1];
	};

	/**
	 * Traverses a json-like structure and collects refs in an array
	 * @param config
	 * @returns {Array}
	 * @hidden
	 */
	DynamicLoader._getRefsFromConfig = function (config) {
		var refs = [];

		function traverse(key, value) {
			// Multiple refs
			if (StringUtils.endsWith(key.toLowerCase(), 'refs') && value instanceof Object) {
				var foundRefs = 0;
				for (var i = 0, keys = Object.keys(value), len = keys.length; i < len; i++) {
					if (isValidId(value[keys[i]])) {
						refs.push(value[keys[i]]);
						foundRefs++;
					}
				}
				if (foundRefs > 0) {
					return;
				}
			}

			// Single ref
			if (
				StringUtils.endsWith(key.toLowerCase(), 'ref') &&
				key !== 'thumbnailRef' &&
				isValidId(value)
			) {
				refs.push(value);
				return;
			}

			// Regular object (step into)
			if (
				value instanceof Object &&
				key !== 'assets' &&
				!(value instanceof Array)
			) {
				// Go down a level
				for (var i = 0, keys = Object.keys(value), len = keys.length; i < len; i++) {
					traverse(keys[i], value[keys[i]]);
				}
			}
		}

		traverse('', config);
		return refs;
	};

	/**
	 * Gets the type of a reference.
	 *
	 * @param {string} ref Reference.
	 * @returns {string} Type of reference.
	 */
	DynamicLoader.getTypeForRef = function (ref) {
		return ref.substr(ref.lastIndexOf('.') + 1).toLowerCase();
	};

	/**
	 * Checks if ref has a type included in the group
	 * Different groups are found in the top of the file
	 * @private
	 * @param {string} ref
	 * @param {string} group
	 * @returns {boolean}
	 */
	DynamicLoader._isRefTypeInGroup = function (ref, group) {
		var type = DynamicLoader.getTypeForRef(ref);
		return type && Ajax.types[group] && Ajax.types[group][type];
	};

	return DynamicLoader;
})(goo.ConfigHandler,goo.ComponentHandler,goo.Ajax,goo.rsvp,goo.StringUtils,goo.PromiseUtils,goo.ArrayUtils,goo.ShapeCreatorMemoized,goo.CameraComponentHandler,goo.EntityHandler,goo.LightComponentHandler,goo.MaterialHandler,goo.MeshDataComponentHandler,goo.MeshDataHandler,goo.MeshRendererComponentHandler,goo.SceneHandler,goo.ShaderHandler,goo.TextureHandler,goo.TransformComponentHandler,goo.ProjectHandler,goo.SoundComponentHandler,goo.SoundHandler,goo.EnvironmentHandler,goo.SkyboxHandler,goo.HtmlComponentHandler);
goo.Matrix2 = (function (
	MathUtils,
	Matrix,
	ObjectUtils
) {
	'use strict';

	/**
	 * Matrix with 2x2 components.
	 * @extends Matrix
	 * @param {number...} arguments Initial values for the matrix components.
	 */
	function Matrix2() {
		Matrix.call(this, 2, 2);

		if (arguments.length === 0) {
			this.data[0] = 1;
			this.data[3] = 1;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Matrix2) {
				this.copy(arguments[0]);
			} else {
				this.setArray(arguments[0]);
			}
		} else {
			for (var i = 0; i < arguments.length; i++) {
				this.data[i] = arguments[i];
			}
		}

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	Matrix2.prototype = Object.create(Matrix.prototype);
	Matrix2.prototype.constructor = Matrix2;

	Matrix.setupAliases(Matrix2.prototype, [['e00'], ['e10'], ['e01'], ['e11']]);

	/* @type {Matrix2} */
	Matrix2.IDENTITY = new Matrix2(1, 0, 0, 1);

	/**
	 * Performs a component-wise addition.
	 * @param {Matrix2} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.add = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] += rhsData[0];
		thisData[1] += rhsData[1];
		thisData[2] += rhsData[2];
		thisData[3] += rhsData[3];

		return this;
	};

	/**
	 * Performs a component-wise subtraction.
	 * @param {Matrix2} rhs Matrix or scalar on the right-hand side.
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.sub = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] -= rhsData[0];
		thisData[1] -= rhsData[1];
		thisData[2] -= rhsData[2];
		thisData[3] -= rhsData[3];

		return this;
	};

	/**
	 * Multiplies this matrix with a scalar
	 * @param {number} scalar
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.scale = function (scalar) {
		var data = this.data;

		data[0] *= scalar;
		data[1] *= scalar;
		data[2] *= scalar;
		data[3] *= scalar;

		return this;
	};

	/**
	 * Multiplies this matrix with another matrix
	 * @param {Matrix2} rhs Matrix on the left-hand side
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.mul = function (rhs) {
		var s1d = rhs.data;
		var m00 = s1d[0], m01 = s1d[2],
			m10 = s1d[1], m11 = s1d[3];

		var s2d = this.data;
		var n00 = s2d[0], n01 = s2d[2],
			n10 = s2d[1], n11 = s2d[3];

		var rd = this.data;

		rd[0] = m00 * n00 + m01 * n10;
		rd[2] = m00 * n10 + m01 * n11;

		rd[1] = m10 * n00 + m11 * n10;
		rd[3] = m10 * n01 + m11 * n11;

		return this;
	};

	/**
	 * Multiplies two matrices and stores the result in this matrix
	 * @param {Matrix2} lhs Matrix on the left-hand side
	 * @param {Matrix2} rhs Matrix on the right-hand side
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.mul2 = function (lhs, rhs) {
		var s1d = lhs.data;
		var m00 = s1d[0], m01 = s1d[2],
			m10 = s1d[1], m11 = s1d[3];

		var s2d = rhs.data;
		var n00 = s2d[0], n01 = s2d[2],
			n10 = s2d[1], n11 = s2d[3];

		var rd = this.data;

		rd[0] = m00 * n00 + m01 * n10;
		rd[2] = m00 * n10 + m01 * n11;

		rd[1] = m10 * n00 + m11 * n10;
		rd[3] = m10 * n01 + m11 * n11;

		return this;
	};

	/**
	 * Transposes a matrix (exchanges rows and columns).
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.transpose = function () {
		var data = this.data;

		var e10 = data[1];
		data[1] = data[2];
		data[2] = e10;

		return this;
	};

	/**
	 * Computes the analytical inverse and stores the result in a separate matrix.
	 * @param {Matrix2} source Source matrix.
	 * @param {Matrix2} [target] Target matrix.
	 * @returns {Matrix2} A new matrix if the target matrix is omitted, else the target matrix.
	 */
	Matrix2.invert = function (source, target) {
		if (!target) {
			target = new Matrix2();
		}

		if (target === source) {
			return target.copy(Matrix2.invert(source));
		}

		var det = source.determinant();

		if (Math.abs(det) < MathUtils.EPSILON) {
			return target;
		}

		det = 1.0 / det;

		target.e00 = source.e11 * det;
		target.e10 = 0.0 - source.e10 * det;
		target.e01 = 0.0 - source.e01 * det;
		target.e11 = source.e00 * det;

		return target;
	};

	/**
	 * Computes the analytical inverse and stores the result locally.
	 * @returns {Matrix2} Self for chaining.
	 */
	Matrix2.prototype.invert = function () {
		return Matrix2.invert(this, this);
	};

	/**
	 * Tests if the matrix is orthogonal.
	 * @returns {boolean} True if orthogonal.
	 */
	Matrix2.prototype.isOrthogonal = function () {
		var dot;

		dot = this.e00 * this.e01 + this.e10 * this.e11;

		if (Math.abs(dot) > MathUtils.EPSILON) {
			return false;
		}

		return true;
	};

	/**
	 * Tests if the matrix is normal.
	 * @returns {boolean} True if normal.
	 */
	Matrix2.prototype.isNormal = function () {
		var l;

		l = this.e00 * this.e00 + this.e10 * this.e10;

		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		l = this.e01 * this.e01 + this.e11 * this.e11;

		//! AT: why wrap the condition in an if?!
		if (Math.abs(l - 1.0) > MathUtils.EPSILON) {
			return false;
		}

		return true;
	};

	/**
	 * Tests if the matrix is orthonormal.
	 * @returns {boolean} True if orthonormal.
	 */
	Matrix2.prototype.isOrthonormal = function () {
		return this.isOrthogonal() && this.isNormal();
	};

	/**
	 * Computes the determinant of the matrix.
	 * @returns {number} Determinant of matrix.
	 */
	Matrix2.prototype.determinant = function () {
		return this.e00 * this.e11 - this.e01 * this.e10;
	};

	/**
	 * Sets the matrix to identity.
	 * @returns {Matrix2} Self for chaining.
	 */
	Matrix2.prototype.setIdentity = function () {
		this.set(Matrix2.IDENTITY);
		return this;
	};

	/**
	 * Compares two matrices for approximate equality
	 * @param {Matrix2} rhs The matrix to compare against
	 * @returns {boolean}
	 */
	Matrix2.prototype.equals = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		return (Math.abs(thisData[0] - rhsData[0]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[1] - rhsData[1]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[2] - rhsData[2]) <= MathUtils.EPSILON) &&
			(Math.abs(thisData[3] - rhsData[3]) <= MathUtils.EPSILON);
	};

	/**
	 * Copies component values from another matrix to this matrix
	 * @param {Matrix2} rhs Source matrix
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.copy = function (rhs) {
		var thisData = this.data;
		var rhsData = rhs.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[3];

		return this;
	};

	/**
	 * Sets matrix values from an array.
	 * @param {Array<number>} rhsData Array source
	 * @returns {Matrix2} Self for chaining.
	 */
	Matrix2.prototype.setArray = function (rhsData) {
		var thisData = this.data;

		thisData[0] = rhsData[0];
		thisData[1] = rhsData[1];
		thisData[2] = rhsData[2];
		thisData[3] = rhsData[3];

		return this;
	};

	/**
	 * Sets the matrix's values from another matrix's values; an alias for .copy
	 * @param {Matrix2} source Source matrix
	 * @returns {Matrix2} Self to allow chaining
	 */
	Matrix2.prototype.set = Matrix2.prototype.copy;

	/**
	 * Returns a new matrix with the same values as the existing one
	 * @returns {Matrix2} The new matrix
	 */
	Matrix2.prototype.clone = function () {
		return new Matrix2().copy(this);
	};

	// #ifdef DEBUG
	Matrix.addPostChecks(Matrix2.prototype, [
		'add', 'sub', 'scale', 'transpose', 'invert',
		'isOrthogonal', 'determinant',
		'copy'
	]);
	// #endif

	// SHIM START
	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.add = ObjectUtils.warnOnce(
		'Matrix2.add is deprecated. Use Matrix2.prototype.add instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix2();
			}

			if (rhs instanceof Matrix2) {
				target.e00 = lhs.e00 + rhs.e00;
				target.e10 = lhs.e10 + rhs.e10;
				target.e01 = lhs.e01 + rhs.e01;
				target.e11 = lhs.e11 + rhs.e11;
			} else {
				target.e00 = lhs.e00 + rhs;
				target.e10 = lhs.e10 + rhs;
				target.e01 = lhs.e01 + rhs;
				target.e11 = lhs.e11 + rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.combine = ObjectUtils.warnOnce(
		'Matrix2.combine is deprecated. Use Matrix2.prototype.multiply instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix2();
			}

			if (target === lhs || target === rhs) {
				return Matrix.copy(Matrix2.combine(lhs, rhs), target);
			}

			target.e00 = lhs.e00 * rhs.e00 + lhs.e01 * rhs.e10;
			target.e10 = lhs.e10 * rhs.e00 + lhs.e11 * rhs.e10;
			target.e01 = lhs.e00 * rhs.e01 + lhs.e01 * rhs.e11;
			target.e11 = lhs.e10 * rhs.e01 + lhs.e11 * rhs.e11;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.div = ObjectUtils.warnOnce(
		'Matrix2.div is deprecated. Use Matrix2.prototype.div instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix2();
			}

			if (rhs instanceof Matrix2) {
				target.e00 = lhs.e00 / rhs.e00;
				target.e10 = lhs.e10 / rhs.e10;
				target.e01 = lhs.e01 / rhs.e01;
				target.e11 = lhs.e11 / rhs.e11;
			} else {
				rhs = 1.0 / rhs;

				target.e00 = lhs.e00 * rhs;
				target.e10 = lhs.e10 * rhs;
				target.e01 = lhs.e01 * rhs;
				target.e11 = lhs.e11 * rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.mul = ObjectUtils.warnOnce(
		'Matrix2.mul is deprecated. Use Matrix2.prototype.mul instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix2();
			}

			if (rhs instanceof Matrix2) {
				target.e00 = lhs.e00 * rhs.e00;
				target.e10 = lhs.e10 * rhs.e10;
				target.e01 = lhs.e01 * rhs.e01;
				target.e11 = lhs.e11 * rhs.e11;
			} else {
				target.e00 = lhs.e00 * rhs;
				target.e10 = lhs.e10 * rhs;
				target.e01 = lhs.e01 * rhs;
				target.e11 = lhs.e11 * rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.transpose = ObjectUtils.warnOnce(
		'Matrix2.transpose is deprecated. Use Matrix2.prototype.transpose instead.',
		function (source, target) {
			if (!target) {
				target = new Matrix2();
			}

			if (target === source) {
				return Matrix.copy(Matrix2.transpose(source), target);
			}

			target.e00 = source.e00;
			target.e10 = source.e01;
			target.e01 = source.e10;
			target.e11 = source.e11;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.sub = ObjectUtils.warnOnce(
		'Matrix2.sub is deprecated. Use Matrix2.prototype.sub instead.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Matrix2();
			}

			if (rhs instanceof Matrix2) {
				target.e00 = lhs.e00 - rhs.e00;
				target.e10 = lhs.e10 - rhs.e10;
				target.e01 = lhs.e01 - rhs.e01;
				target.e11 = lhs.e11 - rhs.e11;
			} else {
				target.e00 = lhs.e00 - rhs;
				target.e10 = lhs.e10 - rhs;
				target.e01 = lhs.e01 - rhs;
				target.e11 = lhs.e11 - rhs;
			}

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.prototype.combine = ObjectUtils.warnOnce(
		'Matrix2.prototype.combine is deprecated. Use Matrix2.prototype.mul or Matrix2.prototype.mul2 instead.',
		function (rhs) {
			return Matrix2.combine(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Matrix2.prototype.div = ObjectUtils.warnOnce(
		'Matrix2.prototype.div is deprecated.',
		function (rhs) {
			return Matrix2.div(this, rhs, this);
		}
	);
	// SHIM END

	return Matrix2;
})(goo.MathUtils,goo.Matrix,goo.ObjectUtils);
goo.Matrix2x2 = (function (
	Matrix2,
	ObjectUtils
) {
	'use strict';

	var Matrix2x2 = ObjectUtils.warnOnce(
		'Matrix2x2 has been renamed to Matrix2.',
		function () {
			Matrix2.apply(this, arguments);
		}
	);

	Matrix2x2.prototype = Object.create(Matrix2.prototype);
	Matrix2x2.prototype.constructor = Matrix2x2;
	for (var x in Matrix2) {
		Matrix2x2[x] = Matrix2[x];
	}

	return Matrix2x2;
})(goo.Matrix2,goo.ObjectUtils);
goo.Matrix3x3 = (function (
	Matrix3,
	ObjectUtils
) {
	'use strict';

	var Matrix3x3 = ObjectUtils.warnOnce(
		'Matrix3x3 has been renamed to Matrix3.',
		function () {
			Matrix3.apply(this, arguments);
		}
	);

	Matrix3x3.prototype = Object.create(Matrix3.prototype);
	Matrix3x3.prototype.constructor = Matrix3x3;
	for (var x in Matrix3) {
		Matrix3x3[x] = Matrix3[x];
	}

	return Matrix3x3;
})(goo.Matrix3,goo.ObjectUtils);
goo.Matrix4x4 = (function (
	Matrix4,
	ObjectUtils
) {
	'use strict';

	var Matrix4x4 = ObjectUtils.warnOnce(
		'Matrix4x4 has been renamed to Matrix4.',
		function () {
			Matrix4.apply(this, arguments);
		}
	);

	Matrix4x4.prototype = Object.create(Matrix4.prototype);
	Matrix4x4.prototype.constructor = Matrix4x4;
	for (var x in Matrix4) {
		Matrix4x4[x] = Matrix4[x];
	}

	return Matrix4x4;
})(goo.Matrix4,goo.ObjectUtils);
goo.Quaternion = (function (
	Vector,
	Vector3,
	Vector4,
	Matrix3,
	MathUtils,
	ObjectUtils
) {
	'use strict';

	/**
	 * Quaternions provide a convenient mathematical notation for
	 * representing orientations and rotations of objects in three dimensions.
	 * Compared to Euler angles, Quaternions are simpler to compose and can help avoid the problem of gimbal lock.
	 * Compared to rotation matrices, Quaternions are more numerically stable and the representation (4 numbers) is more compact.
	 * Quaternions are non-commutative and provide a convenient way to interpolate between rotations (using the <i>slerp</i> function).
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 */
	function Quaternion(x, y, z, w) {
		// #ifdef DEBUG
		this._x = 0;
		this._y = 0;
		this._z = 0;
		this._w = 1;
		// #endif

		if (arguments.length === 0) {
			// Nothing given
			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 1;
		} else if (arguments.length === 1 && typeof arguments[0] === 'object') {
			if (arguments[0] instanceof Quaternion) {
				// Quaternion
				this.copy(arguments[0]);
			} else {
				// Array
				this.x = arguments[0][0];
				this.y = arguments[0][1];
				this.z = arguments[0][2];
				this.w = arguments[0][3];
			}
		} else {
			// Numbers
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	// #ifdef DEBUG
	Vector.setupAliases(Quaternion.prototype, [['x'], ['y'], ['z'], ['w']]);
	// #endif

	Quaternion.prototype.setDirect = Vector4.prototype.setDirect;
	Quaternion.prototype.dot = Vector4.prototype.dot;
	Quaternion.prototype.length = Vector4.prototype.length;
	Quaternion.prototype.lengthSquared = Vector4.prototype.lengthSquared;
	Quaternion.prototype.normalize = Vector4.prototype.normalize;
	Quaternion.prototype.equals = Vector4.prototype.equals;

	Quaternion.IDENTITY = new Quaternion(0, 0, 0, 1);

	Quaternion.prototype.copy = function (rhs) {
		this.x = rhs.x;
		this.y = rhs.y;
		this.z = rhs.z;
		this.w = rhs.w;
		return this;
	};

	Quaternion.prototype.set = function (rhs) {
		if (rhs instanceof Quaternion) {
			this.x = rhs.x;
			this.y = rhs.y;
			this.z = rhs.z;
			this.w = rhs.w;
		} else {
			this.x = arguments[0];
			this.y = arguments[1];
			this.z = arguments[2];
			this.w = arguments[3];
		}

		return this;
	};

	/**
	 * Computes the spherical linear interpolation between startQuat and endQuat.
	 * @param {Quaternion} startQuat Start quaternion.
	 * @param {Quaternion} endQuat End quaternion.
	 * @param {number} changeAmnt Interpolation factor between 0.0 and 1.0.
	 * @param {Quaternion} workQuat Work quaternion.
	 * @returns {Quaternion} workQuat The interpolated work quaternion.
	 */
	Quaternion.slerp = function (startQuat, endQuat, changeAmnt, workQuat) {
		// check for weighting at either extreme
		if (changeAmnt === 0.0) {
			return workQuat.set(startQuat);
		} else if (changeAmnt === 1.0) {
			return workQuat.set(endQuat);
		}

		// Check for equality and skip operation.
		if (startQuat.equals(endQuat)) {
			return workQuat.set(startQuat);
		}

		var result = startQuat.dot(endQuat);
		workQuat.set(endQuat);

		if (result < 0.0) {
			// Negate the second quaternion and the result of the dot product
			workQuat.negate();
			result = -result;
		}

		// Set the first and second scale for the interpolation
		var scale0 = 1 - changeAmnt;
		var scale1 = changeAmnt;

		// Check if the angle between the 2 quaternions was big enough to
		// warrant such calculations
		if (1 - result > 0.1) {// Get the angle between the 2 quaternions,
			// and then store the sin() of that angle
			var theta = Math.acos(result);
			var invSinTheta = 1 / Math.sin(theta);

			// Calculate the scale for q1 and q2, according to the angle and
			// it's sine value
			scale0 = Math.sin((1 - changeAmnt) * theta) * invSinTheta;
			scale1 = Math.sin(changeAmnt * theta) * invSinTheta;
		}

		// Calculate the x, y, z and w values for the quaternion by using a
		// special form of linear interpolation for quaternions.
		var x = scale0 * startQuat.x + scale1 * workQuat.x;
		var y = scale0 * startQuat.y + scale1 * workQuat.y;
		var z = scale0 * startQuat.z + scale1 * workQuat.z;
		var w = scale0 * startQuat.w + scale1 * workQuat.w;

		workQuat.setDirect(x, y, z, w);

		// Return the interpolated quaternion
		return workQuat;
	};

	/**
	 * Multiplies this quaterion's values by -1.
	 * @returns {Quaternion} Self for chaining.
	 */
	Quaternion.prototype.negate = function () {
		this.x *= -1;
		this.y *= -1;
		this.z *= -1;
		this.w *= -1;

		return this;
	};

	/**
	 * Conjugates this quaternion
	 * @returns {Quaternion} Self for chaining.
	 */
	Quaternion.prototype.conjugate = function () {
		this.x *= -1;
		this.y *= -1;
		this.z *= -1;

		return this;
	};

	/**
	 * Inverts this quaternion
	 * @returns {Quaternion} Self for chaining.
	 */
	Quaternion.prototype.invert = function () {
		return this.conjugate().normalize();
	};

	/**
	 * Performs a multiplication between the current quaternion and another and stores the result locally.
	 * The result is a <b>quaternion product</b>.
	 * @param {Quaternion} rhs Quaternion on the right-hand side.
	 * @returns {Quaternion} Self for chaining.
	 */
	Quaternion.prototype.mul = function (rhs) {
		var ax = this.x, ay = this.y, az = this.z, aw = this.w;
		var bx = rhs.x, by = rhs.y, bz = rhs.z, bw = rhs.w;

		this.x = ax * bw + aw * bx + ay * bz - az * by;
		this.y = ay * bw + aw * by + az * bx - ax * bz;
		this.z = az * bw + aw * bz + ax * by - ay * bx;
		this.w = aw * bw - ax * bx - ay * by - az * bz;

		return this;
	};

	(function () {
		var slerpWorkQuat = new Quaternion();

		/**
		 * Computes the spherical linear interpolation from the current quaternion towards endQuat.
		 * @param {Quaternion} endQuat End quaternion.
		 * @param {number} changeAmount Interpolation factor between 0.0 and 1.0.
		 * @returns {Quaternion} Self for chaining.
		 */
		Quaternion.prototype.slerp = function (endQuat, changeAmount) {
			slerpWorkQuat.copy(endQuat);
			Quaternion.slerp(this, endQuat, changeAmount, slerpWorkQuat);
			this.copy(slerpWorkQuat);
			return this;
		};
	})();

	/**
	 * Sets the value of this quaternion to the rotation described by the given matrix values.
	 * @param {Matrix3} matrix Rotation matrix.
	 * @returns {Quaternion} Self for chaining.
	 */
	Quaternion.prototype.fromRotationMatrix = function (matrix) {
		// Uses the Graphics Gems code, from
		// ftp://ftp.cis.upenn.edu/pub/graphics/shoemake/quatut.ps.Z
		// *NOT* the "Matrix and Quaternions FAQ", which has errors!

		// the trace is the sum of the diagonal elements; see
		// http://mathworld.wolfram.com/MatrixTrace.html
		var t = matrix.e00 + matrix.e11 + matrix.e22;

		// we protect the division by s by ensuring that s>=1
		var x, y, z, w;
		if (t >= 0) { // |w| >= .5
			var s = Math.sqrt(t + 1); // |s|>=1 ...
			w = 0.5 * s;
			s = 0.5 / s; // so this division isn't bad
			x = (matrix.e21 - matrix.e12) * s;
			y = (matrix.e02 - matrix.e20) * s;
			z = (matrix.e10 - matrix.e01) * s;
		} else if (matrix.e00 > matrix.e11 && matrix.e00 > matrix.e22) {
			var s = Math.sqrt(1.0 + matrix.e00 - matrix.e11 - matrix.e22); // |s|>=1
			x = s * 0.5; // |x| >= .5
			s = 0.5 / s;
			y = (matrix.e10 + matrix.e01) * s;
			z = (matrix.e02 + matrix.e20) * s;
			w = (matrix.e21 - matrix.e12) * s;
		} else if (matrix.e11 > matrix.e22) {
			var s = Math.sqrt(1.0 + matrix.e11 - matrix.e00 - matrix.e22); // |s|>=1
			y = s * 0.5; // |y| >= .5
			s = 0.5 / s;
			x = (matrix.e10 + matrix.e01) * s;
			z = (matrix.e21 + matrix.e12) * s;
			w = (matrix.e02 - matrix.e20) * s;
		} else {
			var s = Math.sqrt(1.0 + matrix.e22 - matrix.e00 - matrix.e11); // |s|>=1
			z = s * 0.5; // |z| >= .5
			s = 0.5 / s;
			x = (matrix.e02 + matrix.e20) * s;
			y = (matrix.e21 + matrix.e12) * s;
			w = (matrix.e10 - matrix.e01) * s;
		}

		return this.setDirect(x, y, z, w);
	};

	/**
	 * Return a rotation matrix representing the current quaternion.
	 * @param {Matrix3} [store] The matrix to store our result in. If null, a new matrix is created.
	 * @returns {Matrix3} The normalized rotation matrix representation of this quaternion.
	 */
	Quaternion.prototype.toRotationMatrix = function (store) {
		var result = store || new Matrix3();

		var norm = this.lengthSquared();
		var s = norm > 0.0 ? 2.0 / norm : 0.0;

		var xs = this.x * s;
		var ys = this.y * s;
		var zs = this.z * s;
		var xx = this.x * xs;
		var xy = this.x * ys;
		var xz = this.x * zs;
		var xw = this.w * xs;
		var yy = this.y * ys;
		var yz = this.y * zs;
		var yw = this.w * ys;
		var zz = this.z * zs;
		var zw = this.w * zs;

		var t = result.data;
		t[0] = 1.0 - (yy + zz);
		t[1] = xy + zw;
		t[2] = xz - yw;
		t[3] = xy - zw;
		t[4] = 1.0 - (xx + zz);
		t[5] = yz + xw;
		t[6] = xz + yw;
		t[7] = yz - xw;
		t[8] = 1.0 - (xx + yy);

		return result;
	};

	(function () {
		var pivotVector = new Vector3();

		/**
		 * Sets this quaternion to the one that will rotate vector "from" into vector "to". Vectors do not have to be the same length.
		 * @param {Vector3} from The source vector.
		 * @param {Vector3} to The destination vector into which to rotate the source vector.
		 * @returns {Quaternion} Self for chaining.
		 */
		Quaternion.prototype.fromVectorToVector = function (from, to) {
			var a = from; //! AT: why this aliasing?
			var b = to;

			var factor = a.length() * b.length();
			if (Math.abs(factor) > MathUtils.EPSILON) {
				// Vectors have length > 0
				var dot = a.dot(b) / factor;
				var theta = Math.acos(Math.max(-1.0, Math.min(dot, 1.0)));
				pivotVector.copy(a).cross(b);
				if (dot < 0.0 && pivotVector.length() < MathUtils.EPSILON) {
					// Vectors parallel and opposite direction, therefore a rotation of 180 degrees about any vector
					// perpendicular to this vector will rotate vector a onto vector b.

					// The following guarantees the dot-product will be 0.0.
					var dominantIndex;
					if (Math.abs(a.x) > Math.abs(a.y)) {
						if (Math.abs(a.x) > Math.abs(a.z)) {
							dominantIndex = 0;
						} else {
							dominantIndex = 2;
						}
					} else {
						if (Math.abs(a.y) > Math.abs(a.z)) {
							dominantIndex = 1;
						} else {
							dominantIndex = 2;
						}
					}
					pivotVector.setValue(dominantIndex, -a[((dominantIndex + 1) % 3)]);
					pivotVector.setValue((dominantIndex + 1) % 3, a[dominantIndex]);
					pivotVector.setValue((dominantIndex + 2) % 3, 0.0);
				}
				return this.fromAngleAxis(theta, pivotVector);
			} else {
				return this.set(Quaternion.IDENTITY);
			}
		};
	})();

	(function () {
		var tmpStoreVector3 = new Vector3();
		/**
		 * Sets the values of this quaternion to the values represented by a given angle and axis of rotation.
		 * Note that this method creates an object, so use fromAngleNormalAxis if your axis is already normalized.
		 * If axis == (0, 0, 0) the quaternion is set to identity.
		 * @param {number} angle The angle to rotate (in radians).
		 * @param {Vector3} axis The axis of rotation.
		 * @returns {Quaternion} Self for chaining.
		 */
		Quaternion.prototype.fromAngleAxis = function (angle, axis) {
			tmpStoreVector3.copy(axis).normalize();
			return this.fromAngleNormalAxis(angle, tmpStoreVector3);
		};
	})();

	/**
	 * Sets the values of this quaternion to the values represented by a given angle and unit length axis of rotation.
	 * If axis == (0, 0, 0) the quaternion is set to identity.
	 * @param {number} angle The angle to rotate (in radians).
	 * @param {Vector3} axis The axis of rotation (already normalized - unit length).
	 * @returns {Quaternion} Self for chaining.
	 */
	Quaternion.prototype.fromAngleNormalAxis = function (angle, axis) {
		if (axis.equals(Vector3.ZERO)) {
			return this.set(Quaternion.IDENTITY);
		}

		var halfAngle = 0.5 * angle;
		var sin = Math.sin(halfAngle);
		var w = Math.cos(halfAngle);
		var x = sin * axis.x;
		var y = sin * axis.y;
		var z = sin * axis.z;
		return this.setDirect(x, y, z, w);
	};

	/**
	 * Returns the rotation angle represented by this quaternion. If a non-null vector is provided, the axis of rotation is stored in
	 *              that vector as well.
	 * @param {Vector3} axisStore The object to store the computed axis in. If null, no computations are done to determine axis.
	 * @returns {number} The angle of rotation in radians.
	 */
	Quaternion.prototype.toAngleAxis = function (axisStore) {
		var sqrLength = this.x * this.x + this.y * this.y + this.z * this.z;
		var angle;
		if (Math.abs(sqrLength) <= MathUtils.EPSILON) { // length is ~0
			angle = 0.0;
			if (axisStore !== null) {
				axisStore.x = 1.0;
				axisStore.y = 0.0;
				axisStore.z = 0.0;
			}
		} else {
			angle = 2.0 * Math.acos(this.w);
			if (axisStore !== null) {
				var invLength = 1.0 / Math.sqrt(sqrLength);
				axisStore.x = this.x * invLength;
				axisStore.y = this.y * invLength;
				axisStore.z = this.z * invLength;
			}
		}

		return angle;
	};

	/**
	 * Clones the quaternion
	 * @returns {Quaternion} Clone of self
	 */
	Quaternion.prototype.clone = function () {
		return new Quaternion(this.x, this.y, this.z, this.w);
	};

	/**
	 * Calculates the dot product between the current quaternion and another quaternion.
	 * @param rhs Quaternion on the right-hand side.
	 * @returns {number} The dot product.
	 */
	Quaternion.prototype.dot = function (q) {
		return this.x * q.x + this.y * q.y + this.z * q.z + this.w * q.w;
	};

	// #ifdef DEBUG
	Vector.addReturnChecks(Quaternion.prototype, [
		'dot', 'dotDirect',
		'length', 'lengthSquared',
		'distance', 'distanceSquared'
	]);
	// #endif

	/**
	 * Sets the vector's values from 4 numeric arguments
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @returns {Quaternion} Self to allow chaining
	 * @example
	 * var q = new Quaternion(); // q == (0, 0, 0, 0)
	 * q.setDirect(2, 4, 6, 8); // q == (2, 4, 6, 8)
	 */
	Quaternion.prototype.setDirect = function (x, y, z, w) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;
	};

	// SHIM START

	Object.defineProperty(Quaternion.prototype, 'data', {
		get: ObjectUtils.warnOnce(
			'The .data property of Quaternion was removed. Please use the .x, .y, .z and .w properties instead.',
			function () {
				var data = [];
				var that = this;
				Object.defineProperties(data, {
					'0': {
						get: function () {
							return that.x;
						},
						set: function (value) {
							that.x = value;
						}
					},
					'1': {
						get: function () {
							return that.y;
						},
						set: function (value) {
							that.y = value;
						}
					},
					'2': {
						get: function () {
							return that.z;
						},
						set: function (value) {
							that.z = value;
						}
					},
					'3': {
						get: function () {
							return that.w;
						},
						set: function (value) {
							that.w = value;
						}
					}
				});
				return data;
			}
		)
	});

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.add = ObjectUtils.warnOnce(
		'Quaternion.add is deprecated.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			target.x = lhs.x + rhs.x;
			target.y = lhs.y + rhs.y;
			target.z = lhs.z + rhs.z;
			target.w = lhs.w + rhs.w;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.div = ObjectUtils.warnOnce(
		'Quaternion.div is deprecated',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			var clean = true;

			target.x = (clean &= rhs.x < 0 || rhs.x > 0) ? lhs.x / rhs.x : 0;
			target.y = (clean &= rhs.y < 0 || rhs.y > 0) ? lhs.y / rhs.y : 0;
			target.z = (clean &= rhs.z < 0 || rhs.z > 0) ? lhs.z / rhs.z : 0;
			target.w = (clean &= rhs.w < 0 || rhs.w > 0) ? lhs.w / rhs.w : 0;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.mul = Quaternion.mul2 = ObjectUtils.warnOnce(
		'Quaternion.mul is deprecated.',
		function (a, b, out) {
			var ax = a.x, ay = a.y, az = a.z, aw = a.w,
				bx = b.x, by = b.y, bz = b.z, bw = b.w;

			out.x = ax * bw + aw * bx + ay * bz - az * by;
			out.y = ay * bw + aw * by + az * bx - ax * bz;
			out.z = az * bw + aw * bz + ax * by - ay * bx;
			out.w = aw * bw - ax * bx - ay * by - az * bz;
			return out;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.sub = ObjectUtils.warnOnce(
		'Quaternion.sub is deprecated.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			target.x = lhs.x - rhs.x;
			target.y = lhs.y - rhs.y;
			target.z = lhs.z - rhs.z;
			target.w = lhs.w - rhs.w;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.add = ObjectUtils.warnOnce(
		'Quaternion.prototype.add is deprecated.',
		function (rhs) {
			return Quaternion.add(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.div = ObjectUtils.warnOnce(
		'Quaternion.prototype.div is deprecated.',
		function (rhs) {
			return Quaternion.div(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.magnitude = ObjectUtils.warnOnce(
		'Quaternion.prototype.magnitude is deprecated.',
		function () {
			var magnitudeSQ = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
			if (magnitudeSQ === 1.0) {
				return 1.0;
			}
			return Math.sqrt(magnitudeSQ);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.magnitudeSquared = ObjectUtils.warnOnce(
		'Quaternion.prototype.magnitudeSquared is deprecated.',
		function () {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.scalarAdd = ObjectUtils.warnOnce(
		'Quaternion.prototype.scalarAdd is deprecated.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			target.x = lhs.x + rhs;
			target.y = lhs.y + rhs;
			target.z = lhs.z + rhs;
			target.w = lhs.w + rhs;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.scalarDiv = ObjectUtils.warnOnce(
		'Quaternion.scalarDiv is deprecated.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			var clean = true;

			rhs = (clean &= rhs < 0.0 || rhs > 0.0) ? 1.0 / rhs : 0.0;

			target.x = lhs.x * rhs;
			target.y = lhs.y * rhs;
			target.z = lhs.z * rhs;
			target.w = lhs.w * rhs;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.scalarMul = ObjectUtils.warnOnce(
		'Quaternion.scalarMul is deprecated.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			target.x = lhs.x * rhs;
			target.y = lhs.y * rhs;
			target.z = lhs.z * rhs;
			target.w = lhs.w * rhs;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.scalarSub = ObjectUtils.warnOnce(
		'Quaternion.scalarSub is deprecated.',
		function (lhs, rhs, target) {
			if (!target) {
				target = new Quaternion();
			}

			target.x = lhs.x - rhs;
			target.y = lhs.y - rhs;
			target.z = lhs.z - rhs;
			target.w = lhs.w - rhs;

			return target;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.setArray = ObjectUtils.warnOnce(
		'Quaternion.prototype.setArray is deprecated.',
		function (array) {
			this.x = array[0];
			this.y = array[1];
			this.z = array[2];
			this.w = array[3];

			return this;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.setVector = ObjectUtils.warnOnce(
		'Quaternion.prototype.setVector is deprecated.',
		function (quat) {
			this.x = quat.x;
			this.y = quat.y;
			this.z = quat.z;
			this.w = quat.w;

			return this;
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.sub = ObjectUtils.warnOnce(
		'Quaternion.prototype.sub is deprecated.',
		function (rhs) {
			return Quaternion.sub(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.scalarAdd = ObjectUtils.warnOnce(
		'Quaternion.prototype.scalarAdd is deprecated.',
		function (rhs) {
			return Quaternion.scalarAdd(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.scalarSub = ObjectUtils.warnOnce(
		'Quaternion.prototype.scalarSub is deprecated.',
		function (rhs) {
			return Quaternion.scalarSub(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.scalarMul = ObjectUtils.warnOnce(
		'Quaternion.prototype.scalarMul is deprecated.',
		function (rhs) {
			return Quaternion.scalarMul(this, rhs, this);
		}
	);

	/**
	 * @hidden
	 * @deprecated
	 */
	Quaternion.prototype.scalarDiv = ObjectUtils.warnOnce(
		'Quaternion.prototype.scalarDiv is deprecated.',
		function (rhs) {
			return Quaternion.scalarDiv(this, rhs, this);
		}
	);

	// SHIM END

	return Quaternion;
})(goo.Vector,goo.Vector3,goo.Vector4,goo.Matrix3,goo.MathUtils,goo.ObjectUtils);
goo.Noise = (function (
	MathUtils
) {
	'use strict';

	/**
	 * A base class for procedural noise functions.
	 * Only used to define the class. Should never be instantiated.
	 */
	function Noise() {}

	Noise.shifter = [
		0x25, 0x5B, 0x0C, 0x80, 0xD8, 0x60, 0x33, 0x99, 0x27, 0xE7, 0xDF, 0xB4, 0xA0, 0x9D, 0x87, 0xB3,
		0x4A, 0x32, 0xCD, 0x97, 0x04, 0xD5, 0xC4, 0x3A, 0xD4, 0x78, 0x35, 0x2D, 0x0A, 0xC3, 0x89, 0x9F,
		0x67, 0x90, 0x6D, 0xAA, 0xCA, 0x30, 0x79, 0x0D, 0xF5, 0x44, 0xE8, 0x1C, 0xD2, 0xAE, 0xC5, 0x50,
		0x6B, 0xCE, 0x9C, 0x74, 0x9B, 0xF0, 0xA2, 0x4F, 0x29, 0x3B, 0x93, 0x75, 0x00, 0xF2, 0x76, 0xA4,
		0x81, 0x65, 0x62, 0x7E, 0xD6, 0x69, 0x59, 0x1A, 0x82, 0xFE, 0x55, 0xC7, 0x08, 0xA5, 0x4C, 0x4B,
		0xBB, 0xA6, 0x40, 0x8F, 0xD9, 0x95, 0x4E, 0x07, 0xAC, 0xE6, 0x57, 0x77, 0x2A, 0xF7, 0x54, 0x8B,
		0x10, 0x8D, 0x86, 0x56, 0x9A, 0x47, 0xFD, 0x3C, 0x63, 0xEB, 0xA8, 0x1E, 0x22, 0x37, 0x71, 0x8C,
		0xBF, 0x45, 0x1F, 0x6A, 0x28, 0x52, 0x49, 0x21, 0x51, 0x0E, 0xEA, 0x83, 0xFF, 0x58, 0xA9, 0x88,
		0xF8, 0x94, 0xDC, 0x8A, 0xDB, 0x66, 0x2C, 0x7F, 0x24, 0xC8, 0x5F, 0xD0, 0x36, 0x98, 0x2F, 0x14,
		0x17, 0x0F, 0x34, 0x7B, 0xB1, 0xE0, 0x7A, 0xAB, 0xD7, 0xAD, 0xD3, 0xBC, 0xBE, 0x85, 0xF4, 0xA7,
		0xEC, 0x23, 0x3F, 0x91, 0xDD, 0x68, 0x41, 0x18, 0x46, 0x64, 0x38, 0x96, 0x31, 0x4D, 0x6E, 0xE4,
		0x70, 0xD1, 0xC6, 0x01, 0xED, 0xB9, 0xFA, 0xE1, 0x5D, 0xC9, 0x7C, 0x6C, 0xDA, 0x48, 0xF3, 0x15,
		0x16, 0x06, 0x72, 0x26, 0x7D, 0x1D, 0x42, 0xF9, 0xDE, 0x6F, 0xF1, 0x0B, 0xBA, 0x3D, 0xB0, 0xB7,
		0x11, 0xA3, 0xE5, 0xA1, 0x39, 0xEE, 0xE3, 0x84, 0x43, 0x53, 0xCF, 0xE2, 0x2E, 0xBD, 0x73, 0xC1,
		0xC2, 0xE9, 0xB6, 0xC0, 0x12, 0x1B, 0x19, 0x02, 0x03, 0xFC, 0x61, 0x3E, 0xB8, 0xEF, 0xAF, 0x5C,
		0xF6, 0x8E, 0xFB, 0xCC, 0xCB, 0x20, 0x92, 0x5A, 0x13, 0x09, 0xB2, 0x9E, 0xB5, 0x5E, 0x2B, 0x05
	];

	/**
	 * Splits a real-valued number into a record for use in smooth interpolation.
	 * @hidden
	 * @param {Float} x Input value.
	 * @returns {Object} Object containing 'i0', 'i1', 'f0' and 'f1' members. (Integer, Integer, Float, Float)
	 */
	Noise.split = function (x) {
		var i = Math.floor(x);
		var f = MathUtils.scurve5(x - i);

		return { 'i0': i + 0, 'i1': i + 1, 'f0': 1.0 - f, 'f1': 0.0 + f };
	};

	/**
	 * Evaluates a one-dimensional fractal noise function at a specific position.
	 * @param {Float} x Evaluation position x.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @param {Integer} octaves Number of octaves.
	 * @param {Float} persistance Amplitude persistance between octaves.
	 * @param {Float} lacunarity Frequency scale between octaves.
	 * @param {Noise} type Name of noise class extending from Noise.
	 * @returns {Float} Noise value.
	 */
	Noise.fractal1d = function (x, scale, octaves, persistance, lacunarity, type) {
		var result = 0.0;
		var amplitude = 1.0;
		var normalizer = 0.0;

		for (var i = 0; i < octaves; i++) {
			result += amplitude * type.evaluate1d(x, scale);
			normalizer += amplitude;
			amplitude *= persistance;
			x *= lacunarity;
		}

		return result / normalizer;
	};

	/**
	 * Evaluates a two-dimensional fractal noise function at a specific position.
	 * @param {Float} x Evaluation position x.
	 * @param {Float} y Evaluation position y.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @param {Integer} octaves Number of octaves.
	 * @param {Float} persistance Amplitude persistance between octaves.
	 * @param {Float} lacunarity Frequency scale between octaves.
	 * @param {Noise} type Name of noise class extending from Noise.
	 * @returns {Float} Noise value.
	 */
	Noise.fractal2d = function (x, y, scale, octaves, persistance, lacunarity, type) {
		var result = 0.0;
		var amplitude = 1.0;
		var normalizer = 0.0;

		for (var i = 0; i < octaves; i++) {
			result += amplitude * type.evaluate2d(x, y, scale);
			normalizer += amplitude;
			amplitude *= persistance;
			x *= lacunarity;
			y *= lacunarity;
		}

		return result / normalizer;
	};

	/**
	 * Evaluates a three-dimensional fractal noise function at a specific position.
	 * @param {Float} x Evaluation position x.
	 * @param {Float} y Evaluation position y.
	 * @param {Float} z Evaluation position z.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @param {Integer} octaves Number of octaves.
	 * @param {Float} persistance Amplitude persistance between octaves.
	 * @param {Float} lacunarity Frequency scale between octaves.
	 * @param {Noise} type Name of noise class extending from Noise.
	 * @returns {Float} Noise value.
	 */
	Noise.fractal3d = function (x, y, z, scale, octaves, persistance, lacunarity, type) {
		var result = 0.0;
		var amplitude = 1.0;
		var normalizer = 0.0;

		for (var i = 0; i < octaves; i++) {
			result += amplitude * type.evaluate3d(x, y, z, scale);
			normalizer += amplitude;
			amplitude *= persistance;
			x *= lacunarity;
			y *= lacunarity;
			z *= lacunarity;
		}

		return result / normalizer;
	};

	/**
	 * Evaluates a four-dimensional fractal noise function at a specific position.
	 * @param {Float} x Evaluation position x.
	 * @param {Float} y Evaluation position y.
	 * @param {Float} z Evaluation position z.
	 * @param {Float} w Evaluation position w.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @param {Integer} octaves Number of octaves.
	 * @param {Float} persistance Amplitude persistance between octaves.
	 * @param {Float} lacunarity Frequency scale between octaves.
	 * @param {Noise} type Name of noise class extending from Noise.
	 * @returns {Float} Noise value.
	 */
	Noise.fractal4d = function (x, y, z, w, scale, octaves, persistance, lacunarity, type) {
		var result = 0.0;
		var amplitude = 1.0;
		var normalizer = 0.0;

		for (var i = 0; i < octaves; i++) {
			result += amplitude * type.evaluate4d(x, y, z, w, scale);
			normalizer += amplitude;
			amplitude *= persistance;
			x *= lacunarity;
			y *= lacunarity;
			z *= lacunarity;
			w *= lacunarity;
		}

		return result / normalizer;
	};

	return Noise;
})(goo.MathUtils);
goo.ValueNoise = (function (
	Noise
) {
	'use strict';

	/**
	 * Value noise is simpler and computationally lighter than Perlin noise yet produce visually similar results when used in fractals.
	 *  Only used to define the class. Should never be instantiated.
	 */
	function ValueNoise() {
		Noise.call(this);
	}

	ValueNoise.prototype = Object.create(Noise.prototype);
	ValueNoise.prototype.constructor = ValueNoise;

	ValueNoise.sources = [
		0.0 / 15.0, 1.0 / 15.0, 2.0 / 15.0, 3.0 / 15.0, 4.0 / 15.0,
		5.0 / 15.0, 6.0 / 15.0, 7.0 / 15.0, 8.0 / 15.0, 9.0 / 15.0,
		10.0 / 15.0, 11.0 / 15.0, 12.0 / 15.0, 13.0 / 15.0, 14.0 / 15.0,
		15.0 / 15.0
	];

	/**
	 * Evaluates the one-dimensional value noise function at a specific position.
	 * @param {Float} px Evaluation position x.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @returns {Float} Noise value.
	 */
	ValueNoise.evaluate1d = function (px, scale) {
		var x = Noise.split(px / scale);

		var i0000 = Noise.shifter[x.i0 & 0xFF] & 0x0F;
		var i0001 = Noise.shifter[x.i1 & 0xFF] & 0x0F;

		var result = 0.0;

		result += x.f0 * ValueNoise.sources[i0000];
		result += x.f1 * ValueNoise.sources[i0001];

		return result;
	};

	/**
	 * Evaluates the two-dimensional value noise function at a specific position.
	 * @param {Float} px Evaluation position x.
	 * @param {Float} py Evaluation position y.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @returns {Float} Noise value.
	 */
	ValueNoise.evaluate2d = function (px, py, scale) {
		var x = Noise.split(px / scale);
		var y = Noise.split(py / scale);

		var i0000 = Noise.shifter[Noise.shifter[y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0001 = Noise.shifter[Noise.shifter[y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0010 = Noise.shifter[Noise.shifter[y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0011 = Noise.shifter[Noise.shifter[y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;

		var result = 0.0;

		result += y.f0 * x.f0 * ValueNoise.sources[i0000];
		result += y.f0 * x.f1 * ValueNoise.sources[i0001];
		result += y.f1 * x.f0 * ValueNoise.sources[i0010];
		result += y.f1 * x.f1 * ValueNoise.sources[i0011];

		return result;
	};

	/**
	 * Evaluates the three-dimensional value noise function at a specific position.
	 * @param {Float} px Evaluation position x.
	 * @param {Float} py Evaluation position y.
	 * @param {Float} pz Evaluation position z.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @returns {Float} Noise value.
	 */
	ValueNoise.evaluate3d = function (px, py, pz, scale) {
		var x = Noise.split(px / scale);
		var y = Noise.split(py / scale);
		var z = Noise.split(pz / scale);

		var i0000 = Noise.shifter[Noise.shifter[Noise.shifter[z.i0 & 0xFF] + y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0001 = Noise.shifter[Noise.shifter[Noise.shifter[z.i0 & 0xFF] + y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0010 = Noise.shifter[Noise.shifter[Noise.shifter[z.i0 & 0xFF] + y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0011 = Noise.shifter[Noise.shifter[Noise.shifter[z.i0 & 0xFF] + y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0100 = Noise.shifter[Noise.shifter[Noise.shifter[z.i1 & 0xFF] + y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0101 = Noise.shifter[Noise.shifter[Noise.shifter[z.i1 & 0xFF] + y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0110 = Noise.shifter[Noise.shifter[Noise.shifter[z.i1 & 0xFF] + y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0111 = Noise.shifter[Noise.shifter[Noise.shifter[z.i1 & 0xFF] + y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;

		var result = 0.0;

		result += z.f0 * y.f0 * x.f0 * ValueNoise.sources[i0000];
		result += z.f0 * y.f0 * x.f1 * ValueNoise.sources[i0001];
		result += z.f0 * y.f1 * x.f0 * ValueNoise.sources[i0010];
		result += z.f0 * y.f1 * x.f1 * ValueNoise.sources[i0011];
		result += z.f1 * y.f0 * x.f0 * ValueNoise.sources[i0100];
		result += z.f1 * y.f0 * x.f1 * ValueNoise.sources[i0101];
		result += z.f1 * y.f1 * x.f0 * ValueNoise.sources[i0110];
		result += z.f1 * y.f1 * x.f1 * ValueNoise.sources[i0111];

		return result;
	};

	/**
	 * Evaluates the four-dimensional value noise function at a specific position.
	 * @param {Float} px Evaluation position x.
	 * @param {Float} py Evaluation position y.
	 * @param {Float} pz Evaluation position z.
	 * @param {Float} pw Evaluation position w.
	 * @param {Float} scale Base scale. Greater scale values will pull the sources (hills and valleys) further apart.
	 * @returns {Float} Noise value.
	 */
	ValueNoise.evaluate4d = function (px, py, pz, pw, scale) {
		var x = Noise.split(px / scale);
		var y = Noise.split(py / scale);
		var z = Noise.split(pz / scale);
		var w = Noise.split(pw / scale);

		var i0000 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i0 & 0xFF] + y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0001 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i0 & 0xFF] + y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0010 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i0 & 0xFF] + y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0011 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i0 & 0xFF] + y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0100 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i1 & 0xFF] + y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0101 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i1 & 0xFF] + y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i0110 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i1 & 0xFF] + y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i0111 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i0 & 0xFF] + z.i1 & 0xFF] + y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i1000 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i0 & 0xFF] + y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i1001 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i0 & 0xFF] + y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i1010 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i0 & 0xFF] + y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i1011 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i0 & 0xFF] + y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i1100 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i1 & 0xFF] + y.i0 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i1101 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i1 & 0xFF] + y.i0 & 0xFF] + x.i1 & 0xFF] & 0x0F;
		var i1110 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i1 & 0xFF] + y.i1 & 0xFF] + x.i0 & 0xFF] & 0x0F;
		var i1111 = Noise.shifter[Noise.shifter[Noise.shifter[Noise.shifter[w.i1 & 0xFF] + z.i1 & 0xFF] + y.i1 & 0xFF] + x.i1 & 0xFF] & 0x0F;

		var result = 0.0;

		result += w.f0 * z.f0 * y.f0 * x.f0 * ValueNoise.sources[i0000];
		result += w.f0 * z.f0 * y.f0 * x.f1 * ValueNoise.sources[i0001];
		result += w.f0 * z.f0 * y.f1 * x.f0 * ValueNoise.sources[i0010];
		result += w.f0 * z.f0 * y.f1 * x.f1 * ValueNoise.sources[i0011];
		result += w.f0 * z.f1 * y.f0 * x.f0 * ValueNoise.sources[i0100];
		result += w.f0 * z.f1 * y.f0 * x.f1 * ValueNoise.sources[i0101];
		result += w.f0 * z.f1 * y.f1 * x.f0 * ValueNoise.sources[i0110];
		result += w.f0 * z.f1 * y.f1 * x.f1 * ValueNoise.sources[i0111];
		result += w.f1 * z.f0 * y.f0 * x.f0 * ValueNoise.sources[i1000];
		result += w.f1 * z.f0 * y.f0 * x.f1 * ValueNoise.sources[i1001];
		result += w.f1 * z.f0 * y.f1 * x.f0 * ValueNoise.sources[i1010];
		result += w.f1 * z.f0 * y.f1 * x.f1 * ValueNoise.sources[i1011];
		result += w.f1 * z.f1 * y.f0 * x.f0 * ValueNoise.sources[i1100];
		result += w.f1 * z.f1 * y.f0 * x.f1 * ValueNoise.sources[i1101];
		result += w.f1 * z.f1 * y.f1 * x.f0 * ValueNoise.sources[i1110];
		result += w.f1 * z.f1 * y.f1 * x.f1 * ValueNoise.sources[i1111];

		return result;
	};

	return ValueNoise;
})(goo.Noise);
goo.ParticleInfluence = (function () {
	'use strict';

	/**
	 * A Particle influence modifies particles in some way over time.
	 * @param {Object} [settings]
	 * @param {Function} [settings.prepare] <code>prepare({@link Entity} particleEntity, {@link ParticleEmitter} emitter)</code>.
	 * @param {Function} [settings.apply] <code>apply(number tpf, {@link Particle} particle, number particleIndex)</code>.
	 * @param {boolean} [settings.enabled=true]
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/particles/ParticleInfluence-vtest.html Working example
	 */
	function ParticleInfluence (settings) {
		settings = settings || {};

		/**
		 * Function for preparing to apply this particle influence. Useful for expensive operations that should only need computing once per frame.
		 * @type {Function}
		 * @param {Entity} [particleEntity] The Entity on which the ParticleComponent is attached to.
		 * @param {ParticleEmitter} [emitter] The ParticleEmitter on which this ParticleInfluence is attached to.
		 */
		this.prepare = settings.prepare ? settings.prepare : function () {};

		/**
		 * Function for applying this particle influence
		 * @type {Function}
		 * @param {number} [tpf] Time since last frame.
		 * @param {Particle} [particle] The Particle object this function is applyed with.
		 * @param {number} [index] The particle's index in the ParticleComponents.particles array.
		 */
		this.apply = settings.apply ? settings.apply : function () {};

		/**
		 * Specifies whether this influence should be applied to particles. Prepare is called regardless
		 * @type {boolean}
		 */
		this.enabled = settings.enabled !== undefined ? settings.enabled === true : true;
	}

	return ParticleInfluence;
})();
goo.BoundingTree = (function (
	BoundingBox,
	BoundingSphere,
	Vector3
) {
	'use strict';

	/**
	 * Bounding tree node
	 * @param boundType
	 */
	function BoundingTree (boundType) {
		this.leftTree = null;
		this.rightTree = null;
		this.localBound = null;
		this.worldBound = null;

		this.boundType = boundType ? boundType : BoundingTree.BOUNDTYPE_BOX;
	}

	BoundingTree.BOUNDTYPE_SPHERE = 'sphere';
	BoundingTree.BOUNDTYPE_BOX = 'box';

	BoundingTree.MAX_PRIMITIVES_PER_LEAF = 16;

	BoundingTree.prototype.construct = function (entity) {
		// check entity has required components
		if (!entity.meshRendererComponent || !entity.meshDataComponent || !entity.transformComponent) {
			console.warn('Entity missing required components for boundingtree construction: ', entity);
			return;
		}

		var meshData = entity.meshDataComponent.meshData;
		// XXX: updatePrimitiveCounts could potentially be done as needed in MeshData instead.
		meshData.updatePrimitiveCounts();
		if (meshData.getSectionCount() === 1) {
			this.primitiveIndices = [];
			for ( var i = 0, max = meshData.getPrimitiveCount(0); i < max; i++) {
				this.primitiveIndices.push(i);
			}
			this.createTree(entity, 0, 0, this.primitiveIndices.length);
		} else {
			this.split(entity, 0, meshData.getSectionCount());
		}
	};

	BoundingTree.prototype.createTree = function (entity, section, start, end) {
		var meshData = entity.meshDataComponent.meshData;

		this.section = section;
		this.start = start;
		this.end = end;

		if (!this.primitiveIndices) {
			return;
		}

		this.createBounds();

		// the bounds at this level should contain all the primitives this level is responsible for.
		this.localBound.computeFromPrimitives(meshData, section, this.primitiveIndices, start, end);

		// check to see if we are a leaf, if the number of primitives we reference is less than or equal to the maximum
		// defined by the CollisionTreeManager we are done.
		if (end - start + 1 <= BoundingTree.MAX_PRIMITIVES_PER_LEAF) {
			return;
		}

		// create the left child
		if (!this.leftTree) {
			this.leftTree = new BoundingTree(this.boundType);
		}
		this.leftTree.primitiveIndices = this.primitiveIndices;
		this.leftTree.createTree(entity, section, start, Math.floor((start + end) / 2));

		// create the right child
		if (!this.rightTree) {
			this.rightTree = new BoundingTree(this.boundType);
		}
		this.rightTree.primitiveIndices = this.primitiveIndices;
		this.rightTree.createTree(entity, section, Math.floor((start + end) / 2), end);
	};

	BoundingTree.prototype.split = function (entity, sectionStart, sectionEnd) {
		// Split range in half
		var rangeSize = sectionEnd - sectionStart;
		var halfRange = Math.floor(rangeSize / 2); // odd number will give +1 to right.

		// left half:
		// if half size === 1, create as regular CollisionTree
		if (halfRange === 1) {
			// compute section
			var section = sectionStart;

			// create the left child
			this.leftTree = new BoundingTree(this.boundType);

			this.leftTree.primitiveIndices = [];
			for (var i = 0; i < this.leftTree.primitiveIndices.length; i++) {
				this.leftTree.primitiveIndices.push(i);
			}
			this.leftTree.createTree(entity, section, 0, this.leftTree.primitiveIndices.length);
		} else {
			// otherwise, make an empty collision tree and call split with new range
			this.leftTree = new BoundingTree(this.boundType);
			this.leftTree.split(entity, sectionStart, sectionStart + halfRange);
		}

		// right half:
		// if rangeSize - half size === 1, create as regular CollisionTree
		if (rangeSize - halfRange === 1) {
			// compute section
			var section = sectionStart + 1;

			// create the left child
			this.rightTree = new BoundingTree(this.boundType);

			this.rightTree._primitiveIndices = [];
			for (var i = 0; i < this.rightTree.primitiveIndices.length; i++) {
				this.rightTree.primitiveIndices.push(i);
			}
			this.rightTree.createTree(entity, section, 0, this.rightTree.primitiveIndices.length);
		} else {
			// otherwise, make an empty collision tree and call split with new range
			this.rightTree = new BoundingTree(this.boundType);
			this.rightTree.split(entity, sectionStart + halfRange, sectionEnd);
		}

		// Ok, now since we technically have no primitives, we need our bounds to be the merging of our children bounds
		// instead:
		this.localBound = this.leftTree.localBound.clone();
		this.localBound.merge(this.rightTree.localBound);
		this.worldBound = this.localBound.clone();
	};

	BoundingTree.prototype.createBounds = function () {
		switch (this.boundType) {
			case BoundingTree.BOUNDTYPE_BOX:
				this.localBound = new BoundingBox();
				this.worldBound = new BoundingBox();
				break;
			case BoundingTree.BOUNDTYPE_SPHERE:
				this.localBound = new BoundingSphere();
				this.worldBound = new BoundingSphere();
				break;
			default:
				break;
		}
	};

	BoundingTree.prototype.findPick = function (ray, entity, store) {
		var result = store;
		if (!result) {
			result = {};
		}

		var worldTransform = entity.transformComponent.worldTransform;
		this.localBound.transform(worldTransform, this.worldBound);

		// if our ray doesn't hit the bounds, then it must not hit a primitive.
		if (!this.worldBound.intersectsRay(ray)) {
			return result;
		}

		// This is not a leaf node, therefore, check each child (left/right) for intersection with the ray.
		if (this.leftTree) {
			this.leftTree.findPick(ray, entity, result);
		}

		if (this.rightTree) {
			this.rightTree.findPick(ray, entity, result);
		} else if (!this.leftTree) {
			// This is a leaf node. We can therefore check each primitive this node contains. If an intersection occurs, place it in the list.
			var data = entity.meshDataComponent.meshData;

			var vertices = null;
			var vecStore = new Vector3();
			for (var i = this.start; i < this.end; i++) {
				vertices = data.getPrimitiveVertices(this.primitiveIndices[i], this.section, vertices);
				for (var t = 0; t < vertices.length; t++) {
					worldTransform.matrix.applyPostPoint(vertices[t]);
				}
				if (ray.intersects(vertices, false, vecStore)) {
					result.distances = result.distances || [];
					result.distances.push(ray.origin.distance(vecStore));
					result.points = result.points || [];
					var vec = new Vector3();
					vec.set(vecStore);
					result.points.push(vec);

					result.vertices = result.vertices || [];
					var verticesCopy = [];
					for (var copyIndex = vertices.length - 1; copyIndex >= 0; copyIndex--) {
						verticesCopy[copyIndex] = new Vector3().set(vertices[copyIndex]);
					}
					result.vertices.push(verticesCopy);
				}
			}
		}

		// if (result.hits) {
		// 	result.hits.sort(function (a, b) {
		// 		return a.distance - b.distance;
		// 	});
		// }

		return result;
	};

	return BoundingTree;
})(goo.BoundingBox,goo.BoundingSphere,goo.Vector3);
goo.PrimitivePickLogic = (function (
	BoundingTree
) {
	'use strict';

	/**
	 * Primitive pick logic
	 */
	function PrimitivePickLogic () {}

	PrimitivePickLogic.prototype.getPickResult = function (pickRay, entity) {
		// look in pick tree for intersection
		var tree = entity.meshDataComponent.meshData.__boundingTree;
		if (!tree) {
			return null;
		}

		return tree.findPick(pickRay, entity, {});
	};

	PrimitivePickLogic.prototype.added = function (entity) {
		// Build boundingtree if not existing
		if (!this.isConstructed(entity)) {
			this.rebuild(entity);
		}
	};

	PrimitivePickLogic.prototype.removed = function (entity) {
		// clear bounding tree
		if ( entity.meshDataComponent && entity.meshDataComponent.meshData) {
			entity.meshDataComponent.meshData.__boundingTree = null;
		}
	};

	PrimitivePickLogic.prototype.isConstructed = function (entity) {
		return !!entity.meshDataComponent.meshData.__boundingTree;
	};

	PrimitivePickLogic.prototype.rebuild = function (entity) {
		// build bounding tree
		entity.meshDataComponent.meshData.__boundingTree = new BoundingTree();

		// calculate bounding tree.
		entity.meshDataComponent.meshData.__boundingTree.construct(entity);
	};

	return PrimitivePickLogic;
})(goo.BoundingTree);
goo.RendererContextLost = (function (
	Renderer,
	RendererRecord
) {
	'use strict';

	Renderer.prototype.invalidateBuffer = function (buffer) {
		buffer.glBuffer = null;
	};

	Renderer.prototype.invalidateMeshData = function (meshData) {
		this.invalidateBuffer(meshData.vertexData);
		if (meshData.indexData) {
			this.invalidateBuffer(meshData.indexData);
		}
		if (meshData.wireframeData) {
			this.invalidateMeshData(meshData.wireframeData);
		}
		if (meshData.flatMeshData) {
			this.invalidateMeshData(meshData.flatMeshData);
		}
	};

	Renderer.prototype.invalidateTexture = function (texture) {
		texture.glTexture = null;
		texture.textureRecord = {};
	};

	Renderer.prototype.invalidateShader = function (shader) {
		shader.shaderProgram = null;
		shader.vertexShader = null;
		shader.fragmentShader = null;
	};

	Renderer.prototype.invalidateMaterial = function (material) {
		var keys = Object.keys(material._textureMaps);
		for (var i = 0; i < keys.length; i++) {
			var key = keys[i];
			var texture = material._textureMaps[key];
			this.invalidateTexture(texture);
		}

		this.invalidateShader(material.shader);
	};

	Renderer.prototype.invalidateRenderTarget = function (renderTarget) {
		renderTarget.glTexture = null;
		renderTarget._glRenderBuffer = null;
		renderTarget._glFrameBuffer = null;
		delete renderTarget.textureRecord;
	};

	Renderer.prototype.invalidateComposer = function (composer) {
		if (composer.writeBuffer && !composer._passedWriteBuffer) {
			this.invalidateRenderTarget(composer.writeBuffer);
		}
		if (composer.readBuffer) {
			this.invalidateRenderTarget(composer.readBuffer);
		}

		composer.copyPass.invalidateHandles(this);

		for (var i = 0; i < composer.passes.length; i++) {
			var pass = composer.passes[i];
			// every pass has to do its own internal cleaning
			pass.invalidateHandles(this);
		}
	};

	Renderer.prototype.invalidatePicking = function () {
		if (this.hardwarePicking) {
			if (this.hardwarePicking.pickingTarget) {
				this.invalidateRenderTarget(this.hardwarePicking.pickingTarget);
			}
			this.invalidateMaterial(this.hardwarePicking.pickingMaterial);
		}
	};

	Renderer.prototype._restoreContext = function () {
		this.establishContext();

		this.rendererRecord = new RendererRecord();

		this.context.clearColor(
			this._clearColor.x,
			this._clearColor.y,
			this._clearColor.z,
			this._clearColor.w
		);
	};
})(goo.Renderer,goo.RendererRecord);
goo.OrbitCamControlScript = (function (
	Vector3,
	Vector2,
	MathUtils,
	Camera,
	SystemBus
) {
	'use strict';

	var ZOOM_DISTANCE_FACTOR = 0.035;
	var EPSILON = 1e-6;

	/**
	 * @param {Object} args
	 * @param {boolean} args.whenUsed When current entity is the camera in use
	 * @param {string} args.dragButton Can be 'Any', 'Left', 'Middle', 'Right', 'None'. None disables dragging
	 * @param {number} args.orbitSpeed
	 * @param {number} args.zoomSpeed
	 * @param {number} args.drag The inertia
	 * @param {number} args.smoothness
	 * @param {number} args.minZoomDistance
	 * @param {number} args.maxZoomDistance
	 * @param {number} args.minAscent in degrees
	 * @param {number} args.maxAscent in degrees
	 * @param {number} args.minAzimuth in degrees
	 * @param {number} args.maxAzimuth in degress
	 * @param {boolean} args.clampAzimuth If true, min and max azimuth are used.
	 * @param {number} args.lookAtDistance distance to the lookatpoint
	 * @param {number[3]} args.lookAtPoint the point in space to look
	 * @deprecated
	 * @param {number[3]} args.spherical The start position of the camera in [radius, azimuth, ascent] form, where 0 azimuth looks to -X
	 * @deprecated
	 */
	function setup(args, ctx) {
		ctx.dirty = true;
		ctx.timeSamples = [0, 0, 0, 0, 0];
		ctx.xSamples = [0, 0, 0, 0, 0];
		ctx.ySamples = [0, 0, 0, 0, 0];
		ctx.sample = 0;
		ctx.velocity = new Vector2(0, 0);
		ctx.cartesian = new Vector3();
		ctx.worldUpVector = Vector3.UNIT_Y.clone();
		ctx.maxSampleTimeMS = 200;

		ctx.mouseState = {
			buttonDown: false,
			lastX: NaN,
			lastY: NaN
		};

		// Making more linear perception
		ctx.smoothness = Math.pow(MathUtils.clamp(args.smoothness, 0, 1), 0.3);
		ctx.inertia = Math.pow(MathUtils.clamp(args.drag, 0, 1), 0.3);

		ctx.dragButton = ['Any', 'Left', 'Middle', 'Right', 'None'].indexOf(args.dragButton) - 1;
		if (ctx.dragButton < -1) {
			ctx.dragButton = -1;
		} else if (ctx.dragButton === 4) {
			ctx.dragButton = null;
		}

		var spherical;
		if (args.lookAtDistance) {
			// Getting script angles from transform
			var angles = ctx.entity.getRotation();
			spherical = ctx.spherical = new Vector3(
				args.lookAtDistance,
				-angles.y + Math.PI / 2,
				-angles.x
			);
		} else if (args.spherical instanceof Array) {
			var spherical = ctx.spherical = new Vector3(
				args.spherical[0],
				args.spherical[1] * MathUtils.DEG_TO_RAD,
				args.spherical[2] * MathUtils.DEG_TO_RAD
			);
		} else if (args.spherical) {
			var spherical = ctx.spherical = new Vector3(
				args.spherical.x,
				args.spherical.y * MathUtils.DEG_TO_RAD,
				args.spherical.z * MathUtils.DEG_TO_RAD
			);
		} else {
			var spherical = ctx.spherical = new Vector3(15, 0, 0); // Just something so the script won't crash
		}
		ctx.targetSpherical = spherical.clone();

		if (args.lookAtDistance) {
			// Setting look at point at a distance forward
			var rotation = ctx.entity.transformComponent.transform.rotation;
			ctx.lookAtPoint = new Vector3(0, 0, -args.lookAtDistance);
			ctx.lookAtPoint.applyPost(rotation);
			ctx.lookAtPoint.add(ctx.entity.getTranslation());
		} else if (args.lookAtPoint) {
			ctx.lookAtPoint = args.lookAtPoint instanceof Array ? Vector3.fromArray(args.lookAtPoint) : args.lookAtPoint.clone();
		} else {
			ctx.lookAtPoint = new Vector3();
		}
		ctx.goingToLookAt = ctx.lookAtPoint.clone();

		// Parallel camera size
		updateFrustumSize(1, ctx);

		setupMouseControls(args, ctx);
	}

	function updateButtonState(buttonIndex, down, args, ctx) {
		/*if (ctx.domElement !== document) {
			ctx.domElement.focus();
		}*/
		var dragButton = ctx.dragButton;
		var mouseState = ctx.mouseState;
		if (dragButton === -1 || dragButton === buttonIndex || down === false) {
			mouseState.buttonDown = down;
			if (down) {
				mouseState.lastX = NaN;
				mouseState.lastY = NaN;
				ctx.velocity.setDirect(0, 0);
				ctx.spherical.y = MathUtils.moduloPositive(ctx.spherical.y, MathUtils.TWO_PI);
				ctx.targetSpherical.set(ctx.spherical);
			} else {
				applyReleaseDrift(args, ctx);
			}
		}
	}

	function updateDeltas(mouseX, mouseY, args, ctx) {
		var dx = 0, dy = 0;
		var mouseState = ctx.mouseState;
		if (isNaN(mouseState.lastX) || isNaN(mouseState.lastY)) {
			mouseState.lastX = mouseX;
			mouseState.lastY = mouseY;
		} else {
			dx = -(mouseX - mouseState.lastX);
			dy = mouseY - mouseState.lastY;
			mouseState.lastX = mouseX;
			mouseState.lastY = mouseY;
		}

		if (!mouseState.buttonDown || dx === 0 && dy === 0) {
			return;
		}

		// Release velocity samples
		ctx.timeSamples[ctx.sample] = Date.now();
		ctx.xSamples[ctx.sample] = dx;
		ctx.ySamples[ctx.sample] = dy;

		ctx.sample++;
		if (ctx.sample > ctx.timeSamples.length - 1) {
			ctx.sample = 0;
		}

		ctx.velocity.setDirect(0, 0);
		move(args.orbitSpeed * dx, args.orbitSpeed * dy, args, ctx);
	}

	function move(azimuthAccel, thetaAccel, args, ctx) {
		var td = ctx.targetSpherical;

		// update our master spherical coords, using x and y movement
		if (args.clampAzimuth) {
			var minAzimuth = args.minAzimuth * MathUtils.DEG_TO_RAD;
			var maxAzimuth = args.maxAzimuth * MathUtils.DEG_TO_RAD;
			td.y = MathUtils.radialClamp(td.y - azimuthAccel, minAzimuth, maxAzimuth);
		} else {
			td.y -= azimuthAccel;
		}
		var minAscent = args.minAscent * MathUtils.DEG_TO_RAD;
		var maxAscent = args.maxAscent * MathUtils.DEG_TO_RAD;
		td.z = MathUtils.clamp(td.z + thetaAccel, minAscent, maxAscent);

		ctx.dirty = true;
	}

	function updateFrustumSize(delta, ctx) {
		var camera = ctx.entity.cameraComponent.camera;
		if (camera.projectionMode === Camera.Parallel) {
			ctx.size = camera.top;
			ctx.size /= delta;
			var size = ctx.size;
			camera.setFrustum(null, null, -size, size, size, -size);
		}
	}

	function applyWheel(e, args, ctx) {
		var delta = Math.max(-1, Math.min(1, -e.wheelDelta || e.detail));
		delta *= ZOOM_DISTANCE_FACTOR * ctx.targetSpherical.x;

		var td = ctx.targetSpherical;
		td.x = MathUtils.clamp(
			td.x + args.zoomSpeed * delta,
			args.minZoomDistance,
			args.maxZoomDistance
		);
		ctx.dirty = true;
	}

	function applyReleaseDrift(args, ctx) {
		var timeSamples = ctx.timeSamples;
		var now = Date.now();
		var dx = 0, dy = 0;
		var found = false;
		for (var i = 0, max = timeSamples.length; i < max; i++) {
			if (now - timeSamples[i] < ctx.maxSampleTimeMS) {
				dx += ctx.xSamples[i];
				dy += ctx.ySamples[i];
				found = true;
			}
		}
		if (found) {
			ctx.velocity.setDirect(
				dx * args.orbitSpeed / timeSamples.length,
				dy * args.orbitSpeed / timeSamples.length
			);
		} else {
			ctx.velocity.setDirect(0, 0);
		}
	}

	function setupMouseControls(args, ctx) {
		var oldDistance = 0;
		var isAndroid = !!navigator.userAgent.match(/Android/i);
		var fakeEvent = {
			wheelDelta: 0
		};

		ctx.listeners = {
			mousedown: function (event) {
				if (!args.whenUsed || ctx.entity === ctx.activeCameraEntity) {
					var button = event.button;
					if (button === 0) {
						if (event.altKey) {
							button = 2;
						} else if (event.shiftKey) {
							button = 1;
						}
					}
					updateButtonState(button, true, args, ctx);
				}
			},
			mouseup: function (event) {
				var button = event.button;
				if (button === 0) {
					if (event.altKey) {
						button = 2;
					} else if (event.shiftKey) {
						button = 1;
					}
				}
				updateButtonState(button, false, args, ctx);
			},
			mousemove: function (event) {
				if (!args.whenUsed || ctx.entity === ctx.activeCameraEntity) {
					updateDeltas(event.clientX, event.clientY, args, ctx);
				}
			},
			mouseleave: function (event) {
				ctx.orbitListeners.mouseup(event);
			},
			mousewheel: function (event) {
				if (!args.whenUsed || ctx.entity === ctx.activeCameraEntity) {
					applyWheel(event, args, ctx);
				}
			},
			touchstart: function (event) {
				if (!args.whenUsed || ctx.entity === ctx.activeCameraEntity) {
					updateButtonState(ctx.dragButton, event.targetTouches.length === 1, args, ctx);
				}
				// fix Android bug that stops touchmove events, unless prevented
				// https://code.google.com/p/android/issues/detail?id=5491
				if (isAndroid) {
					event.preventDefault();
				}
			},
			touchend: function (/*event*/) {
				updateButtonState(ctx.dragButton, false, args, ctx);
				oldDistance = 0;
			},
			touchmove: function (event) {
				if (!args.whenUsed || ctx.entity === ctx.activeCameraEntity) {
					var cx, cy, distance;
					var touches = event.targetTouches;
					var x1 = touches[0].clientX;
					var y1 = touches[0].clientY;
					if (touches.length === 2) {
						var x2 = touches[1].clientX;
						var y2 = touches[1].clientY;
						distance = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
					} else {
						cx = x1;
						cy = y1;
						updateDeltas(cx, cy, args, ctx);
					}
					var scale = (distance - oldDistance) / Math.max(ctx.domElement.offsetHeight, ctx.domElement.offsetWidth);
					scale /= 3;
					if (oldDistance === 0) {
						oldDistance = distance;
					} else if (touches.length === 2 && Math.abs(scale) > 0.3) {
						fakeEvent.wheelDelta = scale;
						applyWheel(fakeEvent, args, ctx);
						oldDistance = distance;
					}
				}
			}
		};
		ctx.listeners.DOMMouseScroll = ctx.listeners.mousewheel;
		ctx.listeners.mouseleave = ctx.listeners.mouseup;

		for (var event in ctx.listeners) {
			ctx.domElement.addEventListener(event, ctx.listeners[event]);
		}

		// Avoid missing the mouseup event because of Chrome bug:
		// https://code.google.com/p/chromium/issues/detail?id=244289
		// seems solved
		/*
		args.domElement.addEventListener('dragstart', function (event) {
			preventDefault();
		}, false);
		*/
		ctx.domElement.oncontextmenu = function () { return false; };
	}

	function updateVelocity(time, args, ctx) {
		if (ctx.velocity.lengthSquared() > EPSILON) {
			move(ctx.velocity.x, ctx.velocity.y, args, ctx);
			var rate = MathUtils.lerp(ctx.inertia, 0, 1 - time / ctx.inertia);
			ctx.velocity.scale(rate);
		} else {
			ctx.velocity.setDirect(0, 0, 0);
		}
	}

	function update(args, ctx/*, goo*/) {
		if (!ctx.dirty) {
			return; //
		}
		var spherical = ctx.spherical;
		var targetSpherical = ctx.targetSpherical;
		var lookAtPoint = ctx.lookAtPoint;
		var goingToLookAt = ctx.goingToLookAt;
		var cartesian = ctx.cartesian;

		var entity = ctx.entity;
		var transformComponent = entity.transformComponent;
		var transform = transformComponent.transform;

		var delta = MathUtils.lerp(ctx.smoothness, 1, ctx.world.tpf);

		if (goingToLookAt.distanceSquared(lookAtPoint) < EPSILON) {
			lookAtPoint.set(goingToLookAt);
		} else {
			lookAtPoint.lerp(goingToLookAt, delta);
		}

		if (ctx.inertia > 0) {
			updateVelocity(entity._world.tpf, args, ctx);
		}


		//var delta = MathUtils.clamp(args.interpolationSpeed * ctx.world.tpf, 0.0, 1.0);
		var sd = spherical;
		var tsd = targetSpherical;

		// Move azimuth to target
		sd.y = MathUtils.lerp(delta, sd.y, tsd.y);
		// Move ascent to target
		sd.z = MathUtils.lerp(delta, sd.z, tsd.z);

		// Move distance to target
		var deltaX = sd.x;
		sd.x = MathUtils.lerp(delta, sd.x, tsd.x);
		deltaX /= sd.x;
		updateFrustumSize(deltaX, ctx);


		MathUtils.sphericalToCartesian(sd.x, sd.y, sd.z, cartesian);

		transform.translation.set(cartesian.add(lookAtPoint));
		if (!transform.translation.equals(lookAtPoint)) {
			transform.lookAt(lookAtPoint, ctx.worldUpVector);
		}

		if (spherical.distanceSquared(targetSpherical) < EPSILON && ctx.lookAtPoint.equals(ctx.goingToLookAt)) {
			sd.y = MathUtils.moduloPositive(sd.y, MathUtils.TWO_PI);
			targetSpherical.set(spherical);
			ctx.dirty = false;
		}

		// set our component updated.
		transformComponent.setUpdated();
		SystemBus.emit('goo.cameraPositionChanged', {
			spherical: ctx.spherical.toArray(),
			translation: transform.translation.toArray(),
			lookAtPoint: ctx.lookAtPoint.toArray(),
			id: entity.id
		});
	}

	function cleanup(args, ctx) {
		for (var event in ctx.listeners) {
			ctx.domElement.removeEventListener(event, ctx.listeners[event]);
		}
	}

	function OrbitCamControlScript() {
		return {
			setup: setup,
			update: update,
			cleanup: cleanup
		};
	}

	OrbitCamControlScript.externals = {
		key: 'OrbitCamControlScript',
		name: 'OrbitCamera Control',
		description: 'Enables camera to orbit around a point in 3D space using the mouse',
		parameters: [{
			key: 'whenUsed',
			'default': true,
			name: 'When Camera Used',
			description: 'Script only runs when the camera to which it is added is being used.',
			type: 'boolean'
		}, {
			key: 'dragButton',
			description: 'Button to enable dragging',
			'default': 'Any',
			options: ['Any', 'Left', 'Middle', 'Right', 'None'],
			type: 'string',
			control: 'select'
		}, {
			key: 'orbitSpeed',
			'default': 0.005,
			type: 'float',
			scale: 0.001,
			decimals: 3
		}, {
			key: 'zoomSpeed',
			'default': 1.0,
			type: 'float',
			scale: 0.1
		}, {
			key: 'drag',
			name: 'Inertia',
			'default': 0.9,
			type: 'float',
			control: 'slider',
			min: 0,
			max: 1.0
		}, {
			key: 'smoothness',
			'default': 0.4,
			type: 'float',
			min: 0,
			max: 1,
			control: 'slider'
		}, {
			key: 'minZoomDistance',
			'default': 1,
			type: 'float',
			min: 0.01
		}, {
			key: 'maxZoomDistance',
			'default': 1000,
			type: 'float',
			min: 1
		}, {
			key: 'minAscent',
			description: 'Maximum arc the camera can reach below the target point',
			'default': -89.99,
			type: 'float',
			control: 'slider',
			min: -89.99,
			max: 89.99
		}, {
			key: 'maxAscent',
			description: 'Maximum arc the camera can reach above the target point',
			'default': 89.99,
			type: 'float',
			control: 'slider',
			min: -89.99,
			max: 89.99
		}, {
			key: 'clampAzimuth',
			'default': false,
			type: 'boolean'
		}, {
			key: 'minAzimuth',
			description: 'Maximum arc the camera can reach clockwise of the target point',
			'default': 90,
			type: 'int',
			control: 'slider',
			min: 0,
			max: 360
		}, {
			key: 'maxAzimuth',
			description: 'Maximum arc the camera can reach counter-clockwise of the target point',
			'default': 270,
			type: 'int',
			control: 'slider',
			min: 0,
			max: 360
		}, {
			key: 'lookAtDistance',
			description: 'The point to orbit around',
			'default': 15,
			type: 'float',
			min: 0.001
		}]
	};

	return OrbitCamControlScript;
})(goo.Vector3,goo.Vector2,goo.MathUtils,goo.Camera,goo.SystemBus);
goo.Grid = (function (
	MeshData,
	_
) {
	'use strict';

	/**
	 * MeshData for a Grid.
	 * @extends MeshData
	 * @param {number} [xSegments=10] Number of columns.
	 * @param {number} [ySegments=10] Number of rows.
	 * @param {number} [width=1] Total width of the Grid.
	 * @param {number} [height=1] Total height of the Grid.
	 * @example var meshData = new Grid( 10, 10, 10, 10);
	 */
	function Grid(xSegments, ySegments, width, height) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			xSegments = props.xSegments;
			ySegments = props.ySegments;
			width = props.width;
			height = props.height;
		}
		this.xSegments = xSegments || 10;
		this.ySegments = ySegments || 10;
		this.width = width || 1;
		this.height = height || 1;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION]);
		var vertsCount = 4 + (this.xSegments - 1) * 2 + (this.ySegments - 1) * 2;
		var idcsCount = 8 + (this.xSegments - 1) * 2 + (this.ySegments - 1) * 2;
		MeshData.call(this, attributeMap, vertsCount, idcsCount);
		this.indexModes[0] = 'Lines';
		this.rebuild();
	}

	Grid.prototype = Object.create(MeshData.prototype);
	Grid.prototype.constructor = Grid;

	Grid.prototype.rebuild = function () {
		var xExtent = this.width / 2;
		var yExtent = this.height / 2;
		var verts = [];
		var indices = [];

		// Outer lines
		verts.push(
			-xExtent, -yExtent, 0,
			-xExtent, yExtent, 0,
			xExtent, yExtent, 0,
			xExtent, -yExtent, 0
		);
		// Connecting the corners
		indices.push(
			0, 1,
			1, 2,
			2, 3,
			3, 0
		);

		// X grid lines
		var xPos;
		var step = this.width / this.xSegments;
		for (var i = 1; i < this.xSegments; i++) {
			xPos = i * step - xExtent;
			verts.push(
				xPos, -yExtent, 0,
				xPos, yExtent, 0
			);
		}

		// Y grid lines
		var yPos;
		step = this.height / this.ySegments;
		for (var i = 1; i < this.ySegments; i++) {
			yPos = i * step - yExtent;
			verts.push(
				-xExtent, yPos, 0,
				xExtent, yPos, 0
			);
		}
		for (var i = indices.length / 2; i < verts.length / 3; i += 2) {
			indices.push(i, i + 1);
		}
		this.getAttributeBuffer(MeshData.POSITION).set(verts);
		this.getIndexBuffer().set(indices);
	};

	/**
	 * Returns a clone of this grid
	 * @returns {Grid}
	 */
	Grid.prototype.clone = function () {
		var options = _.shallowSelectiveClone(this, ['xSegments', 'ySegments', 'width', 'height']);

		return new Grid(options);
	};


	return Grid;
})(goo.MeshData,goo.ObjectUtils);
goo.SimpleBox = (function (
	MeshData
) {
	'use strict';

	/**
	 * An axis-aligned rectangular prism defined by a center point and x-, y- and z-extents (radii) from that center.
	 * @extends MeshData
	 * @param {number} [width=1] Total width of box.
	 * @param {number} [height=1] Total height of box.
	 * @param {number} [length=1] Total length of box.
	 */
	function SimpleBox(width, height, length) {
		if (arguments.length === 1 && arguments[0] instanceof Object) {
			var props = arguments[0];
			width = props.width;
			height = props.height;
			length = props.length;
		}

		this.xExtent = width !== undefined ? width * 0.5 : 0.5;
		this.yExtent = height !== undefined ? height * 0.5 : 0.5;
		this.zExtent = length !== undefined ? length * 0.5 : 0.5;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION]);
		MeshData.call(this, attributeMap, 8, 36);

		this.rebuild();
	}

	SimpleBox.prototype = Object.create(MeshData.prototype);
	SimpleBox.prototype.constructor = SimpleBox;

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {SimpleBox} Self for chaining.
	 */
	SimpleBox.prototype.rebuild = function () {
		var xExtent = this.xExtent;
		var yExtent = this.yExtent;
		var zExtent = this.zExtent;

		this.getAttributeBuffer(MeshData.POSITION).set([
			-xExtent, -yExtent, -zExtent,
			 xExtent, -yExtent, -zExtent,
			 xExtent,  yExtent, -zExtent,
			-xExtent,  yExtent, -zExtent,

			-xExtent, -yExtent,  zExtent,
			 xExtent, -yExtent,  zExtent,
			 xExtent,  yExtent,  zExtent,
			-xExtent,  yExtent,  zExtent
		]);

		this.getIndexBuffer().set([
			//front
			2, 1, 0, 0, 3, 2,
			//back
			5, 6, 7, 7, 4, 5,
			//left
			7, 3, 0, 0, 4, 7,
			//right
			1, 2, 6, 6, 5, 1,
			//top
			6, 2, 3, 3, 7, 6,
			//bottom
			0, 1, 5, 5, 4, 0
		]);

		return this;
	};

	/**
	 * Returns a clone of this quad
	 * @returns {SimpleBox}
	 */
	SimpleBox.prototype.clone = function () {
		var options = {
			width: this.xExtent * 2,
			height: this.yExtent * 2,
			length: this.zExtent * 2
		};

		return new SimpleBox(options);
	};

	return SimpleBox;
})(goo.MeshData);
goo.TextureGrid = (function (
	MeshData,
	_
) {
	'use strict';

	/**
	 * Meshdata for a grid; useful for displaying tiles
	 * @extends MeshData
	 * @param matrix
	 * @param textureUnitsPerLine
	 */
	function TextureGrid(matrix, textureUnitsPerLine) {
		this.matrix = matrix;
		this.textureUnitsPerLine = textureUnitsPerLine || 8;

		var attributeMap = MeshData.defaultMap([MeshData.POSITION, MeshData.NORMAL, MeshData.TEXCOORD0]);
		var nCells = countCells(matrix);
		MeshData.call(this, attributeMap, nCells * 4, nCells * 6);

		this.rebuild();
	}

	TextureGrid.prototype = Object.create(MeshData.prototype);
	TextureGrid.prototype.constructor = TextureGrid;

	function countCells(matrix) {
		var count = 0;
		for (var i = 0; i < matrix.length; i++) {
			count += matrix[i].length;
		}
		return count;
	}

	/**
	 * Builds or rebuilds the mesh data.
	 * @returns {TextureGrid} Self for chaining.
	 */
	TextureGrid.prototype.rebuild = function () {
		var verts = [];
		var norms = [];
		var indices = [];
		var tex = [];

		var indexCounter = 0;
		for (var i = 0; i < this.matrix.length; i++) {
			for (var j = 0; j < this.matrix[i].length; j++) {
				verts.push(
					j, -i - 1, 0,
					j, -i, 0,
					j + 1, -i, 0,
					j + 1, -i - 1, 0
				);

				norms.push(
					0, 0, 1,
					0, 0, 1,
					0, 0, 1,
					0, 0, 1
				);

				var texX = (this.matrix[i][j] % this.textureUnitsPerLine) / this.textureUnitsPerLine;
				var texY = Math.floor(this.matrix[i][j] / this.textureUnitsPerLine) / this.textureUnitsPerLine;
				texY = 1 - texY;

				tex.push(
					texX, texY - 1 / this.textureUnitsPerLine,
					texX, texY,
					texX + 1 / this.textureUnitsPerLine, texY,
					texX + 1 / this.textureUnitsPerLine, texY - 1 / this.textureUnitsPerLine
				);

				indices.push(
					indexCounter + 3, indexCounter + 1, indexCounter + 0,
					indexCounter + 2, indexCounter + 1, indexCounter + 3
				);

				indexCounter += 4;
			}
		}

		this.getAttributeBuffer(MeshData.POSITION).set(verts);
		this.getAttributeBuffer(MeshData.NORMAL).set(norms);
		this.getAttributeBuffer(MeshData.TEXCOORD0).set(tex);

		this.getIndexBuffer().set(indices);

		return this;
	};

	/**
	 * Returns a clone of this texture grid
	 * @returns {TextureGrid}
	 */
	TextureGrid.prototype.clone = function () {
		var options = _.shallowSelectiveClone(this, ['matrix', 'textureUnitsPerLine']);

		return new TextureGrid(options);
	};

	function stringToMatrix(str) {
		var matrix = [];
		var lineAr = str.split('\n');
		lineAr.forEach(function (line) {
			var charAr = line.split('');
			var matrixLine = charAr.map(function (ch) {
				return ch.charCodeAt(0);
			});
			matrix.push(matrixLine);
		});
		return matrix;
	}

	TextureGrid.fromString = function (str) {
		return new TextureGrid(stringToMatrix(str), 16);
	};

	return TextureGrid;
})(goo.MeshData,goo.ObjectUtils);
goo.OscillatorSound = (function (
	AudioContext,
	MathUtils
) {
	'use strict';

	function OscillatorSound() {
		// Settings
		this.id = null;
		this._volume = 1.0;
		this._frequency = 440;
		this._type = 'sine';

		// Nodes
		this._outNode = AudioContext.getContext().createGain();

		this.connectTo();
	}

	OscillatorSound.prototype.stop = function () {
		this._oscNode.stop();
		this._oscNode = null;
	};

	OscillatorSound.prototype.play = function () {
		this._oscNode = AudioContext.getContext().createOscillator();
		this._oscNode.connect(this._outNode);
		this._oscNode.frequency.value = this._frequency;
		this._oscNode.type = this._type;

		this._oscNode.start();
	};

	OscillatorSound.prototype.update = function (config) {
		if (config.volume !== undefined) {
			this._volume = MathUtils.clamp(config.volume, 0, 1);
			this._outNode.gain.value = this._volume;
		}
		if (config.frequency !== undefined) {
			this._frequency = config.frequency;
			if (this._oscNode) {
				this._oscNode.frequency.value = this._frequency;
			}
		}
		if (config.type !== undefined && OscillatorSound.TYPES.indexOf(config.type) !== -1) {
			this._type = config.type;
			if (this._oscNode) {
				this._oscNode.type = this._type;
			}
		}
	};

	/**
	 * Connect output of sound to audionodes
	 * @param {(Array<AudioNode> | AudioNode)} nodes
	 */
	OscillatorSound.prototype.connectTo = function (nodes) {
		if (!AudioContext.isSupported()) {
			console.warn('WebAudio not supported');
			return;
		}
		this._outNode.disconnect();
		if (!nodes) {
			return;
		}
		if (!(nodes instanceof Array)) {
			nodes = [nodes];
		}
		for (var i = 0; i < nodes.length; i++) {
			this._outNode.connect(nodes[i]);
		}
	};

	OscillatorSound.TYPES = [
		'sine',
		'square',
		'sawtooth',
		'triangle',
		'custom'
	];

	return OscillatorSound;
})(goo.AudioContext,goo.MathUtils);
goo.ArrayUtil = (function (ArrayUtils) {

	/**
	 * Array-related utilities
	 * @target-class ArrayUtil ArrayUtil constructor
	 * @require-path goo/util/ArrayUtil
	 * @group util
	 * @deprecated Deprecated as of 0.14.x and scheduled for removal in 0.16.0; The class has been renamed to `goo/util/ArrayUtils`
	 */
	return ArrayUtils;
})(goo.ArrayUtils);
goo.EventTarget = (function () {
	'use strict';

	/**
	 * EventTarget is implemented by objects that can receive events and may have listeners for them.
	 * @example
	 * function MyObject() {
	 * 		EventTarget.apply(this, arguments);
	 * }
	 * MyObject.prototype = Object.create(EventTarget.prototype);
	 */
	function EventTarget() {
		this._listenerMap = new Map();
		this._listenersCopy = [];
	}

	/**
	 * Sends an event to all listeners
	 * @param {Object} event Event passed to the listeners
	 * @param {string} event.type The name of the event
	 * @returns {EventTarget} Self for chaining.
	 */
	EventTarget.prototype.fire = function (event) {
		var listeners = this._listenerMap.get(event.type);
		if (listeners) {
			event.target = this;

			var l = listeners.length;

			var listenersCopy = this._listenersCopy;
			for (var i = 0; i < l; i++) {
				listenersCopy[i] = listeners[i];
			}

			for (var i = 0; i < l; i++) {
				listenersCopy[i](event);
			}
		}

		return this;
	};

	/**
	 * Registers a new listener for a certain event type
	 * @param {string} type Type of event listener to add
	 * @param {Function} listener Listener to add
	 * @returns {EventTarget} Self for chaining.
	 */
	EventTarget.prototype.on = function (type, listener) {
		var listeners = this._listenerMap.get(type);
		if (!listeners) {
			listeners = [listener];
			this._listenerMap.set(type, listeners);
		} else if (listeners.indexOf(listener) === -1) {
			listeners.push(listener);
		}

		return this;
	};

	/**
	 * Removes a listener for a certain event type
	 * @param {string} type Type of event listener to remove
	 * @param {Function} listener Listener to remove
	 * @returns {EventTarget} Self for chaining.
	 */
	EventTarget.prototype.off = function (type, listener) {
		if (listener) {
			var index;
			var listeners = this._listenerMap.get(type);
			if (listeners && (index = listeners.indexOf(listener)) !== -1) {
				listeners.splice(index, 1);

				if (listeners.length === 0) {
					this._listenerMap.delete(type);
				}
			}
		} else {
			this._listenerMap.delete(type);
		}

		return this;
	};

	/**
	 * Test if there are any listeners bound to a certain event type
	 * @param {string} type Type of event to test for
	 * @returns {boolean} If there are any listeners of specified type on this target
	 */
	EventTarget.prototype.has = function (type) {
		return this._listenerMap.has(type);
	};

	return EventTarget;
})();
goo.MeshBuilder = (function (
	MeshData,
	Capabilities,
	Vector3,
	EntityUtils
) {
	'use strict';

	/**
	 * Combines the MeshData of passed-in entities into one new MeshData. This can be useful to reduce draw calls.
	 * Combination is currently limited to 65536 vertices.
	 * Keep in mind that combined MeshData can only use one diffuse color texture, so this is best suited for MeshData that can share the same texture.
	 * @example
	 * var meshBuilder = new MeshBuilder();
	 * var transform = new Transform();
	 *
	 * var box1 = new Box(0.3, 1, 1.6);
	 * var box2 = new Box(0.2, 0.15, 0.7);
	 *
	 * transform.translation.setDirect(0, 0, 1.3);
	 * transform.update();
	 * meshBuilder.addMeshData(box1, transform);
     *
	 * transform.translation.setDirect(0, 0, 0);
	 * transform.update();
	 * meshBuilder.addMeshData(box2, transform);
     *
	 * var meshData = meshBuilder.build()[0];
	 * goo.world.createEntity( meshData, new Material(ShaderLib.simpleLit)).addToWorld();

	 */
	function MeshBuilder() {
		this.meshDatas = [];

		this.vertexData = {};
		this.indexData = [];
		this.vertexCounter = 0;
		this.indexCounter = 0;

		this.indexLengths = [];
		this.indexModes = [];
	}

	/**
	 * add the MeshData of an entity to this MeshBuilder
	 * @param {Entity} entity
	 */
	MeshBuilder.prototype.addEntity = function (entity) {
		entity.traverse(function (entity) {
			if (entity.transformComponent._dirty) {
				entity.transformComponent.updateTransform();
			}
		});
		entity.traverse(function (entity) {
			if (entity.transformComponent._dirty) {
				EntityUtils.updateWorldTransform(entity.transformComponent);
			}
		});
		var that = this;
		entity.traverse(function (entity) {
			if (entity.meshDataComponent) {
				that.addMeshData(entity.meshDataComponent.meshData, entity.transformComponent.worldTransform);
			}
		});
	};

	// var normalMatrix = new Matrix3();
	var vert = new Vector3();
	/**
	 * add MeshData to this MeshBuilder
	 * @param {MeshData} meshData
	 */
	MeshBuilder.prototype.addMeshData = function (meshData, transform) {
		if (!Capabilities.ElementIndexUInt) {
			if (meshData.vertexCount >= 65536) {
				throw new Error('Maximum number of vertices for a mesh to add is 65535. Got: ' + meshData.vertexCount);
			} else if (this.vertexCounter + meshData.vertexCount >= 65536) {
				this._generateMesh();
			}
		}

		var matrix = transform.matrix;
		var rotation = transform.rotation;
		// Matrix3.invert(transform.rotation, normalMatrix);
		// Matrix3.transpose(normalMatrix, normalMatrix);

		var attributeMap = meshData.attributeMap;
		var keys = Object.keys(attributeMap);

		for (var ii = 0, l = keys.length; ii < l; ii++) {
			var key = keys[ii];
			var map = attributeMap[key];
			var attribute = this.vertexData[key];
			if (!attribute) {
				this.vertexData[key] = {};
				attribute = this.vertexData[key];
				attribute.array = [];
				attribute.map = {
					count: map.count,
					type: map.type,
					stride: map.stride,
					offset: map.offset,
					normalized: map.normalized
				};
			}

			var view = meshData.getAttributeBuffer(key);

			var viewLength = view.length;
			var array = attribute.array;
			var count = map.count;
			var vertexPos = this.vertexCounter * count;
			if (key === MeshData.POSITION) {
				for (var i = 0; i < viewLength; i += count) {
					vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);
					vert.applyPostPoint(matrix);
					array[vertexPos + i + 0] = vert.x;
					array[vertexPos + i + 1] = vert.y;
					array[vertexPos + i + 2] = vert.z;
				}
			} else if (key === MeshData.NORMAL) {
				for (var i = 0; i < viewLength; i += count) {
					vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);
					vert.applyPost(rotation);
					array[vertexPos + i + 0] = vert.x;
					array[vertexPos + i + 1] = vert.y;
					array[vertexPos + i + 2] = vert.z;
				}
			} else if (key === MeshData.TANGENT) {
				for (var i = 0; i < viewLength; i += count) {
					vert.setDirect(view[i + 0], view[i + 1], view[i + 2]);
					vert.applyPost(rotation);
					array[vertexPos + i + 0] = vert.x;
					array[vertexPos + i + 1] = vert.y;
					array[vertexPos + i + 2] = vert.z;
					array[vertexPos + i + 3] = view.w;
				}
			} else {
				for (var i = 0; i < viewLength; i++) {
					array[vertexPos + i] = view[i];
				}
			}
		}
		var indices = meshData.getIndexBuffer();
		for (var i = 0, l = meshData.indexCount; i < l; i++) {
			this.indexData[this.indexCounter + i] = indices[i] + this.vertexCounter;
		}
		this.vertexCounter += meshData.vertexCount;
		this.indexCounter += meshData.indexCount;

		if (meshData.indexLengths) {
			this.indexLengths = this.indexLengths.concat(meshData.indexLengths);
		} else {
			this.indexLengths = this.indexLengths.concat(meshData.getIndexBuffer().length);
		}

		this.indexModes = this.indexModes.concat(meshData.indexModes);
	};

	MeshBuilder.prototype._generateMesh = function () {
		var attributeMap = {};
		for (var key in this.vertexData) {
			var data = this.vertexData[key];
			attributeMap[key] = data.map;
		}

		var meshData = new MeshData(attributeMap, this.vertexCounter, this.indexCounter);
		for (var key in this.vertexData) {
			var data = this.vertexData[key].array;
			meshData.getAttributeBuffer(key).set(data);
		}
		meshData.getIndexBuffer().set(this.indexData);

		meshData.indexLengths = this.indexLengths;
		meshData.indexModes = this.indexModes;

		// Diet down the index arrays
		var indexMode = meshData.indexModes[0];
		var indexCount = 0;
		var indexModes = [];
		var indexLengths = [];
		for (var i = 0; i < meshData.indexModes.length; i++) {
			var mode = meshData.indexModes[i];
			if (indexMode !== mode) {
				indexModes.push(indexMode);
				indexLengths.push(indexCount);
				indexMode = mode;
				indexCount = 0;
			}
			indexCount += meshData.indexLengths[i];
			if (i === meshData.indexModes.length - 1) {
				indexModes.push(mode);
				indexLengths.push(indexCount);
				indexMode = mode;
				indexCount = 0;
			}
		}
		meshData.indexLengths = indexLengths;
		meshData.indexModes = indexModes;

		this.meshDatas.push(meshData);

		this.vertexData = {};
		this.indexData = [];
		this.vertexCounter = 0;
		this.indexCounter = 0;
		this.indexLengths = [];
		this.indexModes = [];
	};

	/**
	 * build the unified MeshData from all the added MeshData so far and then reset in the internal state.
	 * @returns {Array<MeshData>} array of meshData, but currently there will only be one entry so you can always use [0].
	 * In the future we might create multiple entries if we hit the 65536 vertices limit instead of throwing an error.
	 */
	MeshBuilder.prototype.build = function () {
		if (this.vertexCounter > 0) {
			this._generateMesh();
		}

		return this.meshDatas;
	};

	/**
	 * reset in the internal state.
	 */
	MeshBuilder.prototype.reset = function () {
		this.meshDatas = [];

		this.vertexData = {};
		this.indexData = [];
		this.vertexCounter = 0;
		this.indexCounter = 0;

		this.indexLengths = [];
		this.indexModes = [];
	};

	return MeshBuilder;
})(goo.MeshData,goo.Capabilities,goo.Vector3,goo.EntityUtils);
goo.Rc4Random = (function () {
	'use strict';

	/**
	 * Rc4 random generator with seeding
	 */
	function Rc4Random(seed) {
		var keySchedule = [];
		var keySchedule_i = 0;
		var keySchedule_j = 0;

		this.init = function (seed) {
			for (var i = 0; i < 256; i++) {
				keySchedule[i] = i;
			}

			var j = 0;
			for (var i = 0; i < 256; i++) {
				j = (j + keySchedule[i] + seed.charCodeAt(i % seed.length)) % 256;

				var t = keySchedule[i];
				keySchedule[i] = keySchedule[j];
				keySchedule[j] = t;
			}
		};
		this.init(seed);

		function getRandomByte() {
			keySchedule_i = (keySchedule_i + 1) % 256;
			keySchedule_j = (keySchedule_j + keySchedule[keySchedule_i]) % 256;

			var t = keySchedule[keySchedule_i];
			keySchedule[keySchedule_i] = keySchedule[keySchedule_j];
			keySchedule[keySchedule_j] = t;

			return keySchedule[(keySchedule[keySchedule_i] + keySchedule[keySchedule_j]) % 256];
		}

		this.getRandomNumber = function () {
			var number = 0;
			var multiplier = 1;
			for (var i = 0; i < 8; i++) {
				number += getRandomByte() * multiplier;
				multiplier *= 256;
			}
			return number / 18446744073709551616;
		};
	}

	return Rc4Random;
})();
goo.SoundCreator = (function (
	SoundHandler,
	AudioContext,
	Ajax,
	StringUtils,
	PromiseUtils
) {
	'use strict';

	/**
	 * Provides a simple way to load sounds
	 */
	function SoundCreator() {
		var ajax = this.ajax = new Ajax();

		this.soundHandler = new SoundHandler(
			{},
			function (ref, options) {
				return ajax.load(ref, options ? options.noCache : false);
			},
			function () {},
			function (ref, options) {
				return ajax.load(ref, options ? options.noCache : false);
			}
		);
	}

	/**
	 * Releases any references to cached objects
	 */
	SoundCreator.prototype.clear = function () {
		this.ajax.clear();
		this.soundHandler.clear();
	};

	/**
	 * Load a sound.
	 * @param  {string}   url
	 * @param  {Object}   settings
	 * @return {RSVP.Promise}
	 */
	SoundCreator.prototype.loadSound = function (url, settings) {
		if (!AudioContext.isSupported()) {
			return PromiseUtils.reject(new Error('AudioContext is not supported!'));
		}

		var id = StringUtils.createUniqueId('sound');
		settings = settings || {};
		settings.audioRefs = {};

		var fileExtension = StringUtils.getAfterLast(url, '.');
		settings.audioRefs[fileExtension] = url;

		var sound = this.soundHandler._create();
		this.soundHandler._objects.set(id, sound);

		return this.soundHandler.update(id, settings, {});
	};

	return SoundCreator;
})(goo.SoundHandler,goo.AudioContext,goo.Ajax,goo.StringUtils,goo.PromiseUtils);
goo.StringUtil = (function (StringUtils) {

	/**
	 * String-related utilities
	 * @target-class StringUtil StringUtil constructor
	 * @require-path goo/util/StringUtil
	 * @group util
	 * @deprecated Deprecated as of 0.14.x and scheduled for removal in 0.16.0; The class has been renamed to `goo/util/StringUtils`
	 */
	return StringUtils;
})(goo.StringUtils);
goo.TWEEN = (function () {
	'use strict';

	var TWEEN = (function () {

		var _tweens = [];

		return {

			REVISION: '10',

			getAll: function () {

				return _tweens;

			},

			removeAll: function () {

				_tweens = [];

			},

			add: function (tween) {

				_tweens.push(tween);

			},

			remove: function (tween) {

				var i = _tweens.indexOf(tween);

				if (i !== -1) {

					_tweens.splice(i, 1);

				}

			},

			update: function (time) {

				if (_tweens.length === 0) return false;

				var i = 0, numTweens = _tweens.length;

				time = time !== undefined ? time : ( window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now() );

				while (i < numTweens) {

					if (_tweens[i].update(time)) {

						i++;

					} else {

						_tweens.splice(i, 1);

						numTweens--;

					}

				}

				return true;

			}
		};

	})();

	TWEEN.Tween = function (object) {

		var _object = object;
		var _valuesStart = {};
		var _valuesEnd = {};
		var _valuesStartRepeat = {};
		var _duration = 1000;
		var _repeat = 0;
		var _delayTime = 0;
		var _startTime = null;
		var _easingFunction = TWEEN.Easing.Linear.None;
		var _interpolationFunction = TWEEN.Interpolation.Linear;
		var _chainedTweens = [];
		var _onStartCallback = null;
		var _onStartCallbackFired = false;
		var _onUpdateCallback = null;
		var _onCompleteCallback = null;

		// Set all starting values present on the target object
		for (var field in object) {

			_valuesStart[field] = parseFloat(object[field], 10);

		}

		this.from = function (object) {
			_object = object;

			for (var field in object) {
				_valuesStart[field] = parseFloat(object[field], 10);
			}

			return this;
		};

		this.to = function (properties, duration) {

			if (duration !== undefined) {

				_duration = duration;

			}

			_valuesEnd = properties;

			return this;

		};

		this.start = function (time) {

			TWEEN.add(this);

			_onStartCallbackFired = false;

			_startTime = time !== undefined ? time : (window.performance !== undefined && window.performance.now !== undefined ? window.performance.now() : Date.now() );
			_startTime += _delayTime;

			for (var property in _valuesEnd) {

				// check if an Array was provided as property value
				if (_valuesEnd[property] instanceof Array) {

					if (_valuesEnd[property].length === 0) {

						continue;

					}

					// create a local copy of the Array with the start value at the front
					_valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);

				}

				_valuesStart[property] = _object[property];

				if (( _valuesStart[property] instanceof Array ) === false) {
					_valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
				}

				_valuesStartRepeat[property] = _valuesStart[property] || 0;

			}

			return this;

		};

		this.stop = function () {

			TWEEN.remove(this);
			return this;

		};

		this.delay = function (amount) {

			_delayTime = amount;
			return this;

		};

		this.repeat = function (times) {

			_repeat = times;
			return this;

		};

		this.easing = function (easing) {

			_easingFunction = easing;
			return this;

		};

		this.interpolation = function (interpolation) {

			_interpolationFunction = interpolation;
			return this;

		};

		this.chain = function () {

			_chainedTweens = arguments;
			return this;

		};

		this.onStart = function (callback) {

			_onStartCallback = callback;
			return this;

		};

		this.onUpdate = function (callback) {

			_onUpdateCallback = callback;
			return this;

		};

		this.onComplete = function (callback) {

			_onCompleteCallback = callback;
			return this;

		};

		this.update = function (time) {

			if (time < _startTime) {

				return true;

			}

			if (_onStartCallbackFired === false) {

				if (_onStartCallback !== null) {

					_onStartCallback.call(_object);

				}

				_onStartCallbackFired = true;

			}

			var elapsed = ( time - _startTime ) / _duration;
			elapsed = elapsed > 1 ? 1 : elapsed;

			var value = _easingFunction(elapsed);

			for (var property in _valuesEnd) {

				var start = _valuesStart[property] || 0;
				var end = _valuesEnd[property];

				if (end instanceof Array) {

					_object[property] = _interpolationFunction(end, value);

				} else {

					if (typeof(end) === "string") {
						end = start + parseFloat(end, 10);
					}

					_object[property] = start + ( end - start ) * value;

				}

			}

			if (_onUpdateCallback !== null) {

				_onUpdateCallback.call(_object, value);

			}

			if (elapsed == 1) {

				if (_repeat > 0) {

					if (isFinite(_repeat)) {
						_repeat--;
					}

					// reassign starting values, restart by making startTime = now
					for (var property in _valuesStartRepeat) {

						if (typeof( _valuesEnd[property] ) === "string") {
							_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property], 10);
						}

						_valuesStart[property] = _valuesStartRepeat[property];

					}

					_startTime = time + _delayTime;

					return true;

				} else {

					if (_onCompleteCallback !== null) {

						_onCompleteCallback.call(_object);

					}

					for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {

						_chainedTweens[i].start(time);

					}

					return false;

				}

			}

			return true;

		};

	};

	TWEEN.Easing = {

		Linear: {

			None: function (k) {

				return k;

			}

		},

		Quadratic: {

			In: function (k) {

				return k * k;

			},

			Out: function (k) {

				return k * ( 2 - k );

			},

			InOut: function (k) {

				if (( k *= 2 ) < 1) return 0.5 * k * k;
				return -0.5 * ( --k * ( k - 2 ) - 1 );

			}

		},

		Cubic: {

			In: function (k) {

				return k * k * k;

			},

			Out: function (k) {

				return --k * k * k + 1;

			},

			InOut: function (k) {

				if (( k *= 2 ) < 1) return 0.5 * k * k * k;
				return 0.5 * ( ( k -= 2 ) * k * k + 2 );

			}

		},

		Quartic: {

			In: function (k) {

				return k * k * k * k;

			},

			Out: function (k) {

				return 1 - ( --k * k * k * k );

			},

			InOut: function (k) {

				if (( k *= 2 ) < 1) return 0.5 * k * k * k * k;
				return -0.5 * ( ( k -= 2 ) * k * k * k - 2 );

			}

		},

		Quintic: {

			In: function (k) {

				return k * k * k * k * k;

			},

			Out: function (k) {

				return --k * k * k * k * k + 1;

			},

			InOut: function (k) {

				if (( k *= 2 ) < 1) return 0.5 * k * k * k * k * k;
				return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );

			}

		},

		Sinusoidal: {

			In: function (k) {

				return 1 - Math.cos(k * Math.PI / 2);

			},

			Out: function (k) {

				return Math.sin(k * Math.PI / 2);

			},

			InOut: function (k) {

				return 0.5 * ( 1 - Math.cos(Math.PI * k) );

			}

		},

		Exponential: {

			In: function (k) {

				return k === 0 ? 0 : Math.pow(1024, k - 1);

			},

			Out: function (k) {

				return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);

			},

			InOut: function (k) {

				if (k === 0) return 0;
				if (k === 1) return 1;
				if (( k *= 2 ) < 1) return 0.5 * Math.pow(1024, k - 1);
				return 0.5 * ( -Math.pow(2, -10 * ( k - 1 )) + 2 );

			}

		},

		Circular: {

			In: function (k) {

				return 1 - Math.sqrt(1 - k * k);

			},

			Out: function (k) {

				return Math.sqrt(1 - ( --k * k ));

			},

			InOut: function (k) {

				if (( k *= 2 ) < 1) return -0.5 * ( Math.sqrt(1 - k * k) - 1);
				return 0.5 * ( Math.sqrt(1 - ( k -= 2) * k) + 1);

			}

		},

		Elastic: {

			In: function (k) {

				var s, a = 0.1, p = 0.4;
				if (k === 0) return 0;
				if (k === 1) return 1;
				if (!a || a < 1) {
					a = 1;
					s = p / 4;
				}
				else s = p * Math.asin(1 / a) / ( 2 * Math.PI );
				return -( a * Math.pow(2, 10 * ( k -= 1 )) * Math.sin(( k - s ) * ( 2 * Math.PI ) / p) );

			},

			Out: function (k) {

				var s, a = 0.1, p = 0.4;
				if (k === 0) return 0;
				if (k === 1) return 1;
				if (!a || a < 1) {
					a = 1;
					s = p / 4;
				}
				else s = p * Math.asin(1 / a) / ( 2 * Math.PI );
				return ( a * Math.pow(2, -10 * k) * Math.sin(( k - s ) * ( 2 * Math.PI ) / p) + 1 );

			},

			InOut: function (k) {

				var s, a = 0.1, p = 0.4;
				if (k === 0) return 0;
				if (k === 1) return 1;
				if (!a || a < 1) {
					a = 1;
					s = p / 4;
				}
				else s = p * Math.asin(1 / a) / ( 2 * Math.PI );
				if (( k *= 2 ) < 1) return -0.5 * ( a * Math.pow(2, 10 * ( k -= 1 )) * Math.sin(( k - s ) * ( 2 * Math.PI ) / p) );
				return a * Math.pow(2, -10 * ( k -= 1 )) * Math.sin(( k - s ) * ( 2 * Math.PI ) / p) * 0.5 + 1;

			}

		},

		Back: {

			In: function (k) {

				var s = 1.70158;
				return k * k * ( ( s + 1 ) * k - s );

			},

			Out: function (k) {

				var s = 1.70158;
				return --k * k * ( ( s + 1 ) * k + s ) + 1;

			},

			InOut: function (k) {

				var s = 1.70158 * 1.525;
				if (( k *= 2 ) < 1) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
				return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );

			}

		},

		Bounce: {

			In: function (k) {

				return 1 - TWEEN.Easing.Bounce.Out(1 - k);

			},

			Out: function (k) {

				if (k < ( 1 / 2.75 )) {

					return 7.5625 * k * k;

				} else if (k < ( 2 / 2.75 )) {

					return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;

				} else if (k < ( 2.5 / 2.75 )) {

					return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;

				} else {

					return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;

				}

			},

			InOut: function (k) {

				if (k < 0.5) return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
				return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;

			}

		}

	};

	TWEEN.Interpolation = {

		Linear: function (v, k) {

			var m = v.length - 1, f = m * k, i = Math.floor(f), fn = TWEEN.Interpolation.Utils.Linear;

			if (k < 0) return fn(v[0], v[1], f);
			if (k > 1) return fn(v[m], v[m - 1], m - f);

			return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);

		},

		Bezier: function (v, k) {

			var b = 0, n = v.length - 1, pw = Math.pow, bn = TWEEN.Interpolation.Utils.Bernstein, i;

			for (i = 0; i <= n; i++) {
				b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
			}

			return b;

		},

		CatmullRom: function (v, k) {

			var m = v.length - 1, f = m * k, i = Math.floor(f), fn = TWEEN.Interpolation.Utils.CatmullRom;

			if (v[0] === v[m]) {

				if (k < 0) i = Math.floor(f = m * ( 1 + k ));

				return fn(v[( i - 1 + m ) % m], v[i], v[( i + 1 ) % m], v[( i + 2 ) % m], f - i);

			} else {

				if (k < 0) return v[0] - ( fn(v[0], v[0], v[1], v[1], -f) - v[0] );
				if (k > 1) return v[m] - ( fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m] );

				return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);

			}

		},

		Utils: {

			Linear: function (p0, p1, t) {

				return ( p1 - p0 ) * t + p0;

			},

			Bernstein: function (n, i) {

				var fc = TWEEN.Interpolation.Utils.Factorial;
				return fc(n) / fc(i) / fc(n - i);

			},

			Factorial: (function () {

				var a = [1];

				return function (n) {

					var s = 1, i;
					if (a[n]) return a[n];
					for (i = n; i > 1; i--) s *= i;
					return a[n] = s;

				};

			})(),

			CatmullRom: function (p0, p1, p2, p3, t) {

				var v0 = ( p2 - p0 ) * 0.5, v1 = ( p3 - p1 ) * 0.5, t2 = t * t, t3 = t * t2;
				return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( -3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

			}

		}

	};

	window.TWEEN = TWEEN; // ask Martin, Ray

	return TWEEN;
})();
goo.CssTransformComponent = (function (
	Component
) {
	'use strict';

	/**
	 * Connects a domElement to an entity and applies the transformComponent of the entity to the domElement with CSS3 3D transforms.
	 * @param {domElement} domElement
	 * @param {boolean} faceCamera
	 * @extends Component
	 */
	function CssTransformComponent(domElement, faceCamera) {
		Component.apply(this, arguments);

		this.type = 'CssTransformComponent';

		/**
		 * DOM element.
		 */
		this.domElement = domElement;

		/**
		 * @type {number}
		 * @default 1
		 */
		this.scale = 1;

		/**
		 * @type {boolean}
		 */
		this.faceCamera = (typeof faceCamera === 'undefined') ? false : faceCamera;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	CssTransformComponent.type = 'CssTransformComponent';

	CssTransformComponent.prototype = Object.create(Component.prototype);
	CssTransformComponent.prototype.constructor = CssTransformComponent;

	return CssTransformComponent;
})(goo.Component);
goo.Dom3dComponent = (function (
	Component,
	Quad,
	MeshRendererComponent,
	MeshDataComponent
) {
	'use strict';

	/**
	 * Connects a domElement to an entity and applies the transforms of the entity to the domElement with CSS3 3D transforms.
	 * @param {domElement} domElement
	 * @param {Object} settings
	 * @extends Component
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/Dom3dComponent/Dom3dComponent-vtest.html Working example
	 */
	function Dom3dComponent(domElement, settings) {
		Component.apply(this, arguments);

		this.type = 'Dom3dComponent';

		settings = settings || {};

		/**
		 * @type {boolean}
		 */
		this.hidden = false;

		this.width = settings.width || 500;
		this.height = settings.height || 500;
		this.backfaceVisibility = settings.backfaceVisibility || 'hidden';

		this.updated = true;
		this.entity = null;
		this.initDom(domElement);

		this.meshData = new Quad(1, 1);
		this.meshDataComponent = new MeshDataComponent(this.meshData);
		this.meshRendererComponent = new MeshRendererComponent();

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	Dom3dComponent.type = 'Dom3dComponent';

	Dom3dComponent.prototype = Object.create(Component.prototype);
	Dom3dComponent.prototype.constructor = Dom3dComponent;

	Dom3dComponent.prototype.attached = function (entity) {
		entity.setComponent(this.meshDataComponent);
		entity.setComponent(this.meshRendererComponent);
	};

	Dom3dComponent.prototype.detached = function (entity) {
		if (this.domElement.parentNode !== null) {
			this.domElement.parentNode.removeChild(this.domElement);
		}
		entity.clearComponent('meshRendererComponent');
		entity.clearComponent('meshDataComponent');
	};

	Dom3dComponent.prototype.initDom = function (domElement) {
		if (this.domElement && this.domElement.parentNode !== null) {
			this.domElement.parentNode.removeChild(this.domElement);
		}
		this.domElement = document.createElement('div');
		if (domElement) {
			if (!domElement.style.width) {
				domElement.style.width = "100%";
			}
			if (!domElement.style.height) {
				domElement.style.height = "100%";
			}
			this.domElement.appendChild(domElement);
		}
		this.domElement.style.position = 'absolute';
		this.domElement.style.margin = '0px';
		this.domElement.style.padding = '0px';
		this.domElement.style.backgroundColor = 'white';
		// this.domElement.style.WebkitBackfaceVisibility = this.backfaceVisibility;
		this.domElement.style.backfaceVisibility = this.backfaceVisibility;
		this.domElement.style.overflow = 'hidden';
		this.setSize(this.width, this.height);
	};

	Dom3dComponent.prototype.setSize = function (width, height) {
		this.width = width || this.width;
		this.height = height || this.height;
		this.domElement.style.width = this.width + 'px';
		this.domElement.style.height = this.height + 'px';
	};

	Dom3dComponent.prototype.destroy = function (context) {
		this.meshData.destroy(context);
	};

	return Dom3dComponent;
})(goo.Component,goo.Quad,goo.MeshRendererComponent,goo.MeshDataComponent);
goo.MovementComponent = (function (
		Vector3,
		Component
		) {
		'use strict';

		/**
		 * Holds the movement parameters of an entity.
		 * Typically useful for anything which has a speed and/or
		 * rotation.
		 * @extends Component
		 */
		function MovementComponent() {
			Component.apply(this, arguments);

			this.type = 'MovementComponent';
			this.velocity = new Vector3();
			this.rotationVelocity = new Vector3();

			// #ifdef DEBUG
			Object.seal(this);
			// #endif
		}

		MovementComponent.type = 'MovementComponent';

		MovementComponent.prototype = Object.create(Component.prototype);
		MovementComponent.prototype.constructor = MovementComponent;

		/**
		 * Adds velocity to movement. Typically useful for things such as gravity and slingshots.
		 * @param {Vector3} vec3 velocity impulse vector.
		 */
		MovementComponent.prototype.addVelocity = function (vec3) {
			this.velocity.add(vec3);
		};

		/**
		 * Adds velocity to movement. Typically useful for things such as gravity and slingshots.
		 * @param {Vector3} vec3 velocity impulse vector.
		 */

		MovementComponent.prototype.setVelocity = function (vec3) {
			this.velocity.set(vec3);
		};

		/**
		 * Reads the movement velocity vector
		 * @returns {Vector3} velocity vector
		 */

		MovementComponent.prototype.getVelocity = function () {
			return this.velocity;
		};

		/**
		 * Adds rotational velocity to movement. Typically useful for spinning or turning things.
		 * @param {Vector3} vec3 rotational velocity impulse vector.
		 */

		MovementComponent.prototype.addRotationVelocity = function (vec3) {
			this.rotationVelocity.add(vec3);
		};
		/**
		 * Sets rotational velocity of the movement.
		 * @param {Vector3} vec3 rotational velocity vector.
		 */

		MovementComponent.prototype.setRotationVelocity = function (vec3) {
			this.rotationVelocity.set(vec3);
		};

		/**
		 * Read the rotational velocity of movement
		 * @returns {Vector3} the rotational velocity
		 */

		MovementComponent.prototype.getRotationVelocity = function () {
			return this.rotationVelocity;
		};

		return MovementComponent;
	})(goo.Vector3,goo.Component);
goo.PortalComponent = (function (
	Component,
	RenderTarget
) {
	'use strict';

	/**
	 * Renders to the texture of the host object<br>
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/PortalComponent/PortalComponent-vtest.html Working example
	 * @param {Camera} camera The camera used for rendering
	 * @param {number} [height=200] Height of the texture to render to (the width is calculated automatically from the camera's aspect ratio)
	 * @param {Object} options
	 * @param {boolean} [options.autoUpdate=true] If set to true then updating is done every frame, otherwise updating is done only when solicited via the `requestUpdate` method
	 * @param {boolean} [options.alwaysRender=false] By default the rendering done on the material is disabled if the host object is culled.
	 * @param {boolean} [options.preciseRecursion=false] By default the "portal depth" (the number of portals seen through a portal) is of 4. By enabling this option the limitation disappears, but at the cost of using more memory.
	 * @param {Material} [overrideMaterial=null] Optional override material to use when rendering to the host object
	 * @extends Component
	 */
	function PortalComponent(camera, height, options, overrideMaterial) {
		Component.apply(this, arguments);

		height = height || 200;

		this.options = options || {};
		this.options.preciseRecursion = !!this.options.preciseRecursion;
		this.options.autoUpdate = this.options.autoUpdate !== false;
		this.options.alwaysRender = !!this.options.alwaysRender;

		this.overrideMaterial = overrideMaterial;

		this.doUpdate = true;

		var aspect = camera.aspect;

		this.type = 'PortalComponent';

		/**
		 * @type {Camera}
		 */
		this.camera = camera;

		/**
		 * @type {RenderTarget}
		 */
		this.target = new RenderTarget(height, height / aspect);

		if (this.options.preciseRecursion) {
			this.secondaryTarget = new RenderTarget(height, height / aspect);
		}

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	PortalComponent.type = 'PortalComponent';

	PortalComponent.prototype = Object.create(Component.prototype);
	PortalComponent.prototype.constructor = PortalComponent;

	/**
	 * Requests a rendering to be done to the material of the host object
	 */
	PortalComponent.prototype.requestUpdate = function () {
		this.doUpdate = true;
	};

	return PortalComponent;
})(goo.Component,goo.RenderTarget);
goo.TextComponent = (function (
	Component
) {
	'use strict';

	/**
	 * Provides ways for the entity to display text
	 * @extends Component
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/TextComponent/TextComponent-vtest.html Working example
	 */
	function TextComponent(text) {
		Component.apply(this, arguments);

		this.type = 'TextComponent';

		this.text = text || '';
		this.dirty = true;

		// #ifdef DEBUG
		Object.seal(this);
		// #endif
	}

	TextComponent.type = 'TextComponent';

	TextComponent.prototype = Object.create(Component.prototype);
	TextComponent.prototype.constructor = TextComponent;

	/**
	 * Text to update to
	 * @param {string} text
	 * @returns {TextComponent} Self for chaining
	 */
	TextComponent.prototype.setText = function (text) {
		this.text = text;
		this.dirty = true;
		return this;
	};

	return TextComponent;
})(goo.Component,goo.TextureGrid,goo.MeshDataComponent);
goo.CssTransformSystem = (function (
	System,
	Renderer,
	Matrix4,
	MathUtils,
	Vector3
) {
	'use strict';

	/**
	 * @extends System
	 */
	function CssTransformSystem(renderer) {
		System.call(this, 'CssTransformSystem', ['TransformComponent', 'CssTransformComponent']);

		this.renderer = renderer;

		if (document.querySelector) {
			this.viewDom = document.querySelector('#view');
			this.containerDom = document.querySelector('#cam1');
			this.containerDom2 = document.querySelector('#cam2');
		}
	}

	var tmpMatrix = new Matrix4();
	var tmpMatrix2 = new Matrix4();
	var tmpVector = new Vector3();

	CssTransformSystem.prototype = Object.create(System.prototype);
	CssTransformSystem.prototype.constructor = CssTransformSystem;

	var epsilon = function (value) {
		return Math.abs(value) < 0.000001 ? 0 : value;
	};

	var prefixes = ['', '-webkit-', '-moz-', '-ms-', '-o-'];
	var setStyle = function (element, property, style) {
		for (var j = 0; j < prefixes.length; j++) {
			element.style[prefixes[j] + property] = style;
		}
	};

	var getCSSMatrix = function (matrix) {
		var elements = matrix.data;


		return 'matrix3d(' + epsilon(elements[0]) + ',' + epsilon(-elements[1]) + ',' + epsilon(elements[2]) + ',' + epsilon(elements[3]) + ','
			+ epsilon(elements[4]) + ',' + epsilon(-elements[5]) + ',' + epsilon(elements[6]) + ',' + epsilon(elements[7]) + ','
			+ epsilon(elements[8]) + ',' + epsilon(-elements[9]) + ',' + epsilon(elements[10]) + ',' + epsilon(elements[11]) + ','
			+ epsilon(elements[12]) + ',' + epsilon(-elements[13]) + ',' + epsilon(elements[14]) + ',' + epsilon(elements[15]) + ')';
	};

	CssTransformSystem.prototype.process = function (entities) {
		if (entities.length === 0) {
			return;
		}

		var camera = Renderer.mainCamera;

		if (!camera) {
			return;
		}

		var fov = 0.5 / Math.tan(MathUtils.DEG_TO_RAD * camera.fov * 0.5) * this.renderer.domElement.offsetHeight;
		setStyle(this.viewDom, 'perspective', fov + 'px');

		tmpMatrix.copy(camera.getViewInverseMatrix());
		tmpMatrix2.copy(tmpMatrix);
		tmpMatrix.invert();

		tmpMatrix.setTranslation(new Vector3(0, 0, fov));
		var style = getCSSMatrix(tmpMatrix);
		setStyle(this.containerDom, 'transform', style);

		tmpMatrix2.e03 = -tmpMatrix2.e03;
		// tmpMatrix2.e13 = -tmpMatrix2.e13;
		tmpMatrix2.e23 = -tmpMatrix2.e23;

		// Needed?
		tmpMatrix2.data[0] = 1;
		tmpMatrix2.data[1] = 0;
		tmpMatrix2.data[2] = 0;

		tmpMatrix2.data[4] = 0;
		tmpMatrix2.data[5] = 1;
		tmpMatrix2.data[6] = 0;

		tmpMatrix2.data[8] = 0;
		tmpMatrix2.data[9] = 0;
		tmpMatrix2.data[10] = 1;

		style = getCSSMatrix(tmpMatrix2);
		setStyle(this.containerDom2, 'transform', style);

		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			var component = entity.getComponent('CssTransformComponent');
			var domElement = component.domElement;
			var scale = component.scale;
			scale = [scale, -scale, scale].join(',');

			if (component.faceCamera) {
				entity.transformComponent.worldTransform.matrix.getTranslation(tmpVector);
				tmpMatrix.copy(camera.getViewInverseMatrix());
				tmpMatrix.setTranslation(tmpVector);
			} else {
				tmpMatrix.copy(entity.transformComponent.worldTransform.matrix);
			}

			style = 'translate3d(-50%,-50%,0) ' + getCSSMatrix(tmpMatrix) + 'scale3d(' + scale + ')';
			setStyle(domElement, 'transform', style);

			if (domElement.parentNode !== this.containerDom2) {
				this.containerDom2.appendChild(domElement);
			}
		}
	};

	return CssTransformSystem;
})(goo.System,goo.Renderer,goo.Matrix4,goo.MathUtils,goo.Vector3);
goo.Dom3dSystem = (function (
	System,
	SystemBus,
	Renderer,
	Material,
	ShaderLib,
	Quad,
	Matrix4x4,
	Vector3,
	Ray,
	MathUtils
) {
	'use strict';

	/**
	 * @extends System
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/Dom3dComponent/Dom3dComponent-vtest.html Working example
	 */
	function Dom3dSystem(renderer) {
		System.call(this, 'Dom3dSystem', ['TransformComponent', 'Dom3dComponent']);

		this.renderer = renderer;
		this.camera = null;

		SystemBus.addListener('goo.setCurrentCamera', function (newCam) {
			this.camera = newCam.camera;
		}.bind(this), true);

		this.playing = true;

		var frontMaterial = new Material(ShaderLib.simple);
		frontMaterial.blendState.blending = 'CustomBlending';
		frontMaterial.blendState.blendSrc = 'ZeroFactor';
		frontMaterial.blendState.blendDst = 'ZeroFactor';

		var backMaterial = new Material(ShaderLib.uber);
		backMaterial.uniforms.materialDiffuse = [0.5, 0.5, 0.5, 1];
		backMaterial.cullState.cullFace = 'Front';

		this.materials = [frontMaterial, backMaterial];

		// this.prefixes = ['', '-webkit-', '-moz-'];
		this.prefixes = ['', '-webkit-'];
		this.styleCache = new Map();

		this.precisionScale = 1000; // Thanks browsers
	}

	Dom3dSystem.prototype = Object.create(System.prototype);
	Dom3dSystem.prototype.constructor = Dom3dSystem;

	Dom3dSystem.prototype.init = function () {
		var ray = new Ray();
		var polygonVertices = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];
		var offsets = [new Vector3(-0.5, -0.5, 0), new Vector3(-0.5, 0.5, 0), new Vector3(0.5, 0.5, 0), new Vector3(0.5, -0.5, 0)];
		var doPlanar = false;

		var doesIntersect = false;

		var that = this;
		var doPick = function (event) {
			var x, y;
			var domTarget = that.renderer.domElement;
			if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
				x = event.changedTouches[0].pageX - domTarget.getBoundingClientRect().left;
				y = event.changedTouches[0].pageY - domTarget.getBoundingClientRect().top;
			} else {
				var rect = domTarget.getBoundingClientRect();
				x = event.clientX - rect.left;
				y = event.clientY - rect.top;
			}

			that.camera.getPickRay(x, y, that.renderer.domElement.offsetWidth, that.renderer.domElement.offsetHeight, ray);

			for (var i = 0; i < that._activeEntities.length; i++) {
				var entity = that._activeEntities[i];

				for (var j = 0; j < polygonVertices.length; j++) {
					var vec = polygonVertices[j];
					vec.set(offsets[j]);
					vec.applyPostPoint(entity.transformComponent.worldTransform.matrix);
				}

				if (ray.intersects(polygonVertices, doPlanar, null, true)) {
					return true;
				}
			}

			return false;
		};

		var handlePick = function (event) {
			if (!that.camera || that._activeEntities.length === 0) {
				return false;
			}

			var intersects = doPick(event);

			if (intersects && !doesIntersect) {
				SystemBus.emit('goo.dom3d.enabled', true);
				that.renderer.domElement.style.pointerEvents = 'none';
				doesIntersect = true;
			} else if (!intersects && doesIntersect) {
				SystemBus.emit('goo.dom3d.enabled', false);
				that.renderer.domElement.style.pointerEvents = '';
				doesIntersect = false;
			}
		};

		var drag = false;
		document.addEventListener('mousedown', function (event) {
			if (!that.camera || that._activeEntities.length === 0) {
				return;
			}

			drag = !doPick(event);
		}, false);
		document.addEventListener('mouseup', function (event) {
			if (!that.camera || that._activeEntities.length === 0) {
				return;
			}

			drag = false;

			if (that.playing) {
				handlePick(event);
			}
		}, false);
		document.addEventListener('mousemove', function (event) {
			if (drag || !that.camera || that._activeEntities.length === 0) {
				return;
			}

			if (that.playing) {
				handlePick(event);
			}
		}, false);

		var rootDom = this.rootDom = document.createElement('div');
		this.renderer.domElement.parentNode.insertBefore(rootDom, this.renderer.domElement);

		rootDom.style.position = 'absolute';
		rootDom.style.overflow = 'hidden';
		rootDom.style.webkitUserSelect = 'none';
		rootDom.style.mozUserSelect = 'none';
		rootDom.style.msUserSelect = 'none';
		// rootDom.style.webkitTransformStyle = 'preserve-3d';
		// rootDom.style.mozTransformStyle = 'preserve-3d';
		rootDom.style.transformStyle = 'preserve-3d';
		rootDom.style.width = '100%';
		rootDom.style.height = '100%';
		rootDom.style.top = '0px';
		rootDom.style.bottom = '0px';
		rootDom.style.left = '0px';
		rootDom.style.right = '0px';

		var cameraDom = this.cameraDom = document.createElement('div');
		cameraDom.style.webkitUserSelect = 'none';
		cameraDom.style.mozUserSelect = 'none';
		cameraDom.style.msUserSelect = 'none';
		// cameraDom.style.webkitTransformStyle = 'preserve-3d';
		// cameraDom.style.mozTransformStyle = 'preserve-3d';
		cameraDom.style.transformStyle = 'preserve-3d';
		cameraDom.style.width = '100%';
		cameraDom.style.height = '100%';

		rootDom.appendChild(cameraDom);
	};

	Dom3dSystem.prototype.play = function () {
		this.playing = true;
	};

	Dom3dSystem.prototype.pause = function () {
	};

	Dom3dSystem.prototype.resume = Dom3dSystem.prototype.play;

	Dom3dSystem.prototype.stop = function () {
		this.playing = false;

		SystemBus.emit('goo.dom3d.enabled', false);
		if (this.renderer.domElement) {
			this.renderer.domElement.style.pointerEvents = '';
		}
	};

	Dom3dSystem.prototype.getCameraCSSMatrix = function (matrix) {
		var elements = matrix.data;

		return 'matrix3d('
			+ elements[0] + ',' + (-elements[1]) + ',' + elements[2] + ',' + elements[3] + ','
			+ elements[4] + ',' + (-elements[5]) + ',' + elements[6] + ',' + elements[7] + ','
			+ elements[8] + ',' + (-elements[9]) + ',' + elements[10] + ',' + elements[11] + ','
			+ elements[12] * this.precisionScale + ',' + (-elements[13]) * this.precisionScale + ',' + elements[14] * this.precisionScale + ',' + elements[15] + ')';
	};

	Dom3dSystem.prototype.getEntityCSSMatrix = function (matrix) {
		var elements = matrix.data;

		return 'translate3d(-50%,-50%,0) matrix3d('
			+ elements[0] + ',' + elements[1] + ',' + elements[2] + ',' + elements[3] + ','
			+ (-elements[4]) + ',' + (-elements[5]) + ',' + (-elements[6]) + ',' + (-elements[7]) + ','
			+ elements[8] + ',' + elements[9] + ',' + elements[10] + ',' + elements[11] + ','
			+ elements[12] * this.precisionScale + ',' + elements[13] * this.precisionScale + ',' + elements[14] * this.precisionScale + ',' + elements[15] + ')';
	};

	Dom3dSystem.prototype.setStyle = function (element, property, style) {
		var cachedStyle = this.styleCache.get(element);

		if (style !== cachedStyle) {
			for (var j = 0; j < this.prefixes.length; j++) {
				element.style[this.prefixes[j] + property] = style;
			}
			this.styleCache.set(element, style);
		}
	};

	Dom3dSystem.prototype.inserted = function (entity) {
		var component = entity.dom3dComponent;
		component.meshRendererComponent.materials = this.materials;
	};

	Dom3dSystem.prototype.process = function (entities) {
		var camera = this.camera;
		if (!camera || entities.length === 0) {
			return;
		}

		// lazy init
		if (this.renderer.domElement.parentNode && !this.rootDom) {
			this.init();
		}

		var width = this.renderer.viewportWidth / this.renderer.devicePixelRatio;
		var height = this.renderer.viewportHeight / this.renderer.devicePixelRatio;
		var fov = 0.5 / Math.tan(MathUtils.DEG_TO_RAD * camera.fov * 0.5) * height;

		this.setStyle(this.rootDom, 'perspective', fov + 'px');

		var viewMatrix = camera.getViewMatrix();
		var style = 'translate3d(0,0,' + fov + 'px) ' +
				this.getCameraCSSMatrix(viewMatrix) +
				' translate3d(' + (width / 2) + 'px,' + (height / 2) + 'px, 0)';
		this.setStyle(this.cameraDom, 'transform', style);

		for (var i = 0, l = entities.length; i < l; i++) {
			var entity = entities[i];
			var component = entity.dom3dComponent;
			var domElement = component.domElement;

			if (domElement.parentNode !== this.cameraDom) {
				this.cameraDom.appendChild(domElement);
			}

			// Do we really have to set this every time?
			if (component.hidden) {
				component.domElement.style.display = 'none';
				continue;
			} else {
				component.domElement.style.display = '';
			}

			if (!component.updated && !entity.transformComponent._updated) {
				continue;
			}
			component.updated = false;

			var worldTransform = entity.transformComponent.worldTransform;
			style = this.getEntityCSSMatrix(worldTransform.matrix) +
					' scale(' + this.precisionScale / component.width +
					', ' + this.precisionScale / component.height + ')';
			this.setStyle(domElement, 'transform', style);
		}
	};

	Dom3dSystem.prototype.cleanup = function () {
		System.prototype.cleanup.apply(this, arguments);

		if (this.rootDom.parentNode !== null) {
			this.rootDom.parentNode.removeChild(this.rootDom);
		}
	};

	return Dom3dSystem;
})(goo.System,goo.SystemBus,goo.Renderer,goo.Material,goo.ShaderLib,goo.Quad,goo.Matrix4x4,goo.Vector3,goo.Ray,goo.MathUtils);
goo.HtmlSystem = (function (
	System,
	Renderer,
	Matrix4,
	MathUtils,
	Vector3
) {
	'use strict';

	/**
	 * @extends System
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/HTMLComponent/HTMLComponent-vtest.html Working example
	 */
	function HtmlSystem(renderer) {
		System.call(this, 'HtmlSystem', ['TransformComponent', 'HtmlComponent']);
		this.renderer = renderer;

		// this.prefixes = ['', '-webkit-', '-moz-', '-ms-', '-o-'];
		this.prefixes = ['', '-webkit-'];
		this.styleCache = new Map();
	}

	HtmlSystem.prototype = Object.create(System.prototype);
	HtmlSystem.prototype.constructor = HtmlSystem;

	// Browsers implement z-index as signed 32bit int.
	// Overflowing pushes the element to the back.
	var MAX_Z_INDEX = 2147483647;
	var tmpVector = new Vector3();

	// Copied from CSSTransformComponent
	HtmlSystem.prototype.setStyle = function (element, property, style) {
		var cachedStyle = this.styleCache.get(element);

		if (style !== cachedStyle) {
			for (var j = 0; j < this.prefixes.length; j++) {
				element.style[this.prefixes[j] + property] = style;
			}
			this.styleCache.set(element, style);
		}
	};

	HtmlSystem.prototype.process = function (entities) {
		if (entities.length === 0) {
			return;
		}

		var camera = Renderer.mainCamera;
		var screenWidth = this.renderer.domElement.width;
		var screenHeight = this.renderer.domElement.height;

		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			var component = entity.htmlComponent;

			// Always show if not using transform (if not hidden)
			if (!component.useTransformComponent) {
				component.domElement.style.display = component.hidden ? 'none' : '';
				this.setStyle(component.domElement, 'transform', '');
				continue;
			}

			// Hidden
			if (component.hidden) {
				component.domElement.style.display = 'none';
				continue;
			}

			// Behind camera
			tmpVector.set(camera.translation)
				.sub(entity.transformComponent.worldTransform.translation);
			if (camera._direction.dot(tmpVector) > 0) {
				component.domElement.style.display = 'none';
				continue;
			}

			// compute world position.
			camera.getScreenCoordinates(entity.transformComponent.worldTransform.translation, screenWidth, screenHeight, tmpVector);
			// Behind near plane
			if (tmpVector.z < 0) {
				if (component.hidden !== true) {
					component.domElement.style.display = 'none';
					//component.hidden = true;
				}
				continue;
			}
			// Else visible
			component.domElement.style.display = '';

			var renderer = this.renderer;
			var devicePixelRatio = renderer._useDevicePixelRatio && window.devicePixelRatio ? window.devicePixelRatio / renderer.svg.currentScale : 1;
			var fx = Math.floor(tmpVector.x / devicePixelRatio);
			var fy = Math.floor(tmpVector.y / devicePixelRatio);

			this.setStyle(component.domElement, 'transform',
				'translate(-50%, -50%) ' +
				'translate(' + fx + 'px, ' + fy + 'px)' +
				'translate(' + renderer.domElement.offsetLeft + 'px, ' + renderer.domElement.offsetTop + 'px)');

			component.domElement.style.zIndex = MAX_Z_INDEX - Math.round(tmpVector.z * MAX_Z_INDEX);
		}
	};

	HtmlSystem.prototype.deleted = function (entity) {
		if (!entity || !entity.htmlComponent) {
			return;
		}

		var component = entity.htmlComponent;

		if (component.domElement.parentNode) {
			component.domElement.parentNode.removeChild(component.domElement);
		}

		component.domElement = null;
	};

	return HtmlSystem;
})(goo.System,goo.Renderer,goo.Matrix4,goo.MathUtils,goo.Vector3);
goo.MovementSystem = (function (
	System
) {
	'use strict';

	//! AT: unused; should be removed
	/**
	 * Processes all entities with movement components.
	 * This system applies movement vectors for translation and rotation
	 * to the transform of the entity which has it every frame.
	 * @extends System
	 */
	function MovementSystem() {
		System.call(this, 'MovementSystem', ['MovementComponent']);
	}

	MovementSystem.prototype = Object.create(System.prototype);
	MovementSystem.prototype.constructor = MovementSystem;

	MovementSystem.prototype.addVelocityToTransform = function (vel, transform, tpf) {
		transform.translation.addDirect(vel.x * tpf, vel.y * tpf, vel.z * tpf);
	};

	MovementSystem.prototype.addRotToTransform = function (rotVel, transform, tpf) {
		transform.rotation.rotateX(rotVel.x * tpf);
		transform.rotation.rotateY(rotVel.y * tpf);
		transform.rotation.rotateZ(rotVel.z * tpf);
	};

	MovementSystem.prototype.applyMovementToEntity = function (entity) {
		var tpf = entity._world.tpf;
		var rotVel = entity.movementComponent.getRotationVelocity();
		var velocity = entity.movementComponent.getVelocity();
		var transform = entity.transformComponent.transform;
		this.addVelocityToTransform(velocity, transform, tpf);
		this.addRotToTransform(rotVel, transform, tpf);
		entity.transformComponent.setUpdated();
	};

	MovementSystem.prototype.process = function (entities) {
		for (var i = 0; i < entities.length; i++) {
			this.applyMovementToEntity(entities[i]);
		}
	};

	return MovementSystem;
})(goo.System);
goo.PickingSystem = (function (System) {
	'use strict';

	/**
	 * Helps gather pickable entities
	 * @extends System
	 */
	function PickingSystem (settings) {
		System.call(this, 'PickingSystem', ['MeshRendererComponent', 'TransformComponent']);
		this.passive = true;
		this.pickRay = null;
		this.onPick = null;

		settings = settings || {};

		this.setPickLogic(settings.pickLogic || null);
	}

	PickingSystem.prototype = Object.create(System.prototype);
	PickingSystem.prototype.constructor = PickingSystem;

	PickingSystem.prototype.setPickLogic = function (pickLogic) {
		this.pickLogic = pickLogic;
		if (pickLogic) {
			if (this.interests.indexOf('MeshDataComponent') === -1) {
				this.interests.push('MeshDataComponent');
			}
		}
	};

	PickingSystem.prototype.inserted = function (entity) {
		if (entity.meshRendererComponent.isPickable && this.pickLogic) {
			this.pickLogic.added(entity);
		}
	};

	PickingSystem.prototype.deleted = function (entity) {
		if (this.pickLogic) {
			this.pickLogic.removed(entity);
		}
	};

	PickingSystem.prototype.process = function (entities) {
		if (!this.pickRay || !this.onPick) {
			return;
		}
		var pickList = [];
		for ( var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			var meshRendererComponent = entity.meshRendererComponent;

			if (!meshRendererComponent.isPickable) {
				continue;
			}

			// If we have custom pickLogic, use that.
			if (this.pickLogic) {
				if (!this.pickLogic.isConstructed(entity)) {
					this.pickLogic.added(entity);
				}

				var result = this.pickLogic.getPickResult(this.pickRay, entity);
				if (result && result.distances && result.distances.length) {
					pickList.push({
						'entity': entity,
						'intersection': result
					});
				}
			}

			// just use bounding pick instead... first must have a world bound
			else if (meshRendererComponent.worldBound) {
				// pick ray must intersect world bound
				var result = meshRendererComponent.worldBound.intersectsRayWhere(this.pickRay);
				if (result && result.distances.length) {
					pickList.push({
						'entity': entity,
						'intersection': result
					});
				}
			}
		}

		pickList.sort(function (a, b) {
			return a.intersection.distances[0] - b.intersection.distances[0];
		});

		this.onPick(pickList);
	};

	return PickingSystem;
})(goo.System);
goo.PortalSystem = (function (
	System
) {
	'use strict';

	/**
	 * Processes all entities with a portal component, a mesh renderer component and a mesh data component
	 * @extends System
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/PortalComponent/PortalComponent-vtest.html Working example
	 * @param {Renderer} renderer
	 * @param {RenderSystem} renderSystem
	 */
	function PortalSystem(renderer, renderSystem) {
		System.call(this, 'PortalSystem', ['MeshRendererComponent', 'MeshDataComponent', 'PortalComponent']);

		this.renderer = renderer;
		this.renderSystem = renderSystem;

		this.renderList = [];
	}

	PortalSystem.prototype = Object.create(System.prototype);
	PortalSystem.prototype.constructor = PortalSystem;

	PortalSystem.prototype.process = function (entities) {
		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			var portalComponent = entity.portalComponent;

			if (portalComponent.options.autoUpdate || portalComponent.doUpdate) {
				portalComponent.doUpdate = false;

				var camera = portalComponent.camera;
				var target = portalComponent.target;
				var secondaryTarget = portalComponent.secondaryTarget;
				var overrideMaterial = portalComponent.overrideMaterial;

				if (portalComponent.alwaysRender || entity.isVisible) {
					this.render(this.renderer, camera, target, overrideMaterial);

					var material = entity.meshRendererComponent.materials[0];
					material.setTexture('DIFFUSE_MAP', target);

					if (portalComponent.options.preciseRecursion) {
						var tmp = target;
						portalComponent.target = secondaryTarget;
						portalComponent.secondaryTarget = tmp;
					}
				}
			}
		}
	};

	PortalSystem.prototype.render = function (renderer, camera, target, overrideMaterial) {
		renderer.updateShadows(this.renderSystem.partitioner, this.renderSystem.entities, this.renderSystem.lights);

		for (var i = 0; i < this.renderSystem.preRenderers.length; i++) {
			var preRenderer = this.renderSystem.preRenderers[i];
			preRenderer.process(renderer, this.renderSystem.entities, this.renderSystem.partitioner, camera, this.renderSystem.lights);
		}

		this.renderSystem.partitioner.process(camera, this.renderSystem.entities, this.renderList);

		if (this.renderSystem.composers.length > 0) {
			for (var i = 0; i < this.renderSystem.composers.length; i++) {
				var composer = this.renderSystem.composers[i];
				composer.render(renderer, this.renderSystem.currentTpf, camera, this.renderSystem.lights, null, true);
			}
		} else {
			renderer.render(this.renderList, camera, this.renderSystem.lights, target, true, overrideMaterial);
		}
	};

	return PortalSystem;
})(goo.System);
goo.GridRenderSystem = (function (
	System,
	SystemBus,
	SimplePartitioner,
	MeshData,
	Material,
	Shader,
	ShaderLib,
	ObjectUtils,
	Transform,
	MathUtils,
	Grid
) {
	'use strict';

	/**
	 * Renders entities/renderables using a configurable partitioner for culling
	 * @property {boolean} doRender Only render if set to true
	 * @extends System
	 */
	function GridRenderSystem() {
		System.call(this, 'GridRenderSystem', []);

		this.renderList = [];
		this.doRender = {
			grid: true
		};

		this.scale = 62.5;
		this.count = 100;

		this.camera = null;
		this.lights = [];
		this.transform1 = new Transform();
		this.transform1.rotation.rotateX(-Math.PI / 2);
		this.transform1.scale.setDirect(this.scale, this.scale, this.scale);
		this.transform1.update();

		this.transform2 = new Transform();
		this.transform2.rotation.rotateX(-Math.PI / 2);
		this.transform2.scale.setDirect(this.scale, this.scale, this.scale);
		this.transform2.update();

		var col = 0.2;
		var gridMaterial1 = new Material(gridShaderDef, 'Grid Material');
		gridMaterial1.blendState.blending = 'TransparencyBlending';
		gridMaterial1.uniforms.color = [col, col, col, 1];
		gridMaterial1.depthState.write = false;
		gridMaterial1.depthState.enabled = true;
		var gridMaterial2 = new Material(gridShaderDef, 'Grid Material');
		gridMaterial2.blendState.blending = 'TransparencyBlending';
		gridMaterial2.uniforms.color = [col, col, col, 1];
		gridMaterial2.depthState.write = false;
		gridMaterial2.depthState.enabled = true;

		var gridMesh = new Grid(this.count, this.count);
		this.grid1 = {
			meshData: gridMesh,
			materials: [gridMaterial1],
			transform: this.transform1
		};
		this.grid2 = {
			meshData: gridMesh,
			materials: [gridMaterial2],
			transform: this.transform2
		};

		this.oldHeightScale1 = 0;
		this.oldX1 = 0;
		this.oldZ1 = 0;
		this.oldHeightScale1 = 0;
		this.oldX1 = 0;
		this.oldZ1 = 0;

		// stop using this pattern - use instead .bind()
		var that = this;
		SystemBus.addListener('goo.setCurrentCamera', function (newCam) {
			that.camera = newCam.camera;
		});

		SystemBus.addListener('goo.setLights', function (lights) {
			that.lights = lights;
		});
	}

	GridRenderSystem.prototype = Object.create(System.prototype);
	GridRenderSystem.prototype.constructor = GridRenderSystem;

	GridRenderSystem.prototype.inserted = function (/*entity*/) {};

	GridRenderSystem.prototype.deleted = function (/*entity*/) {};

	function smoothstep(t, level) {
		for (var i = 0; i < level; ++i) {
			t = Math.pow(t, 2) * (3 - 2 * t);
		}
		return t;
	}

	GridRenderSystem.prototype.process = function (/*entities, tpf*/) {
		if (!this.doRender.grid) {
			return;
		}

		var y = Math.max(Math.abs(this.camera.translation.y) / 10, 0);

		var y1 = Math.pow(y, 0.15);
		var blender1 = 1 - Math.abs(y1 - Math.floor(y1) - 0.5) * 2;
		blender1 = Math.min(blender1 * 2, 1);
		var heightScale1 = Math.pow(2, Math.floor(y1) * 4 + 2) * this.scale;

		var y2 = Math.pow(y, 0.15) + 0.5;
		var blender2 = 1 - Math.abs(y2 - Math.floor(y2) - 0.5) * 2;
		blender2 = Math.min(blender2 * 2, 1);
		var heightScale2 = Math.pow(2, Math.floor(y2) * 4) * this.scale;

		blender1 = smoothstep(blender1, 1);
		blender2 = smoothstep(blender2, 1);

		this.grid1.materials[0].uniforms.scale = heightScale1;
		this.grid1.materials[0].uniforms.opacity = blender1;

		this.grid2.materials[0].uniforms.scale = heightScale2;
		this.grid2.materials[0].uniforms.opacity = blender2;

		var x = Math.floor(this.camera.translation.x * this.count / heightScale1);
		var z = Math.floor(this.camera.translation.z * this.count / heightScale1);
		if (heightScale1 !== this.oldHeightScale1 || x !== this.oldX1 || z !== this.oldZ1) {
			this.transform1.scale.setDirect(heightScale1, heightScale1, heightScale1);
			this.transform1.translation.x = x * heightScale1 / this.count;
			this.transform1.translation.z = z * heightScale1 / this.count;
			this.transform1.update();

			this.oldX1 = x;
			this.oldZ1 = z;
			this.oldHeightScale1 = heightScale1;
		}

		x = Math.floor(this.camera.translation.x * this.count / heightScale2);
		z = Math.floor(this.camera.translation.z * this.count / heightScale2);
		if (heightScale2 !== this.oldHeightScale2 || x !== this.oldX2 || z !== this.oldZ2) {
			this.transform2.scale.setDirect(heightScale2, heightScale2, heightScale2);
			this.transform2.translation.x = x * heightScale2 / this.count;
			this.transform2.translation.z = z * heightScale2 / this.count;
			this.transform2.update();

			this.oldX2 = x;
			this.oldZ2 = z;
			this.oldHeightScale2 = heightScale2;
		}

		if (blender1 > blender2) {
			this.renderList[0] = this.grid1;
			this.renderList[1] = this.grid2;
		} else {
			this.renderList[0] = this.grid2;
			this.renderList[1] = this.grid1;
		}
	};

	GridRenderSystem.prototype.render = function (renderer/*, picking*/) {
		renderer.checkResize(this.camera);

		if (this.camera && this.doRender.grid) {
			renderer.render(this.renderList, this.camera, this.lights, null, false);
		}
	};

	GridRenderSystem.prototype.invalidateHandles = function (renderer) {
		this.renderList.forEach(function (renderable) {
			renderable.materials.forEach(function (material) {
				renderer.invalidateMaterial(material);
			});
			renderer.invalidateMeshData(renderable.meshData);
		});
	};

	var gridShaderDef = {
		attributes: {
			vertexPosition: MeshData.POSITION
		},
		uniforms: {
			viewMatrix: Shader.VIEW_MATRIX,
			projectionMatrix: Shader.PROJECTION_MATRIX,
			worldMatrix: Shader.WORLD_MATRIX,
			color: [0.55, 0.55, 0.55, 1],
			fogNear: Shader.NEAR_PLANE,
			fogFar: Shader.FAR_PLANE,
			opacity: 1,
			scale: 1
		},
		vshader: [
			'attribute vec3 vertexPosition;',

			'uniform mat4 worldMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat4 projectionMatrix;',

			'varying float depth;',

			'void main(void) {',
				'vec4 viewPosition = viewMatrix * worldMatrix * vec4(vertexPosition, 1.0);',

				'depth = -viewPosition.z;',

				'gl_Position = projectionMatrix * viewPosition;',
			'}'
		].join('\n'),
		fshader: [
			'precision mediump float;',

			'uniform vec4 color;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float opacity;',
			'uniform float scale;',

			'varying float depth;',

			'void main(void) {',
				'gl_FragColor = color;',
				'float lerpVal = 1.0 - clamp(depth * 3.0 / min(scale, fogFar * 3.0), 0.0, 1.0);',
				'gl_FragColor.a = opacity * lerpVal;',
			'}'
		].join('\n')
	};

	return GridRenderSystem;
})(goo.System,goo.SystemBus,goo.SimplePartitioner,goo.MeshData,goo.Material,goo.Shader,goo.ShaderLib,goo.ObjectUtils,goo.Transform,goo.MathUtils,goo.Grid);
goo.TextSystem = (function (
	System,
	TextureGrid,
	MeshDataComponent
) {
	'use strict';

	/**
	 * Processes all entities with a text component<br>
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/entities/components/TextComponent/TextComponent-vtest.html Working example
	 * @extends System
	 */
	function TextSystem() {
		System.call(this, 'TextSystem', ['TextComponent']);
	}

	TextSystem.prototype = Object.create(System.prototype);
	TextSystem.prototype.constructor = TextSystem;

	TextSystem.prototype.process = function (entities) {
		for (var i = 0; i < entities.length; i++) {
			var entity = entities[i];
			var textComponent = entity.textComponent;
			if (textComponent.dirty) {
				if (entity.hasComponent('MeshDataComponent')) {
					entity.getComponent('MeshDataComponent').meshData = TextureGrid.fromString(textComponent.text);
				}
				else {
					var meshData = TextureGrid.fromString(textComponent.text);
					var meshDataComponent = new MeshDataComponent(meshData);
					entity.setComponent(meshDataComponent);
				}
				this.dirty = false;
			}
		}
	};

	return TextSystem;
})(goo.System,goo.TextureGrid,goo.MeshDataComponent);
goo.Dom3dComponentHandler = (function (
	ComponentHandler,
	Dom3dComponent,
	RSVP,
	PromiseUtils
) {
	'use strict';

	/**
	 * For handling loading of Dom3d components
	 * @param {World} world The goo world
	 * @param {Function} getConfig The config loader function. See {@see DynamicLoader._loadRef}.
	 * @param {Function} updateObject The handler function. See {@see DynamicLoader.update}.
	 * @extends ComponentHandler
	 * @hidden
	 */
	function Dom3dComponentHandler() {
		ComponentHandler.apply(this, arguments);
		this._type = 'Dom3dComponent';
	}

	Dom3dComponentHandler.prototype = Object.create(ComponentHandler.prototype);
	ComponentHandler._registerClass('dom3d', Dom3dComponentHandler);
	Dom3dComponentHandler.prototype.constructor = Dom3dComponentHandler;

	/**
	 * Prepare component. Set defaults on config here.
	 * @param {Object} config
	 * @returns {Object}
	 * @private
	 */
	Dom3dComponentHandler.prototype._prepare = function (/*config*/) {};

	/**
	 * Create camera component object.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @returns {CameraComponent} the created component object
	 * @private
	 */
	Dom3dComponentHandler.prototype._create = function () {
		return new Dom3dComponent();
	};

	var regex = /\W/g;
	function getSafeEntityId(id) {
		// fancy chars (like '.') are allowed in ids in HTML but are not allowed in CSS
		return '__' + id.replace(regex, '-');
	}

	/**
	 * Update engine cameracomponent object based on the config.
	 * @param {Entity} entity The entity on which this component should be added.
	 * @param {Object} config
	 * @param {Object} options
	 * @returns {RSVP.Promise} promise that resolves with the component when loading is done.
	 */
	Dom3dComponentHandler.prototype.update = function (entity, config, options) {
		var that = this;
		return ComponentHandler.prototype.update.call(this, entity, config, options).then(function (component) {
			if (!component) { return; }

			// ids and classes can contain '.' or start with digits in html but not in css selectors
			// could have prefixed it with a simple '-' but that's sort of reserved for '-moz', '-webkit' and the like
			var safeEntityId = getSafeEntityId(entity.id);

			var domElement = component.domElement;
			if (!domElement) {
				domElement = document.createElement('div');
				domElement.id = safeEntityId;
				domElement.className = 'goo-entity';
				component.initDom(domElement);
			}
			component.setSize(config.width !== undefined ? config.width : 500, config.height !== undefined ? config.height : 500);

			var innerHtmlChanged = config.innerHtml !== domElement.prevInnerHtml;
			var styleChanged = config.style !== domElement.prevStyle;
			domElement.prevInnerHtml = config.innerHtml;
			domElement.prevStyle = config.style;

			if (entity.meshRendererComponent !== component.meshRendererComponent) {
				entity.setComponent(component.meshRendererComponent);
			}
			if (entity.meshDataComponent !== component.meshDataComponent) {
				entity.setComponent(component.meshDataComponent);
			}
			if (!innerHtmlChanged && !styleChanged) {
				return PromiseUtils.resolve();
			}

			var wrappedStyle = '';
			if (config.style) {
				var processedStyle = config.style.replace('__entity', '#' + safeEntityId);
				wrappedStyle = '<style>\n' + processedStyle + '\n</style>';
			}

			domElement.innerHTML = wrappedStyle + config.innerHtml;

			var children = domElement.childNodes;
			if (children.length === 1) {
				var child = children[0];
				if (!child.style.width) {
					child.style.width = "100%";
				}
				if (!child.style.height) {
					child.style.height = "100%";
				}
			}

			function loadImage(htmlImage, imageRef) {
				return that.loadObject(imageRef, options)
				.then(function (image) {
					htmlImage.src = image.src;
					return htmlImage;
				}, function (e) {
					console.error(e);
					delete htmlImage.src;
					return htmlImage;
				});
			}

			// Fix images.
			var images = domElement.getElementsByTagName('IMG');
			var imagePromises = [];
			for (var i = 0; i < images.length; i++) {
				var htmlImage = images[i];
				var imageRef = htmlImage.getAttribute('data-id');
				if (imageRef) {
					var promise = loadImage(htmlImage, imageRef);
					imagePromises.push(promise);
				}
			}

			return RSVP.all(imagePromises);
		});
	};

	Dom3dComponentHandler.prototype._remove = function (entity) {
		var component = entity.dom3dComponent;
		ComponentHandler.prototype._remove.call(this, entity);
		if (component.domElement && component.domElement.parentNode) {
			component.domElement.parentNode.removeChild(component.domElement);
		}

		if (entity.meshRendererComponent || entity.meshDataComponent) {
			entity.clearComponent('meshDataComponent');
			entity.clearComponent('meshRendererComponent');
		}
		component.destroy(this.world.gooRunner.renderer.context);
	};

	return Dom3dComponentHandler;
})(goo.ComponentHandler,goo.Dom3dComponent,goo.rsvp,goo.PromiseUtils);
goo.Spline = (function (
	Vector2,
	Vector3,
	Vector4
) {
	'use strict';

	/**
	 * Describes a cubic spline
	 * @param {Array<Vector>} controlPoints
	 */
	function Spline(controlPoints) {
		// array of any sort of Vector
		this.controlPoints = controlPoints;
		this.segments = (this.controlPoints.length - 1) / 3;
	}

	(function () {
		// should be of the same type as p0, p1, p2
		var term0_v4 = new Vector4();
		var term1_v4 = new Vector4();
		var term2_v4 = new Vector4();

		var term0_v3 = new Vector3();
		var term1_v3 = new Vector3();
		var term2_v3 = new Vector3();

		var term0_v2 = new Vector2();
		var term1_v2 = new Vector2();
		var term2_v2 = new Vector2();

		/**
		 * Interpolate on a quadratic Bezier curve
		 * @param {Vector} p0 First control point
		 * @param {Vector} p1 Second control point
		 * @param {Vector} p2 Third control point
		 * @param {number} t Takes values between 0 and 1
		 * @param {Vector} store Vector to store the result to
		 */
		Spline.quadraticInterpolation = function (p0, p1, p2, t, store) {
			// B(t) =
			// (1 - t)^2 * P0 +
			// 2 * (1 - t) * t * P1 +
			// t^2 * P2

			var t2 = t * t;

			var it = 1 - t;
			var it2 = it * it;

			if(store instanceof Vector4){
				p0.copyTo(term0_v4);
				term0_v4.scale(it2);

				p1.copyTo(term1_v4);
				term1_v4.scale(it * t * 2);

				p2.copyTo(term2_v4);
				term2_v4.scale(t2);

				store.set(term0_v4).add(term1_v4).add(term2_v4);
			} else if(store instanceof Vector3){
				p0.copyTo(term0_v3);
				term0_v3.scale(it2);

				p1.copyTo(term1_v3);
				term1_v3.scale(it * t * 2);

				p2.copyTo(term2_v3);
				term2_v3.scale(t2);

				store.set(term0_v3).add(term1_v3).add(term2_v3);
			} else if(store instanceof Vector2){
				p0.copyTo(term0_v2);
				term0_v2.scale(it2);

				p1.copyTo(term1_v2);
				term1_v2.scale(it * t * 2);

				p2.copyTo(term2_v2);
				term2_v2.scale(t2);

				store.set(term0_v2).add(term1_v2).add(term2_v2);
			}
		};
	})();

	(function () {
		// should be of the same type as p0, p1, p2, p3
		var term0_v4 = new Vector4();
		var term1_v4 = new Vector4();
		var term2_v4 = new Vector4();
		var term3_v4 = new Vector4();

		var term0_v3 = new Vector3();
		var term1_v3 = new Vector3();
		var term2_v3 = new Vector3();
		var term3_v3 = new Vector3();

		var term0_v2 = new Vector2();
		var term1_v2 = new Vector2();
		var term2_v2 = new Vector2();
		var term3_v2 = new Vector2();

		/**
		 * Interpolate on a quadratic Bezier curve
		 * @param {Vector} p0 First control point
		 * @param {Vector} p1 Second control point
		 * @param {Vector} p2 Third control point
		 * @param {Vector} p3 Fourth control point
		 * @param {number} t Takes values between 0 and 1
		 * @param {Vector} store Vector to store the result to
		 */
		Spline.cubicInterpolation = function (p0, p1, p2, p3, t, store) {
			// B(t) =
			// (1 - t)^3 * P0 +
			// 3 * (1 - t)^2 * t * P1 +
			// 3 * (1 - t) * t^2 * P2 +
			// t^3 * P3

			var t2 = t * t;
			var t3 = t2 * t;

			var it = 1 - t;
			var it2 = it * it;
			var it3 = it2 * it;

			if(store instanceof Vector4){
				p0.copyTo(term0_v4);
				term0_v4.scale(it3);

				p1.copyTo(term1_v4);
				term1_v4.scale(it2 * t * 3);

				p2.copyTo(term2_v4);
				term2_v4.scale(it * t2 * 3);

				p3.copyTo(term3_v4);
				term3_v4.scale(t3);

				store.set(term0_v4).add(term1_v4).add(term2_v4).add(term3_v4);
			} else if(store instanceof Vector3){
				p0.copyTo(term0_v3);
				term0_v3.scale(it3);

				p1.copyTo(term1_v3);
				term1_v3.scale(it2 * t * 3);

				p2.copyTo(term2_v3);
				term2_v3.scale(it * t2 * 3);

				p3.copyTo(term3_v3);
				term3_v3.scale(t3);

				store.set(term0_v3).add(term1_v3).add(term2_v3).add(term3_v3);
			} else if(store instanceof Vector2){
				p0.copyTo(term0_v2);
				term0_v2.scale(it3);

				p1.copyTo(term1_v2);
				term1_v2.scale(it2 * t * 3);

				p2.copyTo(term2_v2);
				term2_v2.scale(it * t2 * 3);

				p3.copyTo(term3_v2);
				term3_v2.scale(t3);

				store.set(term0_v2).add(term1_v2).add(term2_v2).add(term3_v2);
			}
		};
	})();

	/**
	 * Stores the coordinates of the point on the spline at a given t
	 * @param {number} t Takes values between 0 and 1
	 * @param {Vector} store A vector to store the result in
	 */
	Spline.prototype.getPoint = function (t, store) {
		if (t <= 0) {
			store.set(this.controlPoints[0]);
			return;
		} else if (t >= 1) {
			store.set(this.controlPoints[this.controlPoints.length - 1]);
			return;
		}

		var point = this.segments * t;
		var index = Math.floor(point);
		var fraction = point - index;

		var p0 = this.controlPoints[index * 3 + 0];
		var p1 = this.controlPoints[index * 3 + 1];
		var p2 = this.controlPoints[index * 3 + 2];
		var p3 = this.controlPoints[index * 3 + 3];

		Spline.cubicInterpolation(p0, p1, p2, p3, fraction, store);
	};

	return Spline;
})(goo.Vector2,goo.Vector3,goo.Vector4);
goo.SplineWalker = (function (
	Spline
) {
	'use strict';

	/**
	 * Provides a way to interpolate on a spline with constant speed
	 * @param {Spline} spline Spline to interpolate across
	 * @param {number} [substepSize=0.01] substepSize The size of the substep used to approximate movement across the spline.
	 * Small values of this parameter lead to more substeps and better precision (at the cost of more computations).
	 * @example-link http://code.gooengine.com/latest/visual-test/goo/math/SplineWalker/SplineWalker-vtest.html Comparison or normal interpolation vs using the SplineWalker
	 */
	function SplineWalker(spline, substepSize) {
		this.substepSize = substepSize || 0.01;
		this._spline = spline;
		this._segment = 0;
		this._localT = 0;
		this._pointer = spline.controlPoints[0].clone();
	}

	/**
	 * Performs interpolation according to the internal state
	 * @private
	 * @param {Vector} store
	 */
	SplineWalker.prototype._localInterpolation = function (store) {
		var p0 = this._spline.controlPoints[this._segment * 3 + 0];
		var p1 = this._spline.controlPoints[this._segment * 3 + 1];
		var p2 = this._spline.controlPoints[this._segment * 3 + 2];
		var p3 = this._spline.controlPoints[this._segment * 3 + 3];
		Spline.cubicInterpolation(p0, p1, p2, p3, this._localT, store);
	};

	/**
	 * Performs a step and updates the internal state
	 * @private
	 * @param {Vector} stepSize
	 * @param {Vector} store
	 */
	SplineWalker.prototype._step = function (stepSize, store) {
		this._localT += stepSize;

		if (this._localT > 1) {
			this._localT -= 1;
			this._segment++;

			if (this._segment >= this._spline.segments) {
				store.copy(this._spline.controlPoints[this._spline.controlPoints.length - 1]);
				return;
			}
		}

		this._localInterpolation(store);
	};

	/**
	 * Advances the walker by the provided distance and store the new location in the second parameter
	 * @param {number} distance Distance to "walk" on the spline; must be positive
	 * @param {Vector} store The vector to use to store the resulting position; must have the same type as the control points of the spline
	 */
	SplineWalker.prototype.advance = function (distance, store) {
		var walkedSoFar = 0;
		while (walkedSoFar < distance && this._segment < this._spline.segments) {
			this._step(this.substepSize, store);
			walkedSoFar += this._pointer.distance(store);
			this._pointer.copy(store);
		}
	};

	/**
	 * Returns whether the walker can still advance on the spline
	 * @returns {boolean}
	 */
	SplineWalker.prototype.canWalk = function () {
		return this._segment < this._spline.segments;
	};

	return SplineWalker;
})(goo.Spline);
goo.Composer = (function (
	RenderTarget,
	FullscreenPass,
	ShaderLib,
	SystemBus
) {
	'use strict';

	/**
	 * Post processing handler
	 * @param {RenderTarget} renderTarget Data to wrap
	 * @property {RenderTarget} renderTarget Data to wrap
	 */
	function Composer(renderTarget) {
		this._passedWriteBuffer = !!renderTarget;
		this.writeBuffer = renderTarget;

		if (this.writeBuffer === undefined) {
			var width = window.innerWidth || 1;
			var height = window.innerHeight || 1;

			this.writeBuffer = new RenderTarget(width, height);
		}

		this.readBuffer = this.writeBuffer.clone();

		this.passes = [];
		this._clearColor = [0, 0, 0, 1];
		this.copyPass = new FullscreenPass(ShaderLib.copy);

		this.size = null;
		this.dirty = false;

		this._viewportResizeHandler = function (size) {
			this.dirty = true;
			this.size = size;
		}.bind(this);

		SystemBus.addListener('goo.viewportResize', this._viewportResizeHandler, true);
	}

	/**
	 * Deallocate all allocated WebGL buffers, listeners, and passes.
	 * @param  {Renderer} renderer
	 */
	Composer.prototype.destroy = function (renderer) {
		this.deallocateBuffers(renderer);
		for (var i = 0; i < this.passes.length; i++) {
			var pass = this.passes[i];
			pass.destroy(renderer);
		}
		SystemBus.removeListener('goo.viewportResize', this._viewportResizeHandler);
	};

	/**
	 * Deallocate the read and write buffers.
	 * @param {Renderer} renderer
	 */
	Composer.prototype.deallocateBuffers = function (renderer) {
		if (this.writeBuffer && !this._passedWriteBuffer) {
			this.writeBuffer.destroy(renderer.context);
		}
		if (this.readBuffer) {
			this.readBuffer.destroy(renderer.context);
		}
		this.copyPass.destroy(renderer);
	};

	Composer.prototype.swapBuffers = function () {
		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;
	};

	Composer.prototype._checkPassResize = function (pass, size) {
		return !pass.viewportSize ||
			pass.viewportSize.x !== size.x ||
			pass.viewportSize.y !== size.y ||
			pass.viewportSize.width !== size.width ||
			pass.viewportSize.height !== size.height;
	};

	Composer.prototype.addPass = function (pass, renderer) {
		this.passes.push(pass);
		if (pass.updateSize && this.size && this._checkPassResize(pass, this.size)) {
			pass.updateSize(this.size, renderer);
			pass.viewportSize = this.size;
		}
	};

	Composer.prototype.setClearColor = function (color) {
		this._clearColor[0] = color[0];
		this._clearColor[1] = color[1];
		this._clearColor[2] = color[2];
		this._clearColor[3] = color[3];
	};

	Composer.prototype.updateSize = function (renderer) {
		var size = this.size;
		if (!size) {
			return;
		}
		var width = size.width;
		var height = size.height;

		this.deallocateBuffers(renderer);

		this.writeBuffer = new RenderTarget(width, height);
		this.readBuffer = this.writeBuffer.clone();

		for (var i = 0, il = this.passes.length; i < il; i++) {
			var pass = this.passes[i];
			if (pass.updateSize && this._checkPassResize(pass, size)) {
				pass.updateSize(size, renderer);
				pass.viewportSize = size;
			}
		}
	};

	Composer.prototype.render = function (renderer, delta, camera, lights) {
		if (this.dirty) {
			this.updateSize(renderer);
			this.dirty = false;
		}

		var maskActive = false;
		var pass, i, il = this.passes.length;

		for (i = 0; i < il; i++) {
			pass = this.passes[i];
			if (!pass.enabled) {
				continue;
			}

			pass.render(renderer, this.writeBuffer, this.readBuffer, delta, maskActive, camera, lights, this._clearColor);

			if (pass.needsSwap) {
				if (maskActive) {
					var context = this.renderer.context;
					context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);
					this.copyPass.render(renderer, this.writeBuffer, this.readBuffer, delta, camera, lights);
					context.stencilFunc(context.EQUAL, 1, 0xffffffff);
				}
				this.swapBuffers();
			}
		}
	};

	return Composer;
})(goo.RenderTarget,goo.FullscreenPass,goo.ShaderLib,goo.SystemBus);
goo.FullscreenUtil = (function (
	FullscreenUtils
) {
	'use strict';

	/**
	 * Fullscreen-related utilities
	 * @target-class FullscreenUtil FullscreenUtil constructor
	 * @require-path goo/renderer/pass/FullscreenUtil
	 * @group renderer/pass
	 * @deprecated Deprecated as of 0.14.x and scheduled for removal in 0.16.0; The class has been renamed to `goo/util/FullscreenUtils`
	 */
	return FullscreenUtils;
})(goo.FullscreenUtils);
goo.RenderPass = (function (
	Renderer,
	Pass,
	Vector4
) {
	'use strict';

	/**
	 * A pass that renders provided renderlist to the rendertarget or screen
	 */
	function RenderPass(renderList, filter) {
		this.renderList = renderList;
		this.filter = filter;

		this.clearColor = new Vector4(0.0, 0.0, 0.0, 0.0);
		this.oldClearColor = new Vector4();
		this.renderToScreen = false;

		this.overrideMaterial = null;

		this.enabled = true;
		this.clear = true;
		this.needsSwap = false;
		this.viewportSize = undefined;
	}

	RenderPass.prototype = Object.create(Pass.prototype);
	RenderPass.prototype.constructor = RenderPass;

	// RenderPasses may have a fourth additional parameter called delta
	RenderPass.prototype.render = function (renderer, writeBuffer, readBuffer, delta, maskActive, camera, lights, clearColor) {
		camera = camera || Renderer.mainCamera;

		if (!camera) {
			return;
		}

		lights = lights || [];
		if (clearColor && false) {
			this.oldClearColor.set(renderer.clearColor);
			renderer.setClearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
		}

		var renderList;
		if (this.filter) {
			renderList = this.renderList.filter(this.filter);
		} else {
			renderList = this.renderList;
		}
		if (this.renderToScreen) {
			renderer.render(renderList, camera, lights, null, this.clear, this.overrideMaterial);
		} else {
			renderer.render(renderList, camera, lights, readBuffer, this.clear, this.overrideMaterial);
		}

		if (this.clearColor && false) {
			renderer.setClearColor(this.oldClearColor.x, this.oldClearColor.y, this.oldClearColor.z, this.oldClearColor.w);
		}
	};

	return RenderPass;
})(goo.Renderer,goo.Pass,goo.Vector4);
goo.Rectangle = (function () {
	'use strict';

	/**
	 * Rectangle
	 * @hidden
	 * @param {number} x
	 * @param {number} y
	 * @param {number} w Width
	 * @param {number} h Height
	 */
	function Rectangle(x, y, w, h) {
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
	}

	return Rectangle;
})();
goo.AtlasNode = (function (
	Rectangle
) {
	'use strict';

	/**
	 * Atlas node
	 * @hidden
	 * @param w
	 * @param h
	 */
	function AtlasNode(w, h) {
		this.isLeaf = true;
		this.isSet = false;
		this.children = [];
		if (w !== undefined && h !== undefined) {
			this.localRectangle = new Rectangle(0, 0, w, h);
		} else {
			this.localRectangle = null;
		}
	}

	AtlasNode.prototype.getRectangles = function () {
		var rectangles = [];
		this._getRectangles(rectangles);
		return rectangles;
	};

	AtlasNode.prototype._getRectangles = function (list) {
		if (this.isSet) {
			list.push(this.localRectangle);
		}
		if (!this.isLeaf) {
			this.children[0]._getRectangles(list);
			this.children[1]._getRectangles(list);
		}
	};

	AtlasNode.prototype.insert = function (w, h) {
		return this._insert(new Rectangle(0, 0, w, h));
	};

	AtlasNode.prototype._insert = function (rectangle) {
		if (!this.isLeaf) {
			var newNode = this.children[0]._insert(rectangle);
			if (newNode !== null) {
				return newNode;
			}

			return this.children[1]._insert(rectangle);
		} else {
			if (this.isSet) {
				return null;
			}

			if (rectangle.w > this.localRectangle.w || rectangle.h > this.localRectangle.h) {
				return null;
			}

			if (rectangle.w === this.localRectangle.w && rectangle.h === this.localRectangle.h) {
				this.isSet = true;
				return this;
			}

			this.isLeaf = false;

			this.children[0] = new AtlasNode();
			this.children[1] = new AtlasNode();

			var dw = this.localRectangle.w - rectangle.w;
			var dh = this.localRectangle.h - rectangle.h;

			if (dw > dh) {
				this.children[0].localRectangle = new Rectangle(this.localRectangle.x, this.localRectangle.y, rectangle.w, this.localRectangle.h);
				this.children[1].localRectangle = new Rectangle(this.localRectangle.x + rectangle.w, this.localRectangle.y, dw, this.localRectangle.h);
			} else {
				this.children[0].localRectangle = new Rectangle(this.localRectangle.x, this.localRectangle.y, this.localRectangle.w, rectangle.h);
				this.children[1].localRectangle = new Rectangle(this.localRectangle.x, this.localRectangle.y + rectangle.h, this.localRectangle.w, dh);
			}

			return this.children[0]._insert(rectangle);
		}
	};

	return AtlasNode;
})(goo.Rectangle);
goo.EntityCombiner = (function (
	EntityUtils,
	Entity,
	MeshBuilder,
	Transform,
	Vector3,
	BoundingBox,
	BoundingSphere
) {
	'use strict';

	/**
	 * Runs a mesh combine optimization on the whole scene, based on
	 * material, components etc
	 * @param {World} gooWorld An instance of a goo.world object
	 * @param {number} [gridCount=1] Number of grid segments to split the world in during combine
	 * @param {boolean} [removeOldData=true] Remove old data which is now unused after combining
	 * @param {boolean} [keepEntities=false] Keep all entities even if they are unused after combine
	 */
	function EntityCombiner(gooWorld, gridCount, removeOldData, keepEntities) {
		this.world = gooWorld;
		this.gridCount = gridCount || 1;
		this.gridSize = 1;
		this.removeOldData = removeOldData !== undefined ? removeOldData : true;
		this.keepEntities = keepEntities !== undefined ? keepEntities : false;
		this.createdEntities = [];
	}

	/**
	 * Runs the combiner
	 */
	EntityCombiner.prototype.combine = function () {
		this.world.processEntityChanges();
		this.world.getSystem('TransformSystem')._process();
		this.world.getSystem('BoundingUpdateSystem')._process();

		var topEntities = this.world.entityManager.getTopEntities();
		if (this.gridSize > 1) {
			this.gridSize = this._calculateBounds(topEntities) / this.gridCount;
		}
		this._combineList(topEntities);
	};

	EntityCombiner.prototype._combineList = function (entities) {
		var root = entities;
		this.createdEntities = [];
		if (entities instanceof Entity === true) {
			root = [entities];
		}

		var baseSubs = new Map();
		var subs = [];
		for (var i = 0; i < root.length; i++) {
			this._buildSubs(root[i], baseSubs, subs);
		}
		if (subs.length > 1) {
			root = this.world.createEntity('RootCombined').addToWorld();
			baseSubs.put(root, subs);
		}

		var keys = baseSubs.getKeys();
		for (var i = 0; i < keys.length; i++) {
			var entity = keys[i];
			var combineList = baseSubs.get(entity);
			if (combineList.length > 0) {
				this._combine(entity, combineList);
			}
		}
	};

	EntityCombiner.prototype._buildSubs = function (entity, baseSubs, subs) {
		if (entity._hidden || entity.skip || entity.animationComponent || entity.particleComponent) {
			return;
		}

		// Non static entities become roots in the tree of combined ones so one can have statics under a moving node that combines but you can still move the parent node.
		if (!subs || entity.static === false) {
			subs = [];
			baseSubs.put(entity, subs);
		}

		if (entity.static && entity.meshDataComponent && entity.meshRendererComponent &&
			entity.meshRendererComponent.worldBound) {
			subs.push(entity);
		}

		for (var i = 0; i < entity.transformComponent.children.length; i++) {
			var child = entity.transformComponent.children[i];
			this._buildSubs(child.entity, baseSubs, subs);
		}
	};

	EntityCombiner.prototype._combine = function (root, combineList) {
		var rootTransform = root.transformComponent.worldTransform;
		var invertTransform = new Transform();
		var calcTransform = new Transform();
		rootTransform.invert(invertTransform);

		var entities = new Map();
		for (var i = 0; i < combineList.length; i++) {
			var entity = combineList[i];

			var key = entity.meshRendererComponent.materials[0];

			var attributeMap = entity.meshDataComponent.meshData.attributeMap;
			var key2 = Object.keys(attributeMap);
			key2.sort();
			key2 = key2.join('_');

			if (this.gridSize > 1) {
				var xBucket = entity.meshRendererComponent.worldBound.center.x / this.gridSize;
				var zBucket = entity.meshRendererComponent.worldBound.center.z / this.gridSize;
				key2 = key2 + '_' + Math.round(xBucket) + '_' + Math.round(zBucket);
			}

			var set = entities.get(key);
			if (!set) {
				set = new Map();
				entities.put(key, set);
			}
			var set2 = set.get(key2);
			if (!set2) {
				set2 = [];
				set.put(key2, set2);
			}

			set2.push(entity);
		}

		var sets = entities.getKeys();
		for (var i = 0; i < sets.length; i++) {
			var material = sets[i];
			var entities2 = entities.get(material);
			var sets2 = entities2.getKeys();
			for (var j = 0; j < sets2.length; j++) {
				var toCombine = entities2.get(sets2[j]);

				if (toCombine.length === 1) {
					continue;
				}

				var meshBuilder = new MeshBuilder();
				for (var k = 0; k < toCombine.length; k++) {
					var entity = toCombine[k];

					if (root !== entity) {
						calcTransform.multiply(invertTransform, entity.transformComponent.worldTransform);
					} else {
						calcTransform.setIdentity();
					}

					meshBuilder.addMeshData(entity.meshDataComponent.meshData, calcTransform);

					if (this.removeOldData) {
						entity.clearComponent('meshDataComponent');
						entity.clearComponent('meshRendererComponent');

						// Remove empty leaf children
						if (!this.keepEntities && entity._components.length === 1 && entity.transformComponent.children.length === 0) {
							entity.removeFromWorld();
						}
					} else {
						entity.skip = true;
						entity._hidden = true;
					}
				}
				var meshDatas = meshBuilder.build();

				for (var key in meshDatas) {
					var entity = this.world.createEntity(meshDatas[key], material);
					entity.addToWorld();
					root.attachChild(entity);
					this.createdEntities.push(entity);
				}
			}
		}
	};

	EntityCombiner.prototype._calculateBounds = function (entities) {
		var first = true;
		var wb = new BoundingBox();
		for (var i = 0; i < entities.length; i++) {
			var rootEntity = entities[i];
			rootEntity.traverse(function (entity) {
				if (entity.meshRendererComponent && !entity.particleComponent) {
					if (first) {
						var bound = entity.meshRendererComponent.worldBound;
						if (bound instanceof BoundingBox) {
							wb.copy(bound);
						} else if (bound instanceof BoundingSphere) {
							wb.center.set(bound.center);
							wb.xExtent = wb.yExtent = wb.zExtent = bound.radius;
						} else {
							wb.center.set(Vector3.ZERO);
							wb.xExtent = wb.yExtent = wb.zExtent = 10;
						}

						first = false;
					} else {
						wb.merge(entity.meshRendererComponent.worldBound);
					}
				}
			});
		}
		return Math.max(wb.xExtent, wb.zExtent) * 2.0;
	};

	EntityCombiner.prototype.cleanup = function (entities) {
		for (var i = 0; i < this.createdEntities.length; i++) {
			var entity = this.createdEntities[i];

			entity.removeFromWorld();

			entity.parent().each(function (parent) {
				parent.detachChild(entity);
			});
		}
	};

	function Map() {
		var keys = [],
			values = [];

		return {
			put: function (key, value) {
				var index = keys.indexOf(key);
				if (index === -1) {
					keys.push(key);
					values.push(value);
				} else {
					values[index] = value;
				}
			},
			get: function (key) {
				return values[keys.indexOf(key)];
			},
			getKeys: function () {
				return keys;
			},
			getValues: function () {
				return values;
			}
		};
	}

	return EntityCombiner;
})(goo.EntityUtils,goo.Entity,goo.MeshBuilder,goo.Transform,goo.Vector3,goo.BoundingBox,goo.BoundingSphere);
if (typeof require === "function") {
define("goo/entities/Selection", [], function () { return goo.Selection; });
define("goo/entities/EntitySelection", [], function () { return goo.EntitySelection; });
define("goo/entities/components/Component", [], function () { return goo.Component; });
define("goo/util/StringUtils", [], function () { return goo.StringUtils; });
define("goo/entities/Entity", [], function () { return goo.Entity; });
define("goo/entities/Bus", [], function () { return goo.Bus; });
define("goo/util/ObjectUtils", [], function () { return goo.ObjectUtils; });
define("goo/scripts/ScriptUtils", [], function () { return goo.ScriptUtils; });
define("goo/scripts/Scripts", [], function () { return goo.Scripts; });
define("goo/math/MathUtils", [], function () { return goo.MathUtils; });
define("goo/math/Vector", [], function () { return goo.Vector; });
define("goo/math/Vector4", [], function () { return goo.Vector4; });
define("goo/math/Vector3", [], function () { return goo.Vector3; });
define("goo/renderer/bounds/BoundingVolume", [], function () { return goo.BoundingVolume; });
define("goo/renderer/Capabilities", [], function () { return goo.Capabilities; });
define("goo/renderer/BufferUtils", [], function () { return goo.BufferUtils; });
define("goo/renderer/BufferData", [], function () { return goo.BufferData; });
define("goo/renderer/RendererUtils", [], function () { return goo.RendererUtils; });
define("goo/math/Vector2", [], function () { return goo.Vector2; });
define("goo/renderer/MeshData", [], function () { return goo.MeshData; });
define("goo/renderer/bounds/BoundingSphere", [], function () { return goo.BoundingSphere; });
define("goo/renderer/bounds/BoundingBox", [], function () { return goo.BoundingBox; });
define("goo/entities/EntityUtils", [], function () { return goo.EntityUtils; });
define("goo/entities/managers/Manager", [], function () { return goo.Manager; });
define("goo/entities/managers/EntityManager", [], function () { return goo.EntityManager; });
define("goo/math/Matrix", [], function () { return goo.Matrix; });
define("goo/math/Matrix3", [], function () { return goo.Matrix3; });
define("goo/math/Matrix4", [], function () { return goo.Matrix4; });
define("goo/math/Transform", [], function () { return goo.Transform; });
define("goo/entities/components/TransformComponent", [], function () { return goo.TransformComponent; });
define("goo/entities/systems/System", [], function () { return goo.System; });
define("goo/entities/World", [], function () { return goo.World; });
define("goo/renderer/RendererRecord", [], function () { return goo.RendererRecord; });
define("goo/util/rsvp", [], function () { return goo.rsvp; });
define("goo/util/PromiseUtils", [], function () { return goo.PromiseUtils; });
define("goo/renderer/Texture", [], function () { return goo.Texture; });
define("goo/loaders/handlers/ConfigHandler", [], function () { return goo.ConfigHandler; });
define("goo/loaders/dds/DdsUtils", [], function () { return goo.DdsUtils; });
define("goo/loaders/dds/DdsLoader", [], function () { return goo.DdsLoader; });
define("goo/loaders/crunch/CrunchLoader", [], function () { return goo.CrunchLoader; });
define("goo/loaders/tga/TgaLoader", [], function () { return goo.TgaLoader; });
define("goo/util/CanvasUtils", [], function () { return goo.CanvasUtils; });
define("goo/entities/SystemBus", [], function () { return goo.SystemBus; });
define("goo/loaders/handlers/TextureHandler", [], function () { return goo.TextureHandler; });
define("goo/util/Ajax", [], function () { return goo.Ajax; });
define("goo/renderer/TextureCreator", [], function () { return goo.TextureCreator; });
define("goo/util/ObjectUtil", [], function () { return goo.ObjectUtil; });
define("goo/renderer/pass/RenderTarget", [], function () { return goo.RenderTarget; });
define("goo/renderer/ShaderCall", [], function () { return goo.ShaderCall; });
define("goo/renderer/RenderQueue", [], function () { return goo.RenderQueue; });
define("goo/renderer/Shader", [], function () { return goo.Shader; });
define("goo/renderer/Material", [], function () { return goo.Material; });
define("goo/renderer/shaders/ShaderFragment", [], function () { return goo.ShaderFragment; });
define("goo/renderer/light/Light", [], function () { return goo.Light; });
define("goo/renderer/light/PointLight", [], function () { return goo.PointLight; });
define("goo/renderer/light/DirectionalLight", [], function () { return goo.DirectionalLight; });
define("goo/renderer/light/SpotLight", [], function () { return goo.SpotLight; });
define("goo/util/TangentGenerator", [], function () { return goo.TangentGenerator; });
define("goo/renderer/shaders/ShaderBuilder", [], function () { return goo.ShaderBuilder; });
define("goo/renderer/shaders/ShaderLib", [], function () { return goo.ShaderLib; });
define("goo/shapes/Quad", [], function () { return goo.Quad; });
define("goo/math/Plane", [], function () { return goo.Plane; });
define("goo/math/Ray", [], function () { return goo.Ray; });
define("goo/renderer/Camera", [], function () { return goo.Camera; });
define("goo/renderer/pass/FullscreenUtils", [], function () { return goo.FullscreenUtils; });
define("goo/renderer/pass/Pass", [], function () { return goo.Pass; });
define("goo/renderer/pass/FullscreenPass", [], function () { return goo.FullscreenPass; });
define("goo/renderer/shadow/ShadowHandler", [], function () { return goo.ShadowHandler; });
define("goo/renderer/RenderStats", [], function () { return goo.RenderStats; });
define("goo/renderer/TaskScheduler", [], function () { return goo.TaskScheduler; });
define("goo/renderer/RenderInfo", [], function () { return goo.RenderInfo; });
define("goo/renderer/Renderer", [], function () { return goo.Renderer; });
define("goo/entities/systems/TransformSystem", [], function () { return goo.TransformSystem; });
define("goo/renderer/SimplePartitioner", [], function () { return goo.SimplePartitioner; });
define("goo/entities/systems/RenderSystem", [], function () { return goo.RenderSystem; });
define("goo/entities/systems/BoundingUpdateSystem", [], function () { return goo.BoundingUpdateSystem; });
define("goo/entities/systems/ScriptSystem", [], function () { return goo.ScriptSystem; });
define("goo/entities/systems/LightingSystem", [], function () { return goo.LightingSystem; });
define("goo/entities/systems/CameraSystem", [], function () { return goo.CameraSystem; });
define("goo/entities/systems/ParticlesSystem", [], function () { return goo.ParticlesSystem; });
define("goo/util/Stats", [], function () { return goo.Stats; });
define("goo/sound/AudioContext", [], function () { return goo.AudioContext; });
define("goo/entities/systems/SoundSystem", [], function () { return goo.SoundSystem; });
define("goo/entities/components/MeshDataComponent", [], function () { return goo.MeshDataComponent; });
define("goo/entities/components/MeshRendererComponent", [], function () { return goo.MeshRendererComponent; });
define("goo/entities/components/CameraComponent", [], function () { return goo.CameraComponent; });
define("goo/entities/components/LightComponent", [], function () { return goo.LightComponent; });
define("goo/entities/components/ScriptComponent", [], function () { return goo.ScriptComponent; });
define("goo/entities/components/SoundComponent", [], function () { return goo.SoundComponent; });
define("goo/util/GameUtils", [], function () { return goo.GameUtils; });
define("goo/util/Logo", [], function () { return goo.Logo; });
define("goo/entities/GooRunner", [], function () { return goo.GooRunner; });
define("goo/loaders/handlers/ComponentHandler", [], function () { return goo.ComponentHandler; });
define("goo/util/ArrayUtils", [], function () { return goo.ArrayUtils; });
define("goo/shapes/Box", [], function () { return goo.Box; });
define("goo/shapes/Sphere", [], function () { return goo.Sphere; });
define("goo/shapes/Cylinder", [], function () { return goo.Cylinder; });
define("goo/shapes/Torus", [], function () { return goo.Torus; });
define("goo/shapes/Disk", [], function () { return goo.Disk; });
define("goo/shapes/Cone", [], function () { return goo.Cone; });
define("goo/util/ShapeCreatorMemoized", [], function () { return goo.ShapeCreatorMemoized; });
define("goo/loaders/handlers/CameraComponentHandler", [], function () { return goo.CameraComponentHandler; });
define("goo/loaders/handlers/EntityHandler", [], function () { return goo.EntityHandler; });
define("goo/loaders/handlers/LightComponentHandler", [], function () { return goo.LightComponentHandler; });
define("goo/loaders/handlers/MaterialHandler", [], function () { return goo.MaterialHandler; });
define("goo/loaders/handlers/MeshDataComponentHandler", [], function () { return goo.MeshDataComponentHandler; });
define("goo/loaders/handlers/MeshDataHandler", [], function () { return goo.MeshDataHandler; });
define("goo/loaders/handlers/MeshRendererComponentHandler", [], function () { return goo.MeshRendererComponentHandler; });
define("goo/loaders/handlers/SceneHandler", [], function () { return goo.SceneHandler; });
define("goo/loaders/handlers/ShaderHandler", [], function () { return goo.ShaderHandler; });
define("goo/loaders/handlers/TransformComponentHandler", [], function () { return goo.TransformComponentHandler; });
define("goo/loaders/handlers/ProjectHandler", [], function () { return goo.ProjectHandler; });
define("goo/loaders/handlers/SoundComponentHandler", [], function () { return goo.SoundComponentHandler; });
define("goo/util/PromiseUtil", [], function () { return goo.PromiseUtil; });
define("goo/sound/Sound", [], function () { return goo.Sound; });
define("goo/loaders/handlers/SoundHandler", [], function () { return goo.SoundHandler; });
define("goo/particles/ParticleLib", [], function () { return goo.ParticleLib; });
define("goo/particles/ParticleUtils", [], function () { return goo.ParticleUtils; });
define("goo/particles/Particle", [], function () { return goo.Particle; });
define("goo/particles/ParticleEmitter", [], function () { return goo.ParticleEmitter; });
define("goo/entities/components/ParticleComponent", [], function () { return goo.ParticleComponent; });
define("goo/util/ParticleSystemUtils", [], function () { return goo.ParticleSystemUtils; });
define("goo/util/Snow", [], function () { return goo.Snow; });
define("goo/loaders/handlers/EnvironmentHandler", [], function () { return goo.EnvironmentHandler; });
define("goo/util/Skybox", [], function () { return goo.Skybox; });
define("goo/loaders/handlers/SkyboxHandler", [], function () { return goo.SkyboxHandler; });
define("goo/entities/components/HtmlComponent", [], function () { return goo.HtmlComponent; });
define("goo/loaders/handlers/HtmlComponentHandler", [], function () { return goo.HtmlComponentHandler; });
define("goo/loaders/DynamicLoader", [], function () { return goo.DynamicLoader; });
define("goo/math/Matrix2", [], function () { return goo.Matrix2; });
define("goo/math/Matrix2x2", [], function () { return goo.Matrix2x2; });
define("goo/math/Matrix3x3", [], function () { return goo.Matrix3x3; });
define("goo/math/Matrix4x4", [], function () { return goo.Matrix4x4; });
define("goo/math/Quaternion", [], function () { return goo.Quaternion; });
define("goo/noise/Noise", [], function () { return goo.Noise; });
define("goo/noise/ValueNoise", [], function () { return goo.ValueNoise; });
define("goo/particles/ParticleInfluence", [], function () { return goo.ParticleInfluence; });
define("goo/picking/BoundingTree", [], function () { return goo.BoundingTree; });
define("goo/picking/PrimitivePickLogic", [], function () { return goo.PrimitivePickLogic; });
define("goo/renderer/Renderer+ContextLost", [], function () { return goo.RendererContextLost; });
define("goo/scripts/OrbitCamControlScript", [], function () { return goo.OrbitCamControlScript; });
define("goo/shapes/Grid", [], function () { return goo.Grid; });
define("goo/shapes/SimpleBox", [], function () { return goo.SimpleBox; });
define("goo/shapes/TextureGrid", [], function () { return goo.TextureGrid; });
define("goo/sound/OscillatorSound", [], function () { return goo.OscillatorSound; });
define("goo/util/ArrayUtil", [], function () { return goo.ArrayUtil; });
define("goo/util/EventTarget", [], function () { return goo.EventTarget; });
define("goo/util/MeshBuilder", [], function () { return goo.MeshBuilder; });
define("goo/util/Rc4Random", [], function () { return goo.Rc4Random; });
define("goo/util/SoundCreator", [], function () { return goo.SoundCreator; });
define("goo/util/StringUtil", [], function () { return goo.StringUtil; });
define("goo/util/TWEEN", [], function () { return goo.TWEEN; });
define("goo/entities/components/CssTransformComponent", [], function () { return goo.CssTransformComponent; });
define("goo/entities/components/Dom3dComponent", [], function () { return goo.Dom3dComponent; });
define("goo/entities/components/MovementComponent", [], function () { return goo.MovementComponent; });
define("goo/entities/components/PortalComponent", [], function () { return goo.PortalComponent; });
define("goo/entities/components/TextComponent", [], function () { return goo.TextComponent; });
define("goo/entities/systems/CssTransformSystem", [], function () { return goo.CssTransformSystem; });
define("goo/entities/systems/Dom3dSystem", [], function () { return goo.Dom3dSystem; });
define("goo/entities/systems/HtmlSystem", [], function () { return goo.HtmlSystem; });
define("goo/entities/systems/MovementSystem", [], function () { return goo.MovementSystem; });
define("goo/entities/systems/PickingSystem", [], function () { return goo.PickingSystem; });
define("goo/entities/systems/PortalSystem", [], function () { return goo.PortalSystem; });
define("goo/entities/systems/GridRenderSystem", [], function () { return goo.GridRenderSystem; });
define("goo/entities/systems/TextSystem", [], function () { return goo.TextSystem; });
define("goo/loaders/handlers/Dom3dComponentHandler", [], function () { return goo.Dom3dComponentHandler; });
define("goo/math/splines/Spline", [], function () { return goo.Spline; });
define("goo/math/splines/SplineWalker", [], function () { return goo.SplineWalker; });
define("goo/renderer/pass/Composer", [], function () { return goo.Composer; });
define("goo/renderer/pass/FullscreenUtil", [], function () { return goo.FullscreenUtil; });
define("goo/renderer/pass/RenderPass", [], function () { return goo.RenderPass; });
define("goo/util/combine/Rectangle", [], function () { return goo.Rectangle; });
define("goo/util/combine/AtlasNode", [], function () { return goo.AtlasNode; });
define("goo/util/combine/EntityCombiner", [], function () { return goo.EntityCombiner; });
}

